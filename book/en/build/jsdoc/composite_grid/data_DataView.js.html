<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: data/DataView.js</title>

    <script src="scripts/prettify.js"> </script>
    <script src="scripts/lang-css.js"> </script>
    <!--[if lt IE 9]&gt;
      &lt;script src="//html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
    &lt;![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/default.css">
    <link type="text/css" rel="stylesheet" href="styles/elf-template.css">
</head>

<body>

<div id="main-template" class="elf-template">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>goog.provide("tr.DataView");
goog.require("tr.DataTable");
goog.require("tr.DataCache");
goog.require("tr.WrappedView");
goog.require("tr.ColumnStats");
goog.require("tr.EventDispatcher");
goog.require("tr.grid.util");

/** @event tr.DataView#dataChanged
* @description Trigger when data within the data view has been changed. Not only actual change in data, but also position change will trigger this event.
* @property {boolean} globalChange Indicates a big change. User should expect all data has been change. With active sorting or filtering, this flag will always be true due to multiple changes in row position.
* @property {string} type Type of changes. Possible values are "inserted", "removed", "updated", and undefined
* @property {string} rid Row Id
* @property {Object.&lt;string, *&gt;} rowData Column values of the changed row in JSON object format
*/
/** @event tr.DataView#pageIndexChanged
* @property {number} pageIndex
*/
/** @event tr.DataView#pageCountChanged
* @property {number} pageCount
*/
/** @event tr.DataView#preDisposed
*/
/** @event tr.DataView#groupAdded
* @property {tr.DataView} dataView Parent data view that create the new group
* @property {tr.DataView} newGroup Child data view that is newly created
*/
/** @event tr.DataView#beforeGroupAdded
* @description Fired each time before group added. Set property `cancel` to true to cancel adding of the new group
* @type {Object}
* @property {tr.DataView} dataView Parent data view that create the new group
* @property {string} newGroupId
* @property {*} newGroupValue
* @property {string} newGroupRowId Unique row Id given for the group
*/
/** @event tr.DataView#groupCriteriaChanged
* @type {Object}
*/
/** @event tr.DataView#beforeFiltering
* @description Fired once before actual row filtering (before multiple execution of filter logic). This allow optimization by preparing data needed for the filtering
* @type {Object}
*/
/** @event tr.DataView#wrapCountChanged
* @property {number} prevCount
* @property {number} newCount
*/
/** @event tr.DataView#wrapSizeChanged
* @property {number} wrapSize
* @property {Array.&lt;string&gt;} rids
*/

/** DataView doesn't hold the actual data. It is just a transform view (by applying filtering or sorting) of the data from the {@link tr.DataTable}
* @constructor
* @extends {tr.EventDispatcher}
* @param {tr.DataTable|tr.DataView=} source
* @see {@link tr.DataTable}
*/
tr.DataView = function(source) {
	var t = this; // For file minification
	t._groupFilterLogic = t._groupFilterLogic.bind(t);
	t._internalGroupSortingLogic = t._internalGroupSortingLogic.bind(t);

	t._onDataChanged = t._onDataChanged.bind(t);
	t._onGroupAdded = t._onGroupAdded.bind(t);
	t._onBeforeGroupAdded = t._onBeforeGroupAdded.bind(t);
	t._onRefreshTimeout = t._onRefreshTimeout.bind(t);
	t._updateWrapCount = t._updateWrapCount.bind(t);

	t._rids = [];
	t._sortingDefs = [];
	t._columnStats = {};
	t._shared = {};

	t._conflator = new tr.grid.Conflator(this._onDataChanged, 0);
	t._conflator.disable();

	t._addEvents("dataChanged",
		"preDisposed",
		"pageIndexChanged",
		"pageCountChanged",
		"groupAdded",
		"beforeGroupAdded",
		"groupCriteriaChanged",
		"beforeFiltering",
		"wrapCountChanged",
		"wrapSizeChanged"
	);

	t.setDataSource(source);
};
goog.inherits(tr.DataView, tr.EventDispatcher);

/** List of row Ids with filtering and sorting transformation
* @private
* @type {!Array.&lt;string&gt;}
*/
tr.DataView.prototype._rids; // Contains only data rows that have been filtered
/** List of row Ids with grouping transformation
* @private
* @type {Array.&lt;string&gt;}
*/
tr.DataView.prototype._groupView = null; // Contains non-data rows (e.g. group headers, group footers) and exclude collapsed group data rows
/** List of row Ids with paging transformation
* @private
* @type {Array.&lt;string&gt;}
*/
tr.DataView.prototype._pageView = null; // Cut-off version of _rids or _groupView
/** List of row Ids with expanding transformation
* @private
* @type {Array.&lt;string&gt;}
*/
tr.DataView.prototype._expansionView = null; // The rids with row expansion

/** @private
* @type {Object.&lt;string, boolean&gt;}
*/
tr.DataView.prototype._hiddenRids = null;
/** @private
* @type {Object.&lt;string, boolean&gt;}
*/
tr.DataView.prototype._collapsedRids = null; // For Segmentation
/** @private
* @type {Object.&lt;string, number&gt;}
*/
tr.DataView.prototype._expansionMap = null;
/** @private
* @type {Object.&lt;string, string&gt;}
*/
tr.DataView.prototype._expansionChildren = null;
/** @private
* @type {number}
*/
tr.DataView.prototype._expansionCount = 0;

/** @private
* @type {tr.DataTable}
*/
tr.DataView.prototype._dt = null;
/** @private
* @type {tr.DataTable|tr.DataView}
*/
tr.DataView.prototype._parent = null;
/** @private
* @type {Object}
*/
tr.DataView.prototype._shared = null; // Shared options between data view in the same hierarchy

/** @private
* @type {Array.&lt;Array&gt;}
*/
tr.DataView.prototype._sortingDefs = null;

/** @private
* @type {function(string, Object.&lt;string, *&gt;)|null}
*/
tr.DataView.prototype._userFilter = null;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._filteringOut = false;

/** @private
* @type {number}
*/
tr.DataView.prototype._refreshTimerId = 0;

/** @private
* @type {Function}
*/
tr.DataView.prototype._groupSortingLogic = null;

/** @private
* @type {boolean}
*/
tr.DataView.prototype._pageCorrection = true;
/** @private
* @type {number}
*/
tr.DataView.prototype._pageSize = 0;
/** @private
* @type {number}
*/
tr.DataView.prototype._pageIndex = 1;
/** @private
* @type {number}
*/
tr.DataView.prototype._lastPageIndex = 0;

/** @private
* @type {Array.&lt;Function&gt;}
*/
tr.DataView.prototype._groupCriteria = null; // Shared between groups
/** @private
* @type {Array.&lt;Array&gt;}
*/
tr.DataView.prototype._preDefGroups = null;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._preDefGroupsDirty = false;
/** @private
* @type {Object.&lt;string, tr.DataView&gt;}
*/
tr.DataView.prototype._groupMembers = null; // Map of immediate child data views (key is id)
/** @private
* @type {Array.&lt;string&gt;}
*/
tr.DataView.prototype._groupList = null; // List of immediate child's ids
/** A map object that contains all groups with key is group row id and value is the group DataView
* @private
* @type {Object.&lt;string, tr.DataView&gt;}
*/
tr.DataView.prototype._groupRows = null; // Shared between groups
/** @private
* @type {string}
*/
tr.DataView.prototype._groupId = "";
/** @private
* @type {*}
*/
tr.DataView.prototype._groupValue;
/** @private
* @type {string}
*/
tr.DataView.prototype._groupRowId = "";
/** @private
* @type {Array.&lt;string&gt;}
*/
tr.DataView.prototype._footerRowIds = null;
/** @private
* @type {number}
*/
tr.DataView.prototype._groupLevel = 0;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._groupViewDirty = false;

/** @private
* @type {Object.&lt;string, tr.ColumnStats&gt;}
*/
tr.DataView.prototype._columnStats;

/** @private
* @type {boolean}
*/
tr.DataView.prototype._hidden = false;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._hiddenHeaderRow = false;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._collapsed = false;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._showOnlyFirstMember = false;
/** @private
* @type {boolean}
*/
tr.DataView.prototype._beingAdded = false;
/** @type {tr.grid.Conflator}
* @private
*/
tr.DataView.prototype._conflator = null;
/** @private
* @type {Array.&lt;tr.WrappedView&gt;}
*/
tr.DataView.prototype._wrappedViews = null;
/** @private
* @type {number}
*/
tr.DataView.prototype._wrapSize = 0;
/** @private
* @type {number}
*/
tr.DataView.prototype._wrapTimerId = 0;

/** @public
* @fires tr.DataView#preDisposed
*/
tr.DataView.prototype.dispose = function() {
	this._dispatch("preDisposed", {});

	this.unlistenAll();
	this.wrapView(0);
	this.setDataSource(null); // Remove this._dt and this._parent. WARNING: an event is fired
	this.groupBy(null); // Remove this._groupCriteria, this._groupRows and all of its children. WARNING: an event is fired

	this._conflator.dispose();

	this._sortingDefs = null;
	this._shared = null; // Remove shared options

	this._userFilter = this._groupSortingLogic = null;

	if(this._wrapTimerId) {
		clearTimeout(this._wrapTimerId);
		this._wrapTimerId = 0;
	}
	if(this._refreshTimerId) {
		clearTimeout(this._refreshTimerId);
		this._refreshTimerId = 0;
	}

	if(this._columnStats) {
		for(var field in this._columnStats) {
			this._columnStats[field].dispose();
		}
		this._columnStats = null;
	}
};

/** Get data by row id and column id (field)
* @public
* @param {string} rid
* @param {string} cid
*/
tr.DataView.prototype.getData = function(rid, cid) {
	return this._dt.getData(rid, cid);
};
/** Get entire row data by row id
* @public
* @param {string} rid
* @return {Object.&lt;string, *&gt;}
*/
tr.DataView.prototype.getRowData = function(rid) {
	return this._dt.getRowData(rid);
};
/** @public
* @param {string} cid
* @param {boolean=} inclNonDataRow=false If enabled, group header rows are included
* @return {!Array}
*/
tr.DataView.prototype.getColumnData = function(cid, inclNonDataRow) {
	var rids = this.getAllRowIds(true, inclNonDataRow);

	var rows = [];
	var len = rids.length;
	for(var r = 0; r &lt; len; ++r) {
		var rowData = this._dt.getRowData(rids[r]);
		if(rowData) {
			rows.push(rowData[cid]);
		} else if(inclNonDataRow) {
			rows.push(null);
		}
	}
	return rows;
};
/** @public
* @param {number} rowIndex
* @return {string}
* @see {@link tr.DataView#getRowIndex}
*/
tr.DataView.prototype.getRowId = function(rowIndex) {
	this._rebuildRowIdsFromChildren();

	return this._getRids()[rowIndex] || "";
};
/** @private
* @param {number|string} rowRef
* @return {string}
*/
tr.DataView.prototype._toRowId = function(rowRef) {
	if(typeof rowRef === "number") {
		this._rebuildRowIdsFromChildren();
		return this._getRids()[rowRef] || "";
	}
	return /** @type{string} */(rowRef || "");
};
/** @private
* @param {Array.&lt;number|string&gt;} rowRefs
* @return {!Array.&lt;string&gt;}
*/
tr.DataView.prototype._toRowIds = function(rowRefs) {
	var rowCount = Array.isArray(rowRefs) ? rowRefs.length : 0;
	var ary = new Array(rowCount);
	var rids = this._getRids();
	for(var r = 0; r &lt; rowCount; ++r) {
		var rowRef = rowRefs[r];
		if(typeof rowRef === "number") {
			this._rebuildRowIdsFromChildren();
			ary[r] = rids[rowRef] || "";
		} else {
			ary[r] = rowRef || "";
		}
	}
	return ary;
};
/** Return all row ids with row data, excluding the group header rows (auto generated rows).
* @public
* @param {boolean=} shallowCopy=false If enabled, no new copy of Array is created (better for performance).
* @param {boolean=} inclNonDataRow=false If enabled, group header rows are included. In pagination mode, this flag will always be true.
* @return {!Array.&lt;string&gt;}
* @see {@link tr.DataView#getAllRowData}
* @see {@link tr.DataView#getMultipleRowData}
* @see {@link tr.DataView#getSortedRowIds}
* @see {@link tr.DataView#getVisibleRowIds}
*/
tr.DataView.prototype.getAllRowIds = function(shallowCopy, inclNonDataRow) {
	this._rebuildRowIdsFromChildren();

	// WARNING: this._pageView can contain non-data rows (group header rows), even if inclNonDataRow flag is false
	var rids = (inclNonDataRow) ? this._getRids() : (this._pageView || this._rids);

	return (shallowCopy) ? rids : rids.slice(0); // Fastest way to clone an array is Array.slice()
};
/** This method returns current visible rows (i.e. Rows in other pages or in collapsed groups are excluded). Group header rows may be included in the results.
* @public
* @param {boolean=} shallowCopy=false If enabled, no new copy of Array is created (better for performance).
* @return {!Array.&lt;string&gt;}
* @see {@link tr.DataView#getAllRowData}
*/
tr.DataView.prototype.getVisibleRowIds = function(shallowCopy) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	return shallowCopy ? rids : rids.slice(0); // Fastest way to clone an array
};
/** Return all data rows that is filtered and sorted, excluding header rows or paging. This method ignores pagination.
* @public
* @param {boolean=} shallowCopy=false If enabled, no new copy of Array is created (better for performance).
* @return {!Array.&lt;string&gt;}
* @see {@link tr.DataView#getAllRowData}
*/
tr.DataView.prototype.getSortedRowIds = function(shallowCopy) {
	this._rebuildRowIdsFromChildren();
	return shallowCopy ? this._rids : this._rids.slice(0); // Fastest way to clone an array
};
/** This method is quite slow
* @public
* @param {string} rid
* @return {number}
* @see {@link tr.DataView#getRowId}
*/
tr.DataView.prototype.getRowIndex = function(rid) {
	this._rebuildRowIdsFromChildren();

	return this._getRids().indexOf(rid);
};
/** @public
* @return {number}
*/
tr.DataView.prototype.getRowCount = function() {
	return this._getRids().length;
};
/** @public
* @param {number} rowIndex
* @param {string} cid
*/
tr.DataView.prototype.getDataAt = function(rowIndex, cid) {
	return this._dt.getData(this.getRowId(rowIndex), cid);
};
/** This method is slow. When working with huge amount of rows, use getRowData in combination with getAllRowIds(true) instead of calling getRowDataAt multiple times.
* @public
* @param {number} rowIndex
* @return {Object.&lt;string, *&gt;}
*/
tr.DataView.prototype.getRowDataAt = function(rowIndex) {
	return this._dt.getRowData(this.getRowId(rowIndex));
};
/** @public
* @param {string} rid
* @param {string} cid
*/
tr.DataView.prototype.getPreviousData = function(rid, cid) {
	return this._dt.getPreviousData(rid, cid);
};
/** @public
* @param {Array.&lt;string&gt;} rids
* @param {number=} opt_from
* @param {number=} opt_to EXCLUSIVE
* @return {!Array.&lt;Object&gt;}
*/
tr.DataView.prototype.getMultipleRowData = function(rids, opt_from, opt_to) {
	return this._dt.getMultipleRowData(rids, opt_from, opt_to);
};
/** Return all rows with row data, excluding the group header rows (auto generated rows)
* @public
* @return {!Array.&lt;Object&gt;}
*/
tr.DataView.prototype.getAllRowData = function() {
	return this.getMultipleRowData(this.getAllRowIds(true));
};

/** @public
* @param {string} rid
* @param {string} cid
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setData = function(rid, cid, value) {
	if(this._dt) {
		return this._dt.setData(rid, cid, value);
	}
	return false;
};
/** @public
* @param {string} rid
* @param {Object.&lt;string, *&gt;=} values
* @param {Object=} opt_eventArg
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setRowData = function(rid, values, opt_eventArg) {
	if(rid &amp;&amp; this._dt) {
		if (!this.isRowExpansion(rid)) {
			return this._dt.setRowData(rid, values, opt_eventArg);
		}
	}
	return false;
};
/** Set data in a column manner. This is faster than repeatedly calling {@link tr.DataTable#setData}.
* @public
* @param {string} cid
* @param {Array} valueList
* @param {Array.&lt;string&gt;=} opt_ridList Specify row id to be set corresponding to the data item
*/
tr.DataView.prototype.setColumnData = function(cid, valueList, opt_ridList) {
	//  Note: This function should filter out row expansion before calling dt.setColumnData
	if(this._dt) {
		this._dt.setColumnData(cid, valueList, opt_ridList);
	}
};
/** This method is slow. When working with huge amount of rows, use setData in combination with getAllRowIds(true) instead of calling setDataAt multiple times.
* @public
* @param {number} rowIndex
* @param {string} cid
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setDataAt = function(rowIndex, cid, value) {
	var rid = this.getRowId(rowIndex);
	if(rid &amp;&amp; this._dt) {
		return this._dt.setData(rid, cid, value);
	}
	return false;
};
/** This method is slow. When working with huge amount of rows, use setRowData in combination with getAllRowIds(true) instead of calling setRowDataAt multiple times.
* @public
* @param {number} rowIndex
* @param {Object.&lt;string, *&gt;=} values
* @param {Object=} opt_eventArg
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setRowDataAt = function(rowIndex, values, opt_eventArg) {
	var rid = this.getRowId(rowIndex);
	return this.setRowData(rid, values, opt_eventArg);
};

/** @public
* @param {string|number} rowRef The position of the new row
* @param {Object.&lt;string, *&gt;=} opt_values
* @param {string|null=} opt_rid If the given row Id already exists, data is updated and no new row is added. Leave blank or null to let DataTable generate unique row Id
* @return {string} Return Row id that has been inserted or changed
*/
tr.DataView.prototype.insertRow = function(rowRef, opt_values, opt_rid) { // Data changed event may be dispatched
	this._rebuildRowIdsFromChildren(); // TODO: Check if we need to rebuild row ids
	var nextRid = this._toRowId(rowRef);

	if(this._dt) {
		return this._dt.insertRow(nextRid, opt_values, opt_rid);
	}
	return "";
};

/** Permanently remove the specified row by row id or DataView's row index. If you want to temporarily remove the row, use {@link tr.DataView#hideRows} instead
* @public
* @param {number|string} rowRef
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.removeRow = function(rowRef) {
	if(this._dt) {
		this._dt.removeRow(this._toRowId(rowRef)); // Trigger dataChanged
	}
};
/** Permanently remove the specified rows by row id or DataView's row index. If you want to temporarily remove the rows, use {@link tr.DataView#hideRows} instead
* @public
* @param {Array.&lt;number|string&gt;} rowRefs
*/
tr.DataView.prototype.removeRows = function(rowRefs) {
	if(this._dt) {
		this._dt.removeRows(this._toRowIds(rowRefs)); // Trigger dataChanged
	}
};
/** Move a single row or multiple rows to the position BEFORE the specified target row.
* @public
* @param {Array.&lt;number|string&gt;|number|string} fromRef The value could be row index, row id, or array of row indices or row ids.
* @param {number|string} toRef Destination target could be row index or row id
* @return {Array.&lt;string&gt;|string} rid rowId or array of the rowId of the moved row(s)
* @example
* ary = [0, 1, 2];
* move(ary, 0, 1); // [0, 1, 2] Move index 0 to the position before index 1 (nothing is changed)
* move(ary, 1, 0); // [1, 0, 2] Move index 1 to the position before index 0
*/
tr.DataView.prototype.moveRow = function(fromRef, toRef) {
	var toRid = this._toRowId(toRef);
	
	var fromIndices = /** @type{!Array.&lt;number|string&gt;} */(Array.isArray(fromRef) ? fromRef : [fromRef]);
	var fromRids = this._toRowIds(fromIndices);

	if(this._dt.hasSegmentation()) {
		this.synchronizeRowOrder();
	}

	return this._dt._moveRow(fromRids, toRid);
};

/** Deprecated
* @public
* @function
* @param {number} fromIndex
* @param {number} toIndex INCLUSIVE
*/
tr.DataView.prototype.swapRow = tr._deprecatedFunction;

/** Returns the root data source (tr.DataTable) of all data views
* @public
* @return {tr.DataTable}
* @see {@link tr.DataView#getDataSource}
*/
tr.DataView.prototype.getDataTable = function() {
	return this._dt;
};
/** Return source for this data view which could be another data view or a data table.
* @public
* @return {tr.DataTable|tr.DataView}
* @see {@link tr.DataView#getDataTable}
*/
tr.DataView.prototype.getDataSource = function() {
	return this._parent;
};
/** @public
* @param {(tr.DataTable|tr.DataView)=} source
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setDataSource = function(source) {
	if(source) {
		if(this._groupLevel &gt; 0) {
			return; // Sub group cannot be changed data source
		}
		this._setParent(source);

		this._onDataChanged(tr.DataTable._globalChangeArg); // Update current view
		this._parent.listen("dataChanged", this._onDataChanged);
	} else {
		if(this._parent) {
			this._parent.unlisten("dataChanged", this._onDataChanged);
			this._resetAllViews();
			this._groupViewDirty = false;
		}
		this._parent = this._dt = null;
		this._shared = {}; // The options are no longer shared
	}
};

/** @public
* @param {number} milliSecond
*/
tr.DataView.prototype.setConflationRate = function (milliSecond) {
	this._conflator.disable(!milliSecond);
	this._conflator.setConflatingTime(milliSecond);
};

/** @public
* @return {number}
*/
tr.DataView.prototype.getConflationRate = function () {
	return this._conflator.getConflatingTime();
};

/** @private
*/
tr.DataView.prototype._resetAllViews = function() {
	this._rids.length = 0;
	if(this._groupView &amp;&amp; this._groupView.length) { this._groupView.length = 0; }
	if(this._pageView &amp;&amp; this._pageView.length) { this._pageView.length = 0; }
	if(this._expansionView &amp;&amp; this._expansionView.length) { this._expansionView.length = 0; }
};

/**
* @public
* @ignore
* @return {Object.&lt;string, tr.DataTable.SortLogic&gt;}
*/
tr.DataView.prototype.getSortingLogics = function() {
	return this._dt ? this._dt.getSortingLogics() : null;
};
/** @public
* @param {string|Array.&lt;string&gt;} cid
* @param {string|number|Array.&lt;string|number&gt;=} opt_sortOrder
* @param {Function|Array.&lt;Function&gt;=} sortLogics
* @param {boolean=} noOptimization=false Force to sort without optimization to refresh all rowIds again.
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.sort = function(cid, opt_sortOrder, sortLogics, noOptimization) {
	if(this._groupLevel &gt; 0) {
		window.console.log("ERROR: Sub-group cannot be sorted individually");
		return;
	}

	var compMap = this.getSortingLogics();
	var sortingDefs = this._sortingDefs;
	var curSortLen = sortingDefs.length;

	if (Array.isArray(sortLogics)) {
		for(var c = sortLogics.length; --c &gt;= 0;) {
			if (typeof sortLogics[c] !== "function") {
				var columnId = Array.isArray(cid) ? cid[c] : cid;
				sortLogics[c] = compMap[columnId] || compMap["_default"];
			}
		}
	}
	tr.DataTable._buildSortContext(
		sortingDefs,
		cid,
		opt_sortOrder,
		sortLogics || compMap
	);
	if(sortingDefs.length === 1 &amp;&amp; sortingDefs[0][3] === 0) { // Sort order is zero which is resetting to original order
		sortingDefs.length = 0;
	}
	if(curSortLen &lt;= 0 &amp;&amp; sortingDefs.length &lt;= 0) {
		return; // Nothing is changed
	}
	if(this._shared.stalledRids) { // The stalled view cannot be changed
		return;
	}

	var change = false;
	if (this._groupMembers || sortingDefs.length &lt;= 0 || noOptimization) {
		change = true;
		this._updateRowIds(); // WARNING: Slow!
	} else { // filtering should already be done beforehand
		change = this._sort();
	}
	if(change) {
		this._dispatchDataChange(tr.DataTable._positionChangeArg);
	}
};
/** @public
* @param {string|Array.&lt;string&gt;} cid
* @param {string|number|Array.&lt;string|number&gt;=} opt_sortOrder
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.sortOnce = function(cid, opt_sortOrder) {
	this.sort(cid, opt_sortOrder); // Global change event is dispatched
	this._sortingDefs.length = 0;
};
/** @public
* @param {tr.DataTable.SortLogic} func
* @example
* customLogic = function(a, b, sortOrder) {
*   return (a - b) * sortOrder; // for numeric comparison
* };
* var dt = new DataTable();
* var dv = new DataView(dt);
* dv.setSortingLogic(customLogic);
* dv.sort("Column id", "ascending");
*/
tr.DataView.prototype.setSortingLogic = function(func) {
	if(this._dt) {
		this._dt.setSortingLogic(func);
	}
};
/** Specified sorting logic for the column with the given column id. This will override logic set by {@link tr.DataView#setSortingLogic}, when the column is sorted
* @public
* @param {string} cid
* @param {tr.DataTable.SortLogic} func Use null to remove current sorting logic
*/
tr.DataView.prototype.setColumnSortingLogic = function(cid, func) {
	if(this._dt) {
		this._dt.setColumnSortingLogic(cid, func);
	}
};
/** Check if this view is in sorting mode
* @public
* @return {boolean}
*/
tr.DataView.prototype.isSorting = function() {
	return this._sortingDefs.length &gt; 0;
};

/** Hide rows in the data view
 * @param {string|number} rId Row id to hide. If the rId is a number, it will be treated as a row index
 * @param {boolean=} hidden=true If the value is false, the specified row will be shown.
 * @public
 */
tr.DataView.prototype.hideRow = function(rId, hidden) {
	this.hideRows([rId], hidden);
};
/** Hide rows in the data view
 * @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or indices to hide
 * @param {boolean=} hidden=true If the value is false, the specified rows will be shown.
 * @public
 */
tr.DataView.prototype.hideRows = function(rowRefs, hidden) {
	hidden = hidden !== false;
	var dirty = false;
	var rids = this._toRowIds(rowRefs);
	var hiddenRids = this._hiddenRids;

	if(hidden){
		if(!hiddenRids) {
			hiddenRids = this._hiddenRids = {};
		}
	} else if(!hiddenRids) {
		return; // All rows are visible
	}

	for(var i = rids.length; --i &gt;= 0;) {
		var rid = rids[i];
		if(rid) { // undefined, null, and an empty string value are not a valid row id
			if(!!hiddenRids[rid] !== hidden) {
				hiddenRids[rid] = hidden;
				dirty = true;
			}
		}
	}

	if(dirty) {
		if(!hidden) {
			var hasHiddenRow = false;
			for(var key in hiddenRids) {
				if(hiddenRids[key]) {
					hasHiddenRow = true;
					break;
				}
			}
			if(!hasHiddenRow) {
				hiddenRids = this._hiddenRids = null;
			}
		}
		this._refreshAndNotify(); // Very slow
	}
};
/**
 * Show/hide rows in the data view
 * @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or indices to hide
 * @param {boolean=} shown=true If the value is false, the specified rows will be hidden.
 * @public
 */
tr.DataView.prototype.showRows = function(rowRefs, shown) {
	this.hideRows(rowRefs, shown === false);
};
/** Unhide all rows
* @public
*/
tr.DataView.prototype.unhideAllRows = function(){
	if(this._hiddenRids) {
		this._hiddenRids = null;
		this._refreshAndNotify();
	}
};
/** Check if there is any hidden row
* @public
* @return {boolean}
*/
tr.DataView.prototype.hasHiddenRow = function(){
	return !!this._hiddenRids;
};

/** @public
* @param {string|function(string, Object.&lt;string, *&gt;):boolean} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @param {boolean=} opt_filteringOut
* @return {boolean} Return true if there is any change. Otherwise, return false.
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
* @example
* dv.filterIn("FIELD", "Some value");
* dv.filterIn(function(rowId, rowData)) { // This is equivalent with the above statement
*     return rowData["FIELD"] === "Some value";
* });
*/
tr.DataView.prototype.filterIn = function(cid, value, opt_filteringOut) {
	var newLogic = this._getFilterLogic(cid, value);
	var filteringOut = (opt_filteringOut === true);
	if(this._userFilter === newLogic &amp;&amp; typeof cid !== "function") {
		if(!newLogic || filteringOut === this._filteringOut) {
			return false; // Nothing to update
		}
	}
	this._shared.filterLogic = newLogic;
	this._userFilter = newLogic;
	this._filteringOut = filteringOut;
	this._refreshAndNotify();
	return true;
};
/** @public
* @param {string|function(string, Object.&lt;string, *&gt;):boolean} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @return {boolean} Return true if there is any change. Otherwise, return false.
* @param {*=} value
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
* @example
* dv.filterIn("FIELD", "Some value");
* dv.filterOut(function(rowId, rowData)) { // This is equivalent with the above statement
*     return rowData["FIELD"] !== "Some value";
* });
*/
tr.DataView.prototype.filterOut = function(cid, value) {
	return this.filterIn(cid, value, true);
};
/** @public
* @param {string|Function} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @param {boolean=} opt_filteringOut
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.filterInOnce = function(cid, value, opt_filteringOut) {
	var checker = this._getFilterLogic(cid, value);
	if(!checker) { return; }

	var filteringOut = (opt_filteringOut === true);
	var rids = this._rids;
	var dt = this._dt;
	var removalMap = {};
	var totalRem = 0;
	var len = rids.length;
	for(var i = len; --i &gt;= 0;) {
		var rid = rids[i];
		var values = dt.getRowData(rid);
		if (!values || checker(rid, values) === filteringOut) {
			removalMap[rid] = true;
			++totalRem;
		}
	}
	if(totalRem &lt;= 0) { return; }

	var firstChange = this._removeRowIds(removalMap);

	var pageIndexChanged = this._updatePageCount();
	if(pageIndexChanged || this._transformView(firstChange)) {
		this._dispatchGlobalChange();
	} else {
		this._dispatchMultiRowRemoved(Object.keys(removalMap));
	}
};
/** @public
* @suppress {checkTypes}
* @param {string|function(string, Object.&lt;string, *&gt;):boolean} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.filterOutOnce = function(cid, value) {
	this.filterInOnce(cid, value, true);
};
/** @private
* @param {!Object.&lt;string, *&gt;} removalMap
* @return {number}
*/
tr.DataView.prototype._removeRowIds = function(removalMap) {
	var firstChange = this._removeArrayItems(this._rids, removalMap);
	if(this._groupView) {
		firstChange = this._removeArrayItems(this._groupView, removalMap);
	}

	if(this._groupMembers) {
		var len = this._groupList.length;
		for(var i = 0; i &lt; len; ++i) {
			var groupId = this._groupList[i];
			this._groupMembers[groupId]._removeRowIds(removalMap);
		}
	}
	return firstChange;
};
/** @public
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.clearFilter = function() {
	if(this._userFilter) {
		this._userFilter = null;
		this._shared.filterLogic = null;
		this._refreshAndNotify();
	}
};

/** Disable the page index correction
* @public
* @param {boolean=} opt_disable
*/
tr.DataView.prototype.disablePageCorrection = function(opt_disable) {
	this._pageCorrection = (opt_disable === false);
};
/** Goes to the specified page
* @public
* @param {number} pageIndex
* @return {boolean} True if there is any change, otherwise false
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setPage = function (pageIndex) {
	var result = this._setPage(pageIndex);
	if(result) {
		this._dispatchGlobalChange();
	}
	return result;
};
/** {@link tr.DataView#setPage}
* @public
* @function
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.gotoPage = tr.DataView.prototype.setPage;
/** Goes to the next page. If current page is already the last page, nothing is performed
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.nextPage = function () {
	return this.gotoPage(this._pageIndex + 1);
};
/** Goes back to the previous page. If current page is already the first page, nothing is performed
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.previousPage = function () {
	return this.gotoPage(this._pageIndex - 1);
};
/** {@link tr.DataView#previousPage}
* @public
* @function
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.prevPage = tr.DataView.prototype.previousPage;
/** Goes to the last page
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.lastPage = function () {
	return this.gotoPage(this._lastPageIndex - 1);
};
/** Goes to the first page
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype.firstPage = function () {
	return this.gotoPage(0);
};

/**
* @public
* @return {number}
*/
tr.DataView.prototype.getCurrentPage = function () {
	return this._pageIndex;
};
/** {@link tr.DataView#getCurrentPage}
* @public
* @function
*/
tr.DataView.prototype.getPageIndex = tr.DataView.prototype.getCurrentPage;
/** Verifies that current page is the last page
* @public
* @return {boolean}
*/
tr.DataView.prototype.isOnLastPage = function () {
	return (this._pageIndex === this._lastPageIndex);
};
/** Verifies that current page is the first page
* @public
* @return {boolean}
*/
tr.DataView.prototype.isOnFirstPage = function () {
	return (this._pageIndex === 1);
};

/** Get total number of rows in a single page
* @public
* @return {number}
*/
tr.DataView.prototype.getPageSize = function () {
	return this._pageSize;
};
/** Get total number of pages
* @public
* @return {number}
*/
tr.DataView.prototype.getPageCount = function () {
	return this._lastPageIndex;
};
/** {@link tr.DataView#getTotalPages}
* @public
* @function
*/
tr.DataView.prototype.getTotalPages = tr.DataView.prototype.getPageCount;
/** Shrink current view to the specified size. Set it 0 to reset to original size
* @public
* @param {number} pageSize
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
* @fires tr.DataView#dataChanged
*/
tr.DataView.prototype.setPageSize = function (pageSize) {
	if(!(pageSize &gt;= 0)) { pageSize = 0; }
	if(this._pageSize === pageSize) { return; }

	this._pageSize = pageSize;
	this._updatePageCount();

	if(pageSize &gt; 0) {
		if(!this._pageView) {
			this._pageView = [];
		}
	} else {
		if(this._pageView) {
			this._pageView = null;
		}
	}

	if(!this._pageView || pageSize === 0) {
		this._updateRowIds();
	} else {
		// filtering and sorting should already be done beforehand
		this._transformView();
	}
	this._dispatchGlobalChange();
};

/** Group all rows by the specified criteria. The criteria can be field name (field value will be used as a group id) or a function that takes row data and returns group id.
* @public
* @param {string|Function|Array.&lt;string|Function&gt;} cid Column id or grouper method that take one parameter for row data in JSON format, and returns groupId (string)
* @param {Array=} opt_predefinedGroups
* @fires tr.DataView#groupAdded
* @fires tr.DataView#groupCriteriaChanged
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype.groupBy = function (cid, opt_predefinedGroups) {
	// always deactivate multi-group row mode, it will automatically activate when populating group
	this._shared.multiGroupRow = false;

	if(this._groupCriteria) {
		if(this._groupList &amp;&amp; this._groupList.length &gt; 0) { // Dispose any existing member
			for(var key in this._groupMembers) {
				this._groupMembers[key].dispose(); // Clear everything in the data view
			}
			this._groupMembers = {}; // Clear all members
			this._groupList.length = 0;
		}
		this._groupCriteria = null;
	}
	if(opt_predefinedGroups !== undefined) { // null is allowed
		this._setPredefinedGroups(opt_predefinedGroups);
	}

	var i, len;
	if(cid &amp;&amp; this._groupLevel === 0) { // Sub group cannot be re-group without its parent noticing it
		this._groupCriteria = [];
		var ary;
		if(!tr.isArray(cid)) {
			ary = [cid];
		} else {
			ary = /** @type{Array.&lt;string|Function&gt;} */(cid);
		}
		len = ary.length;
		for(i = 0; i &lt; len; ++i) {
			var criteria = ary[i];
			if(typeof criteria === "string") {
				this._groupCriteria.push(this._defaultGroupCriteria.bind(this, criteria));
			} else if(criteria) {
				this._groupCriteria.push(/** @type{Function} */(criteria));
			}
		}
	}

	if(this._groupCriteria) { // Only root view can have group criteria at this point
		if(!this._groupMembers) {
			this._groupMembers = {};
			this._groupList = [];
			this._groupRows = {};
		}
		if(!this._groupView) {
			this._groupView = [];
		}
	} else {
		this._groupMembers = null;
		this._groupList = null;
		this._groupView = null;
		if(this._groupRows) { // this._groupRows is a shared member
			if(this._groupLevel &lt;= 0) {
				this._footerRowIds = null;
			} else {
				if(this._groupRowId) {
					delete this._groupRows[this._groupRowId];
				}
				if(this._footerRowIds) {
					len = this._footerRowIds.length;
					for(i = 0; i &lt; len; ++i) {
						delete this._groupRows[this._footerRowIds[i]];
					}
					this._footerRowIds = null;
				}
			}
			this._groupRows = null;
		}
		this._groupValue = null;
	}
	this._groupLevel = 0; // View that is set criteria will always be in the first group level
	this._updateRowIds();

	this._dispatch("groupCriteriaChanged", {});
	this._dispatchGlobalChange();
};
/** addGroup is used to add a single predefined group or multiple predefined groups.
* @public
* @param {*|Array} value
* @fires tr.DataView#groupAdded
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype.addGroup = function (value) {
	if(!this._groupMembers) {
		// window.console.log("Group criteria must be specified first before adding any group");
		return;
	}

	if(!tr.isArray(value)) {
		this._addGroup(value);
	} else {
		var ary = /** @type{Array} */(value);
		var len = ary.length;
		for(var i = 0; i &lt; len; ++i) {
			this._addGroup(ary[i]);
		}
	}
};
/** Sort all of its descendants based on given compare function
* @public
* @param {Function=} compare Default is sorting by text. If null or false value is given, no sorting is performed
*/
tr.DataView.prototype.sortGroups = function (compare) {
	if(!this._groupMembers) { return; }

	if(compare === undefined) {
		this._groupSortingLogic = tr.DataView._defaultGroupSortingLogic; // Temporary set the variable
	} else {
		this._groupSortingLogic = compare || null;
	}
	if(!this._groupSortingLogic) {
		return; // No logic is defined
	}

	this._groupList.sort(this._internalGroupSortingLogic);
	for(var i = this._groupList.length; --i &gt;= 0;){
		var groupId = this._groupList[i];
		this._groupMembers[groupId].sortGroups(this._groupSortingLogic);
	}
	this._groupViewDirty = true;
	if(this._groupLevel &lt;= 0) {
		this._dispatchGlobalChange();
	}
};
/** Move the specified group within its group
* @public
* @param {number|string} groupRef
* @param {number} destIndex
*/
tr.DataView.prototype.moveGroup = function (groupRef, destIndex) {
	var movedGroup = this.getGroup(groupRef);
	if(!movedGroup) {
		return; // Cannot find the given group
	}

	var parentGroup = movedGroup.getDataSource();
	var groupId = movedGroup.getGroupId();
	var curGroupIndex = parentGroup._groupList.indexOf(groupId);
	if(curGroupIndex === destIndex || curGroupIndex + 1 === destIndex) {
		return; // Nothing is needed to be moved
	}

	parentGroup._groupList.splice(curGroupIndex, 1);
	if(curGroupIndex &lt; destIndex) {
		--destIndex;
	}
	parentGroup._groupList.splice(destIndex, 0, groupId);

	this._requestRebuildingRowIds(false);
};
/** WARNING: This could be very slow to perform
* @public
* @param {Array} predefinedGroups Use two dimensional array to define groups for multi-level grouping. The first item is for the top level groups. The second item is for the second level groups, and so on. If one dimentional array is given, it is treated as the first item in the two-dimentionsal array.
* @example
* dv.setPredefinedGroups(["a", "b", "c"]); // Create empty three empty groups
* dv.setPredefinedGroups([ // Create two empty groups, and each group has 3 sub-groups
*   ["Main Group 1", "Main 2"],
*   ["Sub 1", "Sub 2", "Sub 3"]
* ]);
*/
tr.DataView.prototype.setPredefinedGroups = function (predefinedGroups) {
	this._setPredefinedGroups(predefinedGroups);
	if(this._groupMembers) {
		this._refreshAndNotify();
	}
};
/** @private
* @param {Array} predefinedGroups
*/
tr.DataView.prototype._setPredefinedGroups = function (predefinedGroups) {
	if(this._preDefGroups === predefinedGroups) {
		return;
	}

	if(this._preDefGroups) {
		this._preDefGroups.length = 0; // Remove all predefined groups in all members (this var is shared)
	}
	var is2D = false;
	if(predefinedGroups) {
		for(var i = predefinedGroups.length; --i &gt;= 0;) {
			if(Array.isArray(predefinedGroups[i])) {
				is2D = true;
				break;
			}
		}
	}

	if(is2D) {
		this._preDefGroups = predefinedGroups; // WARNING: Referencing user's object
	} else if(Array.isArray(predefinedGroups)) {
		this._preDefGroups = [predefinedGroups]; // Convert to 2D Array
	} else {
		this._preDefGroups = null;
	}
	this._preDefGroupsDirty = true;
};

/** Add a footer to current group
* @public
* @param {number=} opt_num Number of footer to be added. If not specified, the number is one.
*/
tr.DataView.prototype.addFooter = function (opt_num) {
	if(this._groupLevel &lt;= 0) {
		console.log("WARNING: Only group can have a footer");
		return;
	}
	if(opt_num == null) {
		opt_num = 1;
	}
	if(opt_num &lt;= 0) { // 0 and negative number is not acceptable
		return;
	}

	if(!this._footerRowIds) {
		this._footerRowIds = [];
	}

	for(var i = 0; i &lt; opt_num; ++i) {
		var footerRowId = this._groupRowId + "_footer" + (this._footerRowIds.length || "");
		this._footerRowIds.push(footerRowId);
		this._groupRows[footerRowId] = this;
	}

	if(!this._beingAdded) {
		this._requestRebuildingRowIds(this._collapsed); // Slow
	}
};
/** Remove all footers in the gurrent view
* @public
*/
tr.DataView.prototype.removeFooter = function () {
	if(this._footerRowIds) {
		var len = this._footerRowIds.length;
		for(var i = 0; i &lt; len; ++i) {
			delete this._groupRows[this._footerRowIds[i]];
		}
		this._footerRowIds = null;

		if(!this._beingAdded) {
			this._requestRebuildingRowIds(this._collapsed); // Slow
		}
	}
};

/** Enable/Disable multi-group row mode
* @public
* @ignore
* @param {boolean=} enabled
*/
tr.DataView.prototype.enableMultiGroup = function(enabled) {
	this._shared.multiGroupRow = enabled !== false;
};
/** Get a group DataView by group row id. If content row id is given, null is returned (unlike getGroup method).&lt;br&gt;
* Nested groups and other groups outside of this group branch will be searched.
* @public
* @param {string} rowId Group Id, row Id or group index (for immediate child groups)
* @return {tr.DataView}
* @see {@link tr.DataView#getGroup}
*/
tr.DataView.prototype.getGroupByRowId = function (rowId) {
	if(this._groupRows) {
		return this._groupRows[rowId] || null;
	}
	return null;
};
/** Get a corresponding DataView by the given group Id, row Id or group index. If row Id of content row is given, a parent group will be returned. &lt;br&gt;
* Nested groups and other groups outside of this group branch will be searched.
* @public
* @param {number|string} groupRef Group Id, row Id or group index (for immediate child groups)
* @return {tr.DataView}
* @see {@link tr.DataView#getGroupByRowId}
*/
tr.DataView.prototype.getGroup = function (groupRef) {
	if(!this._groupMembers) {
		return null;
	}
	var groupId;
	if(typeof groupRef === "number") {
		groupId = this._groupList[groupRef];
		if(!groupId) {
			return null;
		}
	} else {
		groupId = groupRef + ""; // Convert to string
	}

	// Search immediate child groups by group Id
	var dv = this._groupMembers[groupId];
	if(dv) {
		return dv;
	}

	// A group cannot be found by group Id. It is now assumed to be row id
	var rowId = groupId;
	dv = this._groupRows[rowId]; // Groups of any level will be searched
	if(dv) {
		return dv;
	}

	// The given row id is not a group row. Check if it is actually content row of this group
	return this._getGroupByContentRowId(rowId); // Slow recursive function
};
/** Get group of this data view by content row id. Group outside of this group branch is NOT searched
* @private
* @param {string} rowId
* @return {tr.DataView} Group of rowId that given
*/
tr.DataView.prototype._getGroupByContentRowId = function (rowId) {
	if(this._groupMembers) {
		for (var i = 0; i &lt; this._groupList.length; i++) {
			var groupId = this._groupList[i];
			var grp = this._groupMembers[groupId];
			var childGroup = grp._getGroupByContentRowId(rowId);
			if(childGroup) {
				return childGroup;
			}
		}
	} else { // Last childGroup
		if(this._rids.indexOf(rowId) !== -1) {
			return this; // return group if match with rowId
		}
	}
	return null;
};
/** Get all group descendants
* @public
* @param {Array=} out_ary
* @return {!Array.&lt;tr.DataView&gt;}
*/
tr.DataView.prototype.getAllGroups = function (out_ary) {
	if(!out_ary) { out_ary = []; }
	if(this._groupMembers) {
		var len = this._groupList.length;
		for(var i = 0; i &lt; len; ++i) {
			var groupId = this._groupList[i];
			var grp = this._groupMembers[groupId];
			out_ary.push(grp);
			grp.getAllGroups(out_ary);
		}
	}
	return out_ary;
};
/** Get immediate group members row ids in array list
* @public
* @return {Array.&lt;string&gt;}
*/
tr.DataView.prototype.getGroupList = function () {
	return this._groupList;
};
/** Get group id (string) of this data view. Only exists if this data view is a child data view
* @public
* @return {string}
*/
tr.DataView.prototype.getGroupId = function () {
	return this._groupId;
};
/** Get group value (any data type) of this data view. Only exists if this data view is a child data view
* @public
* @return {*}
*/
tr.DataView.prototype.getGroupValue = function () {
	return this._groupValue;
};
/** Row id used by parent data view as a header row for referencing
* @public
* @return {string}
*/
tr.DataView.prototype.getGroupRowId = function () {
	return this._groupRowId;
};
/**
* @public
* @ignore
* @return {number}
*/
tr.DataView.prototype.getFooterRowIndex = function (rid) {
	if(this._footerRowIds) {
		for(var i = this._footerRowIds.length; --i &gt;= 0;) {
			if(this._footerRowIds[i] === rid) {
				return i;
			}
		}
	}
	return -1;
};
/** A List of the footer row ids. Footer row is placed at the bottom of all other rows in this view
* @public
* @ignore
* @return {Array.&lt;string&gt;} Null if there is no footer row
*/
tr.DataView.prototype.getFooterRowIds = function () {
	return this._footerRowIds;
};
/**
* @public
* @return {boolean}
*/
tr.DataView.prototype.hasGroup = function () {
	return (this._groupMembers) ? true : false;
};
/** Deprecated in favor of getGroupByRowId
* @public
* @return {null}
* @see {@link DataView#getGroupByRowId}
*/
tr.DataView.prototype.getGroupRows = function () {
	return null;
};
/** Get group level of the corresponding row. If the given index is not specified, header row (the view itself) is used instead. Group level 0 means it is the root data view.
* @public
* @param {(number|string)=} rowRef
* @return {number}
*/
tr.DataView.prototype.getGroupLevel = function (rowRef) {
	if(rowRef != null &amp;&amp; this._groupRows) {
		if(typeof rowRef === 'number'){ // TODO: Change logic to acquire row id from row index instead
			this._rebuildRowIdsFromChildren();
			var rids = this._getRids(); // TODO : Should include hidden rows
			var rid = rids[rowRef];
			while(rid) {
				var dv = this._groupRows[rid];
				if(dv) {
					return dv._groupLevel;
				}
				rid = rids[--rowRef];
			}
		} else {
			var currentGroup = this.getGroup(rowRef); // Slow becuase recursive
			if(currentGroup) {
				return currentGroup._groupLevel;
			}
			return -1; // group not found
		}
	}
	return this._groupLevel;
};

/** Statistics (e.g. Sum, Avg, Max, and Min) of the specified column will be collected on every update. WARNING: CPU usage is intensive. Do disable, if the column is no longer used.
* @public
* @param {string} cid
* @param {boolean=} opt_enabled
* @param {string=} opt_refId
* @return {tr.ColumnStats} tr.ColumnStats Object
*/
tr.DataView.prototype.enableColumnStats = function(cid, opt_enabled, opt_refId) {
	if (!cid) { return null; }
	var enabled = opt_enabled !== false;
	var cs = this._columnStats[cid];
	if(enabled) {
		if(!cs) {
			cs = new tr.ColumnStats(this, cid);
			this._columnStats[cid] = cs;
		}
		cs.addRef(opt_refId);
	} else {
		if(cs) {
			if(!cs.deRef(opt_refId)) {
				cs.dispose();
				delete this._columnStats[cid];
			}
		}
	}
	if(this._groupMembers) {
		for(var i = this._groupList.length; --i &gt;= 0;) {
			var groupId = this._groupList[i];
			this._groupMembers[groupId].enableColumnStats(cid, opt_enabled, opt_refId);
		}
	}
	return cs || null;
};
/** @public
* @return {tr.ColumnStats} tr.ColumnStats. Return null if the column has not been enabled
*/
tr.DataView.prototype.getColumnStats = function(cid) {
	return this._columnStats[cid] || null;
};

/** This method temporarily remove all rows from the view, which can improve performance as further updates and operations will be ignored
* @public
* @param {boolean=} opt_hidden
*/
tr.DataView.prototype.hide = function(opt_hidden) {
	var val = opt_hidden !== false;
	if(this._hidden === val) {
		return false;
	}

	this._hidden = val;
	this._refreshAndNotify();
	return true;
};
/** @public
* @return {boolean}
*/
tr.DataView.prototype.isHidden = function() {
	return this._hidden;
};
/** @public
* @param {string} rowId
* @return {boolean} Returns true when this row is hidden
*/
tr.DataView.prototype.isHiddenRow = function(rowId) {
	if(this._hiddenRids) {
		return this._hiddenRids[rowId] === true;
	}
	return false;
};

/** @private
* @return {boolean}
*/
tr.DataView.prototype._isHeaderRowShown = function() {
	if (this._hiddenHeaderRow) {
		return false;
	}
	if (this._shared.filterLogic &amp;&amp; this._rids.length === 0) {
		// When filter is active, group without its member will be hidden
		return false;
	}

	// Group member with option autoGroupHiding enabled should always set `_collapsed` to false. Otherwise group will be collapsed and cannot be expanded by UI.
	if (this._shared.autoGroupHiding &amp;&amp; this._groupValue == null) {
		// In auto grouping mode, if group value is either undifined or null the header row will be hidden
		return false;
	}
	return true;
};
/** @private
* @param {boolean} collapsed
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype._setCollapse = function(collapsed) {
	if (this._shared.contentAsHeader) {
		// In this mode, only groups with hidden group header can be expanded/collapsed.
		// Ignore any group with visible group header
		if (this._hiddenHeaderRow) {
			if (this._showOnlyFirstMember !== collapsed) {
				this._showOnlyFirstMember = collapsed;
				return true;
			}
		}
	} else if (this._isHeaderRowShown()) { // Only groups with visible group header can be expanded/collapsed
		if (this._collapsed !== collapsed) {
			this._collapsed = collapsed;
			return true;
		}
	}
	return false;
};
/** Collapse current view. This works only if the view is generated as a child view
* @public
* @param {boolean=} opt_collapsed
*/
tr.DataView.prototype.collapse = function(opt_collapsed) {
	var dirty = this._setCollapse(opt_collapsed !== false);

	if(dirty) {
		if (this._shared.contentAsHeader) {
			if (this._hiddenHeaderRow) {
				this._requestRebuildingRowIds(this._showOnlyFirstMember); // Slow
			}
		} else {
			if(this._groupLevel &gt; 0) {
				this._requestRebuildingRowIds(this._collapsed);
			}
		}
	}
};
/** Collapse all children and descendants, excluding itself and its parent
* @public
* @param {boolean=} opt_collapsed
*/
tr.DataView.prototype.collapseAllGroups = function(opt_collapsed) {
	var grpList = this.getAllGroups();
	var len = grpList.length;
	if(len) {
		var collapsed = (opt_collapsed !== false);
		for(var i = 0; i &lt; len; ++i) {
			var grpItem = grpList[i];
			grpItem._setCollapse(collapsed);
		}
		this._requestRebuildingRowIds(false);
	}
};
/** @public
*/
tr.DataView.prototype.toggleCollapsedState = function() {
	this.collapse(!this.isCollapsed());
};
/** @public
* @return {boolean}
*/
tr.DataView.prototype.isCollapsed = function() {
	return this._collapsed || this._showOnlyFirstMember;
};
/** Content as header mode indicates that the group headers cannot be collapsed and the first row in the group will always be shown.
* @public
* @param {boolean=} bool
*/
tr.DataView.prototype.enableContentAsHeader = function(bool) {
	this._shared.contentAsHeader = bool !== false;
};
/** @private
* @return {?Array.&lt;string&gt;}
*/
tr.DataView.prototype._getFirstHiddenRids = function() {
	if(this._shared.contentAsHeader) {
		if(this._showOnlyFirstMember) {
			var rids = this._rids;
			if (Array.isArray(rids) &amp;&amp; rids.length) {
				return [rids[0]]; // Get only the first member of rids
			}
		}
	}
	return null;
};

/** This will not include collapsed group and rows
* @public
* @return {number}
*/
tr.DataView.prototype.getVisibleRowCount = function() {
	if(this._collapsed) {
		return 0;
	}
	this._rebuildRowIdsFromChildren();
	return this._getRids().length;
};

/** @public
* @description check weather row object is in group
* @param {Object} rowData
* @param {string=} groupID Default group id is the group id of the DataView that is being called.
* @return {boolean}
*/
tr.DataView.prototype.isRowDataInGroup = function (rowData, groupID) {
	var criteria = this._groupCriteria;
	var level = this._groupLevel;

	// Because self is a leaf group, only check against self.
	if (!groupID || groupID === this.getGroupId()) {
		return this._isAllowedInGroup(null, rowData);
	}

	// Check against self and all sub groups within self
	for (var i = level; i &lt; criteria.length; i++) {
		if (criteria[i](rowData).indexOf(groupID) &gt;= 0) {
			return true;
		}
	}
	return false;
};

/** @public
* @description check weather row ID is in group
* @param {string} rowId
* @param {string=} groupID Default group id is the group id of the DataView that is being called.
* @return {boolean}
*/
tr.DataView.prototype.isRowIdInGroup = function (rowId, groupID) {
	var rowData = this.getRowData(rowId);
	if(rowData) {
		return this.isRowDataInGroup(rowData, groupID);
	}
	return false;
};

/** @private
* @param {string} rid Row Id
* @param {number} _index child index
* @return {string}
*/
tr._getDataViewExpansionId = function (rid, _index) {
	return rid + "_ex" + _index;
};

/** The row expansion will be directly below the specified row, even if this data view is sorted.
* @public
* @param {string} rid Row Id
* @param {number=} count=1
*/
tr.DataView.prototype.addRowExpansion = function(rid, count) {
	if(this._groupLevel &gt; 0) {
		return; // Sub-group is not allowed to add a row expansion
	}

	if(!count || count &lt; 0) {
		if(count == null) {
			count = 1;
		} else {
			return;
		}
	}

	var rowIndex = this._rids.indexOf(rid);
	if(rowIndex &lt; 0) {
		// The given row id must be normal row. header and expansion row are not in the this._rids list
		return;
	}

	var expCount = 0;
	if(this._expansionMap) {
		expCount = this._expansionMap[rid] || 0;
	} else {
		this._expansionMap = {};
		this._expansionChildren = {};
	}
	var totalChild = expCount + count;
	this._expansionMap[rid] = totalChild;

	// create _expansionChildren mapping

	for (var i = expCount; i &lt; totalChild; i++) {
		this._expansionChildren[tr._getDataViewExpansionId(rid, i)] = rid;
	}

	if(!expCount) {
		// There is no row expansion for the row before, add number of entries to the map
		this._expansionCount++;
	}

	if(this._groupViewDirty) { // If group view is already dirty, we don't need to update row expansion right away
		return;
	}

	if(this._updateExpansionView()) {
		var e = {}; // Slow
		e["rid"] = rid;
		e["type"] = "inserted";
		e["nextRid"] = this._rids[rowIndex + 1];
		e["fallback"] = rowIndex; // Fallback index in case of no nextRid is found in the receiver
		this._dispatchDataChange(e);
	}
};
/**
* @public
* @param {string} rid Row Id
*/
tr.DataView.prototype.removeRowExpansion = function(rid) {
	if(!this._expansionMap) {
		return;
	}
	var expCount = this._expansionMap[rid];
	if(!expCount) {
		return;
	}

	var rids = new Array(expCount);
	for (var i = 0; i &lt; expCount; ++i) {
		rids[i] = tr._getDataViewExpansionId(rid, i);
		delete this._expansionChildren[rids[i]];
	}

	delete this._expansionMap[rid];
	this._expansionCount--;

	if(!this._groupViewDirty) { // If group view is already dirty, we don't need to update row expansion right away
		if(this._updateExpansionView()) {
			if(expCount === 1) {
				this._dispatchRowRemoved(rids[0]); // TODO: Expansion rid may not need to be sent
			} else {
				this._dispatchMultiRowRemoved(rids);
			}
		}
	}
};
/**
* @public
* @param {string|number} rowRef Row Id or index
* @param {boolean=} force
* @param {number=} count=1
*/
tr.DataView.prototype.toggleRowExpansion = function(rowRef, force, count) {
	var rid = this._toRowId(rowRef);

	if(force != null) {
		force = force === true;
	} else {
		force = !this.hasRowExpansion(rid);
	}

	if (force) {
		this.addRowExpansion(rid, count);
	} else {
		this.removeRowExpansion(rid);
	}
};
/** @public
*/
tr.DataView.prototype.removeAllRowExpansions = function() {
	if(this._expansionMap) {
		this._expansionMap = null;
		this._expansionCount = 0;
		this._expansionView = null;
		this._expansionChildren = null;
		this._refreshAndNotify();
	}
};
/** Deprecated. Use {@link tr.DataView#getExpansionParents} instead. Get all rows with expansion (not row expansion itself) will contains row id, otherwise undefined.
* @public
* @ignore
* @param {number=} from
* @param {number=} to EXCLUSIVE
* @return {!Array.&lt;string|undefined&gt;}
*/
tr.DataView.prototype.getRowsWithExpansion = function(from, to) {
	if(!this._expansionMap) {
		return [];
	}
	var rids = this._expansionView;
	var len = rids.length;
	if(to == null) { to = len; }
	else if(to &gt; len) { to = len; }

	if(!(from &gt; 0)) { from = 0; } // Handle NaN, undefined, null, and other invalid value

	var entryCount = this._expansionCount;
	var out_ary = new Array(len);
	for(var i = from; i &lt; to; ++i) {
		var rid = rids[i];
		if(this._expansionMap[rid]) {
			out_ary[i] = rid;
			if(--entryCount &lt;= 0) {
				break;
			}
		}
	}
	return out_ary;
};
/** Get row expansion states from the specified range. The returned value will be row id for row expansion, otherwise empty string for other types of row (e.g. normal row, or group header row)
* @public
* @param {number=} from
* @param {number=} to EXCLUSIVE
* @return {Array.&lt;string&gt;} object mapping of rowIndex and parentRowId
*/
tr.DataView.prototype.getExpansionParents = function (from, to) {
	var parentMapping = [];
	if (this._expansionMap) {
		var rids = this._expansionView;
		var len = rids.length;

		// Handle NaN, undefined, null, and other invalid values
		if (to == null || to &gt; len) {
			to = len;
		}
		if (!from || from &lt; 0) {
			from = 0;
		}

		for (var i = from; i &lt; to; ++i) {
			parentMapping[i] = this._expansionChildren[rids[i]] || "";
		}
	}
	return parentMapping;
};

/** Check if the specified row is itself a row expansion.
* @public
* @param {string} rid rowId
* @return {boolean}
*/
tr.DataView.prototype.isRowExpansion = function(rid) {
	if(this._expansionChildren) {
		return this._expansionChildren[rid] ? true : false;
	}
	return false;
};
/** Check if the specified row has row expansion (not row expansion itself).
* @public
* @param {string} rid rowId
* @return {boolean}
*/
tr.DataView.prototype.hasRowExpansion = function(rid) {
	if(this._expansionMap) {
		return this._expansionMap[rid] ? true : false;
	}
	return false;
};
/** Get row Id of the row expansion by providing the row Id of the row with row expansion (not row expansion itself). This is NOT recommended for normal usage, since the row expansion contains no data in the tr.DataView
* @public
* @param {string} rid rowId
* @param {number=} idx=0
* @return {string} Empty string is returned if the provided row does not contains a row expansion.
*/
tr.DataView.prototype.getRowExpansionId = function(rid, idx) {
	if(this._expansionMap) {
		var expCount = this._expansionMap[rid] || 0;
		if(!idx) {
			idx = 0;
		}
		if (idx &lt; expCount) {
			return tr._getDataViewExpansionId(rid, idx); // WARNING: Internal logic is exposed
		}
	}
	return "";
};

/** Get index from the row expansion id. Any row other than row expansion will yield negative value (-1)
* @public
* @param {string} rid Row expansion id
* @return {number}
*/
tr.DataView.prototype.getRowExpansionIndex = function(rid) {
	if(rid) {
		var matches = rid.match(/_ex(\d+)$/);
		if(matches) {
			return +matches[1]; // TODO: Check for NaN value
		}
	}
	return -1;
};
/** @private
* @return {boolean}
*/
tr.DataView.prototype._updateExpansionView = function() {
	var expMap = this._expansionMap;
	if(expMap) {
		if(!this._expansionCount || this._expansionCount &lt; 0) {
			this._expansionCount = 0;
			this._expansionMap = null;
			this._expansionView = null;
			this._expansionChildren = null;
			return true;
		}

		var rids = this._pageView || this._groupView || this._rids;
		var rowLen = rids.length;
		var origLen = this._expansionView ? this._expansionView.length : 0;
		if(!this._expansionView) {
			this._expansionView = new Array(rowLen);
		} else {
			this._expansionView.length = rowLen;
		}
		var entryCount = this._expansionCount;
		for(var i = 0, j = 0; i &lt; rowLen; ++i) {
			var rid = rids[i];
			this._expansionView[j++] = rid;
			if(entryCount) {
				var expCount = expMap[rid] || 0;
				if(expCount) {
					for(var k = 0; k &lt; expCount; ++k) {
						this._expansionView[j++] = tr._getDataViewExpansionId(rid, k);
					}
					--entryCount;
				}
			}
		}
		return origLen !== this._expansionView.length; // TODO: This does not completely check the change of all cases
	} else {
		return false;
	}
};
/** Guarantee that expansion is added after the pagination view
* @private
* @param {number=} firstChange
* @return {boolean}
*/
tr.DataView.prototype._transformView = function(firstChange) {
	var dirty = this._updatePaginationView(firstChange);
	dirty |= this._updateExpansionView();
	return dirty ? true : false;
};

/**
* @public
* @param {function(Object):boolean} searchLogic Function that takes row data object and return boolean value
* @param {Array.&lt;string&gt;=} opt_out Array for containing row ids
* @return {!Array.&lt;string&gt;} List of row ids
*/
tr.DataView.prototype.searchAll = function(searchLogic, opt_out) {
	if(!opt_out) { opt_out = []; }

	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	var len = rids.length;

	for(var i = 0; i &lt; len; ++i) {
		var rid = rids[i];
		var row = this._dt.getRowData(rid);
		if(row) {
			if(searchLogic(row)) {
				opt_out.push(rid);
			}
		}
	}
	return opt_out;
};
/**
* @public
* @param {number|string} rowRef
* @param {function(Object):boolean} searchLogic Function that takes row data object and return boolean value
* @return {number} Row index
*/
tr.DataView.prototype.searchPrev = function(rowRef, searchLogic) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	var rowIndex = -1;
	if(typeof rowRef === "number") {
		if(this._dt.getRowData(rids[rowRef])) {
			rowIndex = rowRef;
		}
	} else {
		rowIndex = rids.indexOf(rowRef);
	}

	var foundAt = -1;
	var len = rids.length;
	if(rowIndex &gt; 0) {
		foundAt = this._searchRow(rids, searchLogic, rowIndex - 1, -1, -1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	if(rowIndex &gt;= 0) { // loop the search by starting from the end
		foundAt = this._searchRow(rids, searchLogic, len - 1, rowIndex, -1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	return -1;
};
/**
* @public
* @param {number|string} rowRef
* @param {function(Object):boolean} searchLogic Function that takes row data object and return boolean value
* @return {number} Row index
*/
tr.DataView.prototype.searchNext = function(rowRef, searchLogic) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	var rowIndex = -1;
	if(typeof rowRef === "number") {
		if(this._dt.getRowData(rids[rowRef])) {
			rowIndex = rowRef;
		}
	} else {
		rowIndex = rids.indexOf(rowRef);
	}
	if(rowIndex &lt; 0) { // Cannot find the specified row
		return -1;
	}

	var foundAt = -1;
	var len = rids.length;
	if(rowIndex &lt; len - 1) {
		foundAt = this._searchRow(rids, searchLogic, rowIndex + 1, len, 1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	if(rowIndex &gt; 0) { // loop the search by starting from the start
		foundAt = this._searchRow(rids, searchLogic, 0, rowIndex, 1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	return -1;
};
/**
* @private
* @param {!Array.&lt;string&gt;} rids
* @param {function(Object):boolean} searchLogic
* @param {number} start
* @param {number} end
* @param {number} inc
* @return {number}
*/
tr.DataView.prototype._searchRow = function(rids, searchLogic, start, end, inc) {
	while(start !== end) {
		var rid = rids[start];
		var row = this._dt.getRowData(rid);
		if(row) {
			if(searchLogic(row)) {
				return start;
			}
		}
		start += inc;
	}
	return -1;
};

/** Blocks all row insertion and removal, but keep updating the data
* @public
* @param {boolean=} opt_bool
* @return {boolean} True if there is any change
*/
tr.DataView.prototype.stall = function(opt_bool) {
	var newBool = opt_bool !== false;
	var curBool = this._shared.stalledRids ? true : false;
	if(curBool === newBool) { return false; }
	if(newBool) {
		var srs = {};
		this._shared.stalledRids = srs;
		var rids = this._getRids();

		for(var i = rids.length; --i &gt;= 0;) {
			srs[rids[i]] = 1;
		}
	} else {
		this._shared.stalledRids = null;
		this._refreshAndNotify();
	}
	return true;
};
/** Automatically and asyncronuosly remove group that has no member or no content. Predefined groups will not be removed in this way.
* @public
* @param {boolean=} opt_bool
* @return {boolean} True if there is any change
*/
tr.DataView.prototype.enableAutoGroupRemoval = function(opt_bool) {
	opt_bool = opt_bool !== false;
	var autoGroupRemoval = this._shared.autoGroupRemoval ? true : false;
	if(autoGroupRemoval !== opt_bool) {
		this._shared.autoGroupRemoval = opt_bool;
		this._triggerGroupRefreshing();
		return true;
	}
	return false;
};
/** Automatically hide null or undefined group header, while keeping the group's items intact.
* @public
* @param {boolean=} opt_bool
* @return {boolean} True if there is any change
*/
tr.DataView.prototype.enableAutoGroupHiding = function(opt_bool) {
	opt_bool = opt_bool !== false;
	var autoGroupHiding = this._shared.autoGroupHiding ? true : false;
	if(autoGroupHiding !== opt_bool) {
		this._shared.autoGroupHiding = opt_bool;
		this._triggerGroupRefreshing();
		return true;
	}
	return false;
};

/** Copy row order in data view to its data table
* @public
*/
tr.DataView.prototype.synchronizeRowOrder = function() {
	if(this.isSorting()) {
		this._dt._sort(this._sortingDefs);
	}
};
/** Set visible row as segment separator (hidden or filtered rows cannot be a segment separator)
* @public
* @param {string|number} rowRef Row id or row index
* @param {boolean=} enabled
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.setSegmentSeparator = function(rowRef, enabled) {
	var rowId = "";
	if(typeof rowRef === "number") {
		rowId = this.getRowId(rowRef);
	} else if(typeof rowRef === "string") {
		rowId = rowRef; // WARNING: Invisible row id can still be set as segment separator as long as it is in the data table
	}

	if(rowId) {
		enabled = enabled !== false;
		if(enabled) {
			this.synchronizeRowOrder();
		}
		// TODO: Force expanding of segment before unsetting segment separator
		return this._dt.setSegmentSeparator(rowId, enabled);
	}
	return false;
};
/**
* @public
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.unsetAllSegmentSeparators = function() {
	return this._dt.unsetAllSegmentSeparators();
};
/**
* @public
* @return {boolean}
*/
tr.DataView.prototype.hasSegmentation = function() {
	return this._dt.hasSegmentation();
};
/**
* @public
* @param {string} rid
* @return {boolean}
*/
tr.DataView.prototype.isSegmentSeparator = function(rid) {
	return this._dt.isSegmentSeparator(rid);
};
/**
* @public
* @param {string} rid
* @return {string} parent row id of this segmentation. If the parent row id for this segmentation cannot be found, return ""
*/
tr.DataView.prototype.getSegmentParentRowId = function(rid) {
	return this._dt.getSegmentParentRowId(rid);
};
/** @public
* @param {string|number} rowRef Row id or row index
* @param {boolean=} collapsed
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.collapseSegment = function(rowRef, collapsed) {
	collapsed = collapsed !== false;
	var segments = this._dt._getSegmentSeparators();
	if(segments) {
		var segmentRid = this._toRowId(rowRef);

		if(segments.collapseSegment(segmentRid, collapsed)) {
			this._refreshAndNotify(); // dispatch global change event

			return true;
		}
	}

	return false;
};
/** @public
* @param {string|number} rowRef Row id or row index
* @param {boolean=} expanded
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.expandSegment = function(rowRef, expanded) {
	return this.collapseSegment(rowRef, expanded === false);
};
/** @public
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.expandAllSegments = function() {
	var segments = this._dt._getSegmentSeparators();
	if(segments) {
		if(segments.expandAllSegments()) {
			this._refreshAndNotify();
			return true;
		}
	}
	return false;
};
/** Deprecated.
* @public
* @ignore
*/
tr.DataView.prototype.setSegmentCollapsingLogic = function() {};
/** @public
* @param {string|number} rowRef Row id or row index
* @return {boolean} Return true if only the given row is a collapsed segment separator
*/
tr.DataView.prototype.isSegmentCollapsed = function(rowRef) {
	var segments = this._dt._getSegmentSeparators();
	if(segments) {
		return segments.isCollapsedSegment(this._toRowId(rowRef));
	}
	return false;
};
/** Remove existing segment children and fill the segments with all contnet rows before the next segment separator
* @public
* @param {string|number} segmentRef Row id or row index
*/
tr.DataView.prototype.fillSegment = function(segmentRef) {
	this._dt.fillSegment(this._toRowId(segmentRef));
};
/** Remove all existing segment children in each segment and fill the segments with all contnet rows before the next segment separator
* @public
*/
tr.DataView.prototype.fillSegments = function() {
	this._dt.fillSegments();
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {string|number} rowRef Row id, row index
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.addSegmentChild = function(segmentRef, rowRef) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowId = this._toRowId(rowRef);
		return this._dt.addSegmentChild(segmentId, rowId);
	}
	return false;
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or row indices
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.addSegmentChildren = function(segmentRef, rowRefs) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowIds = this._toRowIds(rowRefs);
		return this._dt.addSegmentChildren(segmentId, rowIds);
	}
	return false;
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {string|number} rowRef Row id, row index
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.removeSegmentChild = function(segmentRef, rowRef) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowId = this._toRowId(rowRef);
		return this._dt.removeSegmentChild(segmentId, rowId); // TODO: Handle the case where a child is remove from its collapsed parent. Child should be made visible
	}
	return false;
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or row indices. If null is given, no child will be removed.
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.removeSegmentChildren = function(segmentRef, rowRefs) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowIds = this._toRowIds(rowRefs);
		return this._dt.removeSegmentChildren(segmentId, rowIds); // TODO: Handle the case where a child is remove from its collapsed parent. Child should be made visible
	}
	return false;
};
/** @public
* @return {boolean} Return true if there is any change
*/
tr.DataView.prototype.removeAllSegmentChildren = function() {
	return this._dt.removeAllSegmentChildren();
};
/** Get row ids of all segment separator
* @public
* @return {Array.&lt;string&gt;} Return null if there is no segment separator
*/
tr.DataView.prototype.getSegmentIds = function() {
	return this._dt.getSegmentIds();
};
/** Get row ids of all children from the specified segment
* @public
* @param {string|number} segmentRef Row id or row index
* @return {Array.&lt;string&gt;} Returns array of row ids. Returns null if there is no child or no segment separator found
*/
tr.DataView.prototype.getSegmentChildIds = function(segmentRef) {
	return this._dt.getSegmentChildIds(this._toRowId(segmentRef));
};
/** Sort all of existing segments by given compare function
* @public
* @param {Function} compare
*/
tr.DataView.prototype.sortSegments = function (compare) {
	this._dt.sortSegments(compare);
};

/** @public
* @ignore
* @return {Object}
*/
tr.DataView.prototype._getSharedObject = function () {
	return this._shared;
};
/** Return 0, if there is no wrapping
* @public
* @return {number}
*/
tr.DataView.prototype.getWrapSize = function () {
	return this._wrapSize;
};
/** Return null, if there is no wrapping
* @public
* @return {Array.&lt;tr.WrappedView&gt;}
*/
tr.DataView.prototype.getWrappedViews = function () {
	return this._wrappedViews;
};
/**
* @public
* @param {number=} wrapSize
* @fires tr.DataView#wrapCountChanged
*/
tr.DataView.prototype.wrapView = function (wrapSize) {
	if(wrapSize != null) {
		if(!wrapSize || wrapSize &lt; 0) {
			wrapSize = 0;
		}
		if(this._wrapSize !== wrapSize) {
			this._wrapSize = wrapSize;
			this._dispatch("wrapSizeChanged", {
				"wrapSize": wrapSize,
				"rids": this.getVisibleRowIds(true)
			});
		}
	}
	this._updateWrapCount();
};

/** @private
* @fires tr.DataView#wrapCountChanged
*/
tr.DataView.prototype._updateWrapCount = function () {
	this._wrapTimerId = 0;
	var wrapSize = this._wrapSize;

	var i;
	var views = this._wrappedViews;
	var viewCount = views ? views.length : 0;
	var targetCount = 0;
	if(wrapSize) {
		var rids = this.getVisibleRowIds(true);
		var rowCount = rids.length;
		targetCount = Math.ceil(rowCount / wrapSize);
		if(viewCount &lt; targetCount) {
			if(!views) {
				views = this._wrappedViews = [];
			}
			for(i = viewCount; i &lt; targetCount; ++i) {
				this._wrappedViews[i] = new tr.WrappedView({
					"dataView": this,
					"wrapIndex": i,
					"rids": rids
				});
			}
		}
	}

	if(targetCount &lt; viewCount) {
		for(i = viewCount; --i &gt;= targetCount;) {
			this._wrappedViews[i].dispose();
		}
		this._wrappedViews.length = targetCount;
	}
	if(!wrapSize) {
		this._wrappedViews = null;
	}

	if(viewCount !== targetCount) {
		this._dispatch("wrapCountChanged", {
			"prevCount": viewCount,
			"newCount": targetCount
		});
	}
};

/** Construct a JSON object that is compatible with console.table()
* @public
* @param {Object=} opt_options {@link tr.DataCache#dump}
* @return {!Array.&lt;Object&gt;} Return a JSON object that is compatible with console.table()
* @see {@link tr.DataCache#dump}
*/
tr.DataView.prototype.dump = function(opt_options) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();

	return tr.DataCache.constructTable(this.getMultipleRowData(rids), opt_options, rids);
};
/** Print current data and structure to console panel
* @public
* @param {Object=} opt_options
* @example
// Options have the following format:
// {
//  "colNames": Array.&lt;string&gt;,
//  "rowCount": number,
//  "startIndex": number,
//  "getter": function(Object, string):*,
//  "withRowIds": boolean
//}
dv.log({"rowCount": 10}); // Showing 10 records
dv.log({"getter": function(rowData, colName){
	var complexData = rowData[colName];
	return complextData.someProperty;
}});
*/
tr.DataView.prototype.log = function(opt_options) {
	console.table(this.dump(opt_options));
};


/** @private
* @return {!Array.&lt;string&gt;}
*/
tr.DataView.prototype._getRids = function() {
	return this._expansionView || this._pageView || this._groupView || this._rids;
};

/** @private
* @param {Array.&lt;string&gt;=} opt_rowIds Provide this parameter to avoid unnecessary group filtering
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype._updateRowIds = function(opt_rowIds) {
	this._groupViewDirty = false;
	if(!this._parent || this._hidden) {
		this._resetAllViews();
		return;
	}
	if(this._shared.stalledRids) { // The stalled view cannot be changed
		return;
	}

	// Perform the following sequences: parent view cloning &gt;&gt; row hiding &gt;&gt; row filtering &gt;&gt; row grouping &gt;&gt; sorting &gt;&gt; paging
	this._rids = opt_rowIds || this._parent.getAllRowIds(); // Get all data ids

	if(this._hiddenRids) {
		this._removeArrayItems(this._rids, this._hiddenRids);
	}
	var segments = this._dt._getSegmentSeparators();
	this._collapsedRids = null;
	var filterExceptions = null;
	if(segments) {
		filterExceptions = segments.getSegments(); // Segment separators should not be filtered out (hidden)
		var collapsedRows = this._collapsedRids = segments.getCollapsedRows(); // Children of collapsed segments must be filtered out (hidden)
		if(collapsedRows) {
			this._removeArrayItems(this._rids, collapsedRows);
		}
	}

	this._dispatch("beforeFiltering", {});
	this._quickFilter(this._userFilter, this._filteringOut, filterExceptions);

	if(this._groupLevel &gt; 0 &amp;&amp; !opt_rowIds) {
		this._quickFilter(this._groupFilterLogic, false); // Filter In
	}

	if(this._groupMembers) { // Has grouping
		this._populateGroups(); // View will be properly re-populate inside _populateGroups()
	} else { // No grouping
		var pageIndexChanged = this._updatePageCount();
		var sorted = this._sort();
		if(!sorted &amp;&amp; !pageIndexChanged) {
			this._transformView();
		}
	}
};
/** @private
* @param {Object} e
*/
tr.DataView.prototype._onDataChanged = function (e) {
	if (this._conflator.conflate(e)) return;

	var events = this._conflator.popAllData() || [e];

	// process all events
	var eventsCount = events.length;
	if (eventsCount === 1) {
		var event = events[0];
		if (event["globalChange"]) {
			this._updateRowIds();  // Reset all row ids and perform sorting
			this._dispatchDataChange(event);
		} else {
			var type = event["type"];
			if (type === "inserted") {
				this._onRowInserted(event);
			} else if (type === "removed") {
				this._onRowRemoved(event);
			} else {
				this._onRowUpdated(event);
			}
		}
	} else {
		// multi event should occur globalchange
		this._updateRowIds();  // Reset all row ids and perform sorting
		var positionChangeOnly = true;
		for (var i = 0; i &lt; eventsCount; i++) {
			if (!events[i].positionChangeOnly) {
				positionChangeOnly = false;
				break;
			}
		}
		this._dispatchDataChange({
			"globalChange": true,
			"positionChangeOnly": positionChangeOnly,
			"events": events
		});
	}
};
/** @private
* @param {!Object} e
* @return {number} 1 if there is any change, zero otherwise.
*/
tr.DataView.prototype._onRowInserted = function(e) { // onInsert
	if(this._shared.stalledRids) {
		return 0;
	}

	if(this.isRowFiltered(e["rid"], e["rowData"])) {
		return 0;
	}

	var ret = 0;
	if(this._groupMembers) {
		var gids = this._resolveGroupId(e["rowData"]);
		var groupLen = gids.length;
		if(groupLen &gt; 1) {
			// activate multi-group row mode
			this._shared.multiGroupRow = true;
		}
		var gid;
		for(var i = 0; i &lt; groupLen; i++) {
			gid = gids[i];
			if(this._groupMembers[gid]) { // Insert to existing member
				ret = this._groupMembers[gid]._onRowInserted(e);
			} else {
				var member = this._addGroup(gid);
				if(member) {
					e["globalChange"] = true;
					member._onRowInserted(e);
					ret = 1;
				}
			}
		}
		if(e["globalChange"]) {
			this._groupViewDirty = true;
		}
	}

	if(this._hidden) {
		return ret; // the view is hidden and there is no need to be updated
	}

	var rid = e["rid"];
	var rowData = e["rowData"];

	if(!this._isAllowedInGroup(rid, rowData)) {
		return ret;
	}

	var nextRid = /** @type{string} */(e["nextRid"]);
	var rowIndex;
	if(this.isSorting() &amp;&amp; !e["segmentChanged"]) {
		rowIndex = this._addDataRow(rid);
	} else {
		rowIndex = this._addDataRow(rid, nextRid, e["fallback"]);
	}

	var pageIndexChanged = this._updatePageCount();
	var sorted = this._sort();
	if(sorted) {
		e["globalChange"] = true; // Notify parent
	}
	if(e["globalChange"]) {
		if(!sorted &amp;&amp; !pageIndexChanged) {
			this._transformView();
		}
	} else {
		e = { // Slow
			"rid": rid,
			"rowData": rowData,
			"type": "inserted"
		};
		if(nextRid !== undefined) {
			e["nextRid"] = nextRid;
			e["fallback"] = rowIndex;
		}
		if(this._transformView(rowIndex)) {
			e["globalChange"] = true;
		}
	}
	this._dispatchDataChange(e);

	return 1;
};
/** @private
* @param {!Object} e
* @return {number}
*/
tr.DataView.prototype._onRowRemoved = function(e) { // onRemove
	if(this._shared.stalledRids) {
		return 0;
	}

	if(e["segmentChanged"] &amp;&amp; this.isSorting()) {
		this._refreshAndNotify();
		return 1; // may not be a correct number
	}

	var removeCount = 0;
	var rids = e["rids"];
	var i;
	if(this._groupMembers) {
		var rowData = e["rowData"];
		var groupIds, groupId;
		if(!rids &amp;&amp; rowData) {
			groupIds = this._resolveGroupId(rowData);
			for(i = 0; i &lt; groupIds.length; i++) {
				groupId = groupIds[i];
				if(this._groupMembers[groupId]) { // remove existing member
					removeCount += this._groupMembers[groupId]._onRowRemoved(e);
				}
			}

			// should allow rebuilding because rows which the same rid were removed from many groups
			// sectionSetting will not know the proper changed row index
			if(removeCount &gt; 1) {
				this._groupViewDirty = true;
			}
		} else {
			var len = this._groupList.length;
			for(i = 0; i &lt; len; ++i) {
				groupId = this._groupList[i];
				removeCount += this._groupMembers[groupId]._onRowRemoved(e);
			}
		}
	}

	var firstModifiedIndex = NaN;
	var removedRids = null;
	var rid, at;

	// TODO: Change removal mechanism to object map based logic to speed up the process
	removeCount = 0;
	if(rids) {
		removedRids = [];
		for(i = rids.length; --i &gt;= 0;) {
			rid = rids[i];
			at = this._removeDataRow(rid);
			if(at &gt;= 0) {
				removedRids.push(rid);
				if(!(at &gt;= firstModifiedIndex)) {
					firstModifiedIndex = at;
				}
			}
		}
		removeCount = removedRids.length;
	} else {
		rid = e["rid"];
		at = this._removeDataRow(rid);
		if(at &gt;= 0) {
			removedRids = [rid];
			firstModifiedIndex = at;
			removeCount = 1;
		}
	}
	if(removeCount &gt; 0) {
		// No sorting is required, since no order should be changed during the removal
		var pageIndexChanged = this._updatePageCount();
		if(pageIndexChanged || this._transformView(firstModifiedIndex)) {
			this._dispatchGlobalChange();
		} else {
			this._dispatchMultiRowRemoved(removedRids);
		}
		if(this._shared.autoGroupRemoval &amp;&amp;
			this._groupRows &amp;&amp;
			this._rids.length &lt;= 0) {
			this._triggerGroupRefreshing(); // Set a timer to refresh group view
		}
		if (this._hiddenHeaderRow) { // If the first row is removed while th group is collapsing, the next row should take place.
			this._requestRebuildingRowIds(true); // TODO: Optimize
		}
	}
	return removeCount;
};
/** @private
* @param {!Object} e
* @return {number}
*/
tr.DataView.prototype._onRowUpdated = function(e) { // onUpdate
	var rid = e["rid"];
	var rowData = e["rowData"];

	if(this.isRowFiltered(rid, rowData)) { // The row is qualified but it is filtered out
		if(this._onRowRemoved(e)) {
			return 1;
		}
		return 0; // The row does not belong to this view
	}

	if(this._groupMembers) {
		var flags = [];
		var len = this._groupList.length;
		for(var i = 0; i &lt; len; ++i) {
			var gid = this._groupList[i];
			flags[this._groupMembers[gid]._onRowUpdated(e)] = true;
		}

		if(e["globalChange"]) { // If current dataView is sorting, globalChange will always be true
			this._groupViewDirty = true;
		}

		// conclude flag
		var processingFlag = 0;
		if(flags[2]) {
			processingFlag = 2;
		} else if(flags[1]) {
			if(!this._isAllowedInGroup(rid, rowData)) {
				processingFlag = 1;
			}
		} else if(flags[4]) {
			processingFlag = 4;
		}

		if(this._groupLevel &gt; 0) {
			if(processingFlag === 1) { // The row is moved to the other group
				if(this._removeArrayItem(this._rids, rid) &gt;= 0) {
					if(this._groupView) {
						this._removeArrayItem(this._groupView, rid);
					}
				}
				if(this._shared.multiGroupRow) {
					this._groupViewDirty = true;
				}
			} else if(processingFlag === 2) { // The row is added to its sub-group
				if(!this._hidden) {
					if(this._rids.indexOf(rid) &lt; 0) {
						this._rids.push(rid);
					}

					this._groupViewDirty = true; // Adding row to sub-group both single and multiple-group require parent group to rebuild rows

					var groupLen = this._resolveGroupId(rowData).length;
					if(groupLen &gt; 1) {
						// activate multi-group row mode
						this._shared.multiGroupRow = true;
					}
				}
			}
		} else { // This is the root node
			var noNewGroup = (flags[1] &amp;&amp; flags[2]) || flags[4];
			if(this._shared.multiGroupRow || !noNewGroup) {
				// 0 - updated data from non-existing group to new group
				// 1 - updated data from existing group to new group
				// 2 - updated data from a non-existing group to existing group
				// 3 - updated data from a existing group to another existing group
				// 4 - updated data with in a single group and no group member changed
				var gids = this._resolveGroupId(rowData);
				var gid;
				for(var i = 0; i &lt; gids.length; i++) {
					gid = gids[i];
					var member = this._addGroup(gid); // Add header row
					if(member) {
						member._onRowInserted(e);
						processingFlag = 1;
					}
				}
			}

			if(!noNewGroup &amp;&amp; !this._hidden &amp;&amp; this._rids.indexOf(rid) &lt; 0) {
				this._addDataRow(rid);
			}

			if(processingFlag === 4) {
				if(this._shared.multiGroupRow) {
					this._dispatchGlobalChange();
				} else {
					this._dispatchDataChange(e);
				}
			} else {
				this._groupViewDirty = true;
				this._dispatchGlobalChange();
			}
		}
		return processingFlag;
	}

	// recursive task for leaf group
	if(this._isAllowedInGroup(rid, rowData)) {
		var newRowIndex = this._rids.indexOf(rid);
		if(newRowIndex &lt; 0) { // The row is qualified to be in the group, but not in the current view, so insert the row
			this._onRowInserted(e);
			return 2;
		}

		// Perform normal data updating
		if (!this._shared.stalledRids) { // Stalled view cannot be sorted
			if(this._sort()) {
				e["globalChange"] = true;
			}
		}

		this._dispatchDataChange(e);
		return 4; // Update is within the group
	} else {
		if(this._onRowRemoved(e)) {
			return 1;
		}
		return 0; // The row does not belong to this view
	}
};
/** @private
* @param {!Object} e
*/
tr.DataView.prototype._onGroupAdded = function(e) {
	if(!this._hidden) {
		var newGroup = /** @type{tr.DataView} */(e["newGroup"]);
		var rid = newGroup.getGroupRowId();
		this._groupView.push(rid); // Add header row
		this._groupViewDirty = true;
		this._dispatch("groupAdded", e);

		tr.pushArrayItems(this._groupView, newGroup.getFooterRowIds());
	}
};
/** @private
* @param {!Object} e
*/
tr.DataView.prototype._onBeforeGroupAdded = function(e) {
	this._dispatch("beforeGroupAdded", e);
};
/** NOTE: This is not handle well in case of calling this function infinitely
 * @private
* @param {boolean} bottomUp
*/
tr.DataView.prototype._requestRebuildingRowIds = function(bottomUp) {
	if(this._groupMembers) {
		this._groupViewDirty = true;
	}
	if(this._groupLevel &gt; 0) {
		this._parent._requestRebuildingRowIds(bottomUp);
	} else {
		if(bottomUp) { // Regenerate row Ids from children. Use when something is changed and can be resolved from the requester.
			this._rebuildRowIdsFromChildren();
		} else { // Use when something is changed in the hierarchy tree but cannot be resolved by any of the children. Root view then repopulates the entire tree (slow).
			this._updateRowIds();
		}
		this._dispatchGlobalChange();
	}
};
/** There should be no other operation after calling this method
* @private
*/
tr.DataView.prototype._refreshAndNotify = function() {
	this._updateRowIds();
	this._dispatchGlobalChange();
};
/** @private
*/
tr.DataView.prototype._onRefreshTimeout = function() {
	this._refreshTimerId = 0;
	this._refreshAndNotify();
};

/** @private
* @param {string} rid
* @param {string=} opt_nextRid
* @param {number=} opt_fallback
* @return {number}
*/
tr.DataView.prototype._addDataRow = function(rid, opt_nextRid, opt_fallback) {
	var rowIndex = this._getRowIndex(this._rids, opt_nextRid, opt_fallback);
	this._insertItems(this._rids, rowIndex, rid);
	if(this._groupView) {
		if(this._groupMembers) {
			this._groupViewDirty = true;
			return this._insertItems(this._groupView, -1, rid);
		} else if(rowIndex &lt; 0) { // No nextRid, No fallback
			return this._insertItems(this._groupView, -1, rid);
		}

		rowIndex = this._getRowIndex(this._groupView, opt_nextRid, opt_fallback);
		return this._insertItems(this._groupView, rowIndex, rid);
	}

	return (rowIndex &gt;= 0) ? rowIndex : this._rids.length - 1;
};
/** @private
* @param {Array.&lt;string&gt;} ary
* @param {number} idx
* @param {string} item1
* @return {number} Return the first position of the inserted item
*/
tr.DataView.prototype._insertItems = function(ary, idx, item1) {
	if(idx &lt; 0){
		idx = ary.length;
		ary.push(item1);
	} else {
		ary.splice(idx, 0, item1);
	}
	return idx;
};
/** @private
* @param {Array.&lt;string&gt;} rids
* @param {string=} opt_nextRid
* @param {number=} opt_fallback Fallback index in case of no nextRid found
* @return {number} Return negative number if not found
*/
tr.DataView.prototype._getRowIndex = function(rids, opt_nextRid, opt_fallback) {
	if(opt_nextRid == null) {
		return -1;
	}

	var rowIndex = this._rids.indexOf(opt_nextRid);
	if(rowIndex &gt;= 0) {
		return rowIndex;
	}

	if(opt_fallback == null || opt_fallback &gt;= rids.length) {
		return -1;
	}
	return /** @type{number} */(opt_fallback);
};
/**
* @private
* @param {string} rid
*/
tr.DataView.prototype._removeDataRow = function(rid) {
	var at = this._removeArrayItem(this._rids, rid);
	if(this._groupView &amp;&amp; at &gt;= 0) {
		at = this._removeArrayItem(this._groupView, rid);
	}
	return at;
};
/** @private
* @param {Array} ary
* @param {*} item
* @return {number} Index of the removed item
*/
tr.DataView.prototype._removeArrayItem = function(ary, item) {
	var len = ary.length;
	for(var i = 0; i &lt; len; ++i) {
		if(ary[i] === item) {
			ary.splice(i, 1);
			return i;
		}
	}
	return -1;
};
/** Remove multiple array items
* @private
* @param {Array.&lt;string&gt;} ary
* @param {Object.&lt;string, *&gt;} items
* @return {number} First item index that is being removed. NaN if no item is removed
*/
tr.DataView.prototype._removeArrayItems = function(ary, items) {
	var f = NaN;
	var c = 0;
	for(var i = ary.length; --i &gt;= 0;) {
		if (items[ary[i]]) {
			++c;
		} else if(c) {
			f = i + 1;
			ary.splice(f, c);
			c = 0;
		}
	}
	if(c) {
		ary.splice(0, c);
		f = 0;
	}
	return f;
};
/** @private
* @param {string|null} rid
* @param {Object} rowData
* @return {boolean}
*/
tr.DataView.prototype._isAllowedInGroup = function(rid, rowData) {
	// Check if it the row is belong to this group branch
	if(this._groupLevel &gt; 0) {
		var dv = this;
		for(var i = this._groupLevel; --i &gt;= 0;) {
			if(!dv._groupFilterLogic(rid, rowData)) {
				return false;
			}
			dv = dv.getDataSource();
		}
	}

	return true; // The row is in this group
};
/** Check if the row should be filtered out
* @public
* @param {string} rid
* @param {Object} rowData
* @return {boolean}
*/
tr.DataView.prototype.isRowFiltered = function(rid, rowData) {
	if(this._shared.stalledRids) {
		return !this._shared.stalledRids[rid]; // Snapshot override everything else
	}
	if(this._hiddenRids) {
		if(this._hiddenRids[rid]) {
			return true;
		}
	}
	if(this.isSegmentSeparator(rid)) {
		return false; // Segment separator cannot be filtered
	}
	if(this._collapsedRids) {
		if(this._collapsedRids[rid]) {
			return true;
		}
	}

	if(this._userFilter) {
		if(this._userFilter(rid, rowData) === this._filteringOut) {
			return true;
		}
	}
	return false; // The row is not filtered out
};

/** Performance is extremely vital in this method.&lt;br&gt;
* _sort() will be executed by: _onRowUpdated(), _onRowInserted(), _updateRowIds(), and sort()
* @private
* @return {boolean} True if there is any change, otherwise false
*/
tr.DataView.prototype._sort = function() {
	if(this._groupMembers) {
		return false; // DataView with children should not be sorted as sort operation will be done on each child
	}

	if(this._dt._getSegmentSeparators() || this.isSorting()) {
		var rids = this._rids;
		var dataRows = this._dt.getMultipleRowData(rids);
		var segmentValues = this._dt.getSegmentValues(rids);
		var change = tr.DataTable._performMultiLevelSorting(dataRows, this._sortingDefs, segmentValues);

		if(change) {
			this._rids = tr.DataTable._reorderItems(rids, change); // Group view should be changed after this
			this._transformView();
			return true;
		}
	}

	return false;
};

/** @private
* @param {Function} checker
* @param {boolean} filteringOut
* @param {Object=} exceptions
*/
tr.DataView.prototype._quickFilter = function(checker, filteringOut, exceptions) {
	if(!checker) {
		return;
	}

	var rids = this._rids; // Make local variable to speed up the process
	var len = rids.length;
	var dt = this._dt;
	var spliceCount = 0;
	for(var i = len; --i &gt;= 0;) {
		var rid = rids[i];
		var removed = false;
		if(!exceptions || !exceptions[rid]) {
			var values = dt.getRowData(rid);
			if (values) {
				removed = checker(rid, values) === filteringOut;
			} else {
				removed = true;
			}
		}
		if(removed) {
			++spliceCount;
		} else if(spliceCount &gt; 0) {
			rids.splice(i + 1, spliceCount);
			spliceCount = 0;
		}
	}
	if(spliceCount &gt; 0) {
		rids.splice(0, spliceCount);
	}
};
/** @private
* @param {string|Function|undefined} cid
* @param {*} value
* @return {Function} A new function object is created, if cid is a string
*/
tr.DataView.prototype._getFilterLogic = function(cid, value) {
	if(cid != null) {
		if(typeof cid == "function") {
			return cid;
		} else if(typeof cid == "string") {
			return tr.DataView._defaultFilterLogic.bind(null, cid, value);
		} else {
			return tr.DataView._defaultFilterLogic.bind(null, cid + "", value);
		}
	}
	return null;
};

/**
* @private
* @param {number} pageIndex
* @return {boolean} True if there is any change, otherwise false
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype._setPage = function (pageIndex) {
	if (pageIndex &gt; this._lastPageIndex &amp;&amp; this._pageCorrection) {
		pageIndex = this._lastPageIndex;
	}
	if (pageIndex &lt; 1) {
		pageIndex = 1;
	}

	if (pageIndex == this._pageIndex) {
		return false;
	}

	this._pageIndex = pageIndex;
	this._transformView();
	this._dispatch("pageIndexChanged", {"pageIndex": this._pageIndex});
	return true;
};
/** @private
* @param {number=} firstChange Negative value is equivalent to 0
* @return {boolean} Return true if there is any change, otherwise false
*/
tr.DataView.prototype._updatePaginationView = function(firstChange) {
	var dirty = false;
	if(this._pageView) {
		if(!firstChange) { firstChange = 0; }

		var pageStart = this._pageSize * (this._pageIndex - 1);

		var pageEnd = this._pageSize + pageStart;
		if(firstChange &lt; pageEnd) { // The change happens before current page
			var rids = this._groupView || this._rids;
			if (pageEnd &gt; rids.length) { // Shrink view if the last page is not a full page
				pageEnd = rids.length;
			}

			// Populate the page
			var ridsLen = pageEnd - pageStart;
			this._pageView.length = (ridsLen &gt;= 0) ? ridsLen : 0;
			for(var i = pageStart; i &lt; pageEnd; ++i) {
				this._pageView[i - pageStart] = rids[i];
			}
			dirty = true;
		}
	}
	return dirty;
};

/** WARNING: _transformView() may be called due to page index changed
* @private
* @return {boolean} Return true if page index is changed
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype._updatePageCount = function () {
	var lastPageIndex = 1;
	if (this._pageSize &gt; 0) {
		var rows = this._groupView || this._rids;
		var rowCount = (rows.length &gt; 0) ? rows.length : 0;
		lastPageIndex = Math.ceil(rowCount / this._pageSize);
	}
	if(this._lastPageIndex !== lastPageIndex) {
		this._lastPageIndex = lastPageIndex;
		this._dispatch("pageCountChanged", {"pageCount": this._lastPageIndex});

		if(this._lastPageIndex &lt; this._pageIndex &amp;&amp; this._pageCorrection) {
			return this._setPage(this._lastPageIndex);
		}
	}
	return false;
};

/** @private
* @param {string} rid
*/
tr.DataView.prototype._dispatchRowRemoved = function(rid) {
	if(rid) {
		this._dispatchDataChange({"type": "removed", "rid": rid});
	}
};
/** @private
* @param {Array.&lt;string&gt;} rids
*/
tr.DataView.prototype._dispatchMultiRowRemoved = function(rids) {
	if(rids) {
		var count = rids.length;
		if(count === 1) {
			this._dispatchRowRemoved(rids[0]);
		} else if(count &gt; 1) {
			this._dispatchDataChange({"type": "removed", "rids": rids});
		}
	}
};
/** @private
*/
tr.DataView.prototype._dispatchGlobalChange = function() {
	this._dispatchDataChange(tr.DataTable._globalChangeArg);
};
/** @private
* @param {!Object} evtArgument
*/
tr.DataView.prototype._dispatchDataChange = function(evtArgument) {
	this._dispatch("dataChanged", evtArgument);
	if(this._wrapSize &amp;&amp; !this._wrapTimerId) {
		this._wrapTimerId = setTimeout(this._updateWrapCount);
	}
};

/** @private
* @param {tr.DataTable|tr.DataView} source
*/
tr.DataView.prototype._setParent = function (source) {
	this._parent = source;
	this._dt = /** @type{tr.DataTable} */(source);
	do {
		source = source.getDataSource();
		if(source) {
			this._dt = /** @type{tr.DataTable} */(source);
		}
	} while(source);

	if(this._parent &amp;&amp; this._dt !== this._parent) { // Copy shared member from parent data view
		this._shared = this._parent._shared;

		var cids = this._parent._columnStats;
		if(cids) {
			for(var cid in cids) {
				var cs = this.enableColumnStats(cid);
				var pcs = this._parent.getColumnStats(cid);
				if(cs &amp;&amp; pcs) {
					cs.setColumnDataGetter(pcs.getColumnDataGetter());
				}
			}
		}
	}
};

/** @private
*/
tr.DataView.prototype._populateGroups = function () {
	var initialRids = this._rids;
	var i, len, member;
	this._rids = [];

	// Collect members of each group from the available data
	var groupId, groupIds, groupLen;
	var ridMap = {};
	var groupList = [];
	len = initialRids.length;
	for(i = 0; i &lt; len; ++i) {
		var rid = initialRids[i];
		var rowData = this._dt.getRowData(rid);
		if(rowData) {
			groupIds = this._resolveGroupId(rowData);
			groupLen = groupIds.length;
			if(groupLen &gt; 1) {
				// activate multi-group row mode
				this._shared.multiGroupRow = true;
			}
			for(var j = 0; j &lt; groupLen; j++) {
				groupId = groupIds[j];
				var groupedRids = ridMap[groupId];
				if(groupedRids) {
					groupedRids.push(rid);
				} else {
					groupedRids = [rid];
					ridMap[groupId] = groupedRids;
					groupList.push(groupId);
				}
			}
		}
	}

	// Remove groups that have no member
	if(this._shared.autoGroupRemoval) {
		len = this._groupList.length;
		for(i = len; --i &gt;= 0;) {
			groupId = this._groupList[i];
			if(!ridMap[groupId]) { // No member exists
				member = this._groupMembers[groupId];
				if(member &amp;&amp; !member._predefinedGroup) { // Predefined group should not be removed automatically
					this._removeGroupMember(i, groupId);
				}
			}
		}
	}
	// Remove any non existing predefined groups
	var preDefGroups = null;
	if(this._preDefGroups &amp;&amp; this._groupLevel &lt; this._preDefGroups.length) {
		preDefGroups = this._preDefGroups[this._groupLevel];
	}

	len = this._groupList.length;
	if(this._preDefGroupsDirty) {
		this._preDefGroupsDirty = false;
		for(i = len; --i &gt;= 0;) {
			groupId = this._groupList[i];
			member = this._groupMembers[groupId];
			if(member &amp;&amp; member._predefinedGroup) {
				// TODO: Handle the case where predefined groups exist in normal groupList
				if(preDefGroups) {
					if(preDefGroups.indexOf(member._groupId) &lt; 0) {
						this._removeGroupMember(i, groupId);
					}
				} else {
					this._removeGroupMember(i, groupId);
				}
			}
		}
	}


	// Add predefined groups first, allowing user to initially order the groups
	if(preDefGroups) {
		len = preDefGroups.length;
		for(i = 0; i &lt; len; ++i) {
			var pdg = this._addGroup(preDefGroups[i]);
			if(pdg) {
				pdg._predefinedGroup = true;
			}
		}
	}
	// Add normal group
	len = groupList.length;
	for(i = 0; i &lt; len; ++i) {
		this._addGroup(groupList[i]);
	}

	// Add row Id
	len = this._groupList.length;
	for(i = 0; i &lt; len; ++i) { // Re-distribute this object content to all of its group members
		groupId = this._groupList[i];
		member = this._groupMembers[groupId];
		member._updateRowIds(ridMap[groupId]); // member will be sorted individually
		member._markColumnStatsDirty(); // Since there is no event fired for child members
	}

	this._groupViewDirty = true;
	this._rebuildRowIdsFromChildren();
};
/** @private
* @param {number} groupIndex
* @param {string} groupId
*/
tr.DataView.prototype._removeGroupMember = function (groupIndex, groupId) {
	var member = this._groupMembers[groupId];
	if(member) {
		this._groupList.splice(groupIndex, 1);
		delete this._groupMembers[groupId];

		member.dispose(); // Clear everything. Note that this will call groupBy(null);
	}
};
/** @private
* @param {string} cid
* @param {Object.&lt;string, *&gt;} values
* @return {Array.&lt;string&gt;}
*/
tr.DataView.prototype._defaultGroupCriteria = function(cid, values) {
	var val = values[cid];
	if(Array.isArray(val)) {
		return val.map(function(data) {
			return data + "";
		});
	} else {
		return [val + ""];
	}
};
/** @private
* @param {string|null} rid
* @param {Object.&lt;string, *&gt;} values
* @return {boolean}
*/
tr.DataView.prototype._groupFilterLogic = function(rid, values) {
	var gids = this._groupCriteria[this._groupLevel - 1](values);
	return gids.indexOf(this._groupId) &gt;= 0;
};

/** @private
* @param {string} strA
* @param {string} strB
* @return {number}
*/
tr.DataView.prototype._internalGroupSortingLogic = function(strA, strB) {
	var dvA = this._groupMembers[strA];
	var dvB = this._groupMembers[strB];

	return this._groupSortingLogic(strA, strB, dvA, dvB);
};

/** @private
* @param {*} value
* @return {tr.DataView} Newly added group member. If it already exists, this method returns null.
*/
tr.DataView.prototype._addGroup = function (value) {
	var groupId = value + "";
	if(!groupId) {
		// window.console.log("WARNING: Group Id cannot be an empty string");
		return null;
	}
	var member = this._groupMembers[groupId];
	if(member) {
		return null;
	}
	var parentGrpRowId = this._groupRowId || "_grp";
	var newGrpRowId = parentGrpRowId + "_" + groupId;
	var arg;
	if(this._hasListener("beforeGroupAdded")) {
		arg = {
			"dataView": this, // parent
			"newGroupId": groupId,
			"newGroupValue": value,
			"newGroupRowId": newGrpRowId,
			"newGroupLevel": this._groupLevel + 1
		};
		this._dispatch("beforeGroupAdded", arg);
		if(arg["cancel"]) {
			return null;
		}
	}
	member = new tr.DataView();
	member._groupId = groupId;
	if(typeof value == "string") { // TODO: Raw value should not always be a string
		if(value == "null") {
			member._groupValue = null;
		} else if(value != "undefined") {
			member._groupValue = value;
		} // else { value is undefined string
	} else {
		member._groupValue = value;
	}

	if (arg &amp;&amp; arg["hideHeaderRow"] === true) {
		member._hiddenHeaderRow = true;
	}

	member._groupRowId = newGrpRowId;
	member._groupLevel = this._groupLevel + 1;
	member._groupCriteria = this._groupCriteria; // Shared Member
	member._preDefGroups = this._preDefGroups;
	if(member._groupLevel &lt; member._groupCriteria.length) {
		member._groupMembers = {};
		member._groupList = [];
		member._groupView = [];
	}
	member._groupRows = this._groupRows; // Shared Member
	member._setParent(this);
	member._sortingDefs = this._sortingDefs; // Shared Member

	this._groupMembers[groupId] = member;
	this._groupList.push(groupId);
	this._groupRows[member._groupRowId] = member;

	if(!this._hidden) {
		if (member._isHeaderRowShown()) {
			this._groupView.push(member._groupRowId); // Add header row
		}

		this._groupViewDirty = true;
		member._beingAdded = true;
		this._dispatch("groupAdded", {
			"dataView": this,
			"newGroup": member
		});
		member._beingAdded = false;
	}

	member.listen("groupAdded", this._onGroupAdded);
	if(this._hasListener("beforeGroupAdded")) {
		member.listen("beforeGroupAdded", this._onBeforeGroupAdded);
	}
	return member;
};
/** @private
*/
tr.DataView.prototype._triggerGroupRefreshing = function () {
	if(this._groupLevel &gt; 0) {
		if(this._parent) {
			this._parent._triggerGroupRefreshing();
		}
	} else if(this._groupRows &amp;&amp; !this._refreshTimerId) {
		this._refreshTimerId = setTimeout(this._onRefreshTimeout, 100);
	}
};
/** @private
* @fires tr.DataView#pageCountChanged
* @fires tr.DataView#pageIndexChanged
*/
tr.DataView.prototype._rebuildRowIdsFromChildren = function () {
	if(!this._groupViewDirty) {
		return;
	}

	this._rids.length = 0;
	if(this._groupView) { this._groupView.length = 0; }
	if(!this._hidden) {
		var grpLen = this._groupList.length;
		for(var i = 0; i &lt; grpLen; ++i) { // Re-distribute this object content to all of its group members
			var gid = this._groupList[i];
			var member = this._groupMembers[gid];
			member._rebuildRowIdsFromChildren();

			tr.pushArrayItems(this._rids, member._rids);

			if(!this._collapsed &amp;&amp; this._groupView) {
				if (member._isHeaderRowShown()) {
					this._groupView.push(member._groupRowId); // Add header row
				}
				if(!member._collapsed) { // WARNING: This gives different value from isCollapsed() method
					var rids = member._getFirstHiddenRids() || member._groupView || member._rids;
					tr.pushArrayItems(this._groupView, rids);
					tr.pushArrayItems(this._groupView, member._footerRowIds);
				}
			}
		}
	}
	this._groupViewDirty = false;

	// View has been re-created. So we need to add row expansion
	if(!this._updatePageCount()) {
		this._transformView();
	}
};
/** @private
* @param {Object} rowData
* @return {Array.&lt;string&gt;}
*/
tr.DataView.prototype._resolveGroupId = function (rowData) {
	return /** @type{Array.&lt;string&gt;} */(this._groupCriteria[this._groupLevel](rowData));
};

/** @private
*/
tr.DataView.prototype._markColumnStatsDirty = function() {
	for(var cid in this._columnStats) {
		this._columnStats[cid].markDirty();
	}
};

/** @private
* @function
* @param {string} cid
* @param {*} value
* @param {string} rid
* @param {Object.&lt;string, *&gt;} values
* @return {boolean}
*/
tr.DataView._defaultFilterLogic = function(cid, value, rid, values) {
	return (values[cid] === value);
};
/** @private
* @function
* @param {string} strA
* @param {string} strB
* @return {number}
*/
tr.DataView._defaultGroupSortingLogic = function(strA, strB) {
	if(strA == strB) {
		return 0;
	}
	return (strA &lt; strB) ? -1 : 1;
};


goog.exportSymbol("tr.DataView", tr.DataView);
tr.DataView._proto = tr.DataView.prototype;
(function() {
var pt = tr.DataView.prototype;
var methodMap = {
	"dispose": pt.dispose,

	"getData": pt.getData,
	"getRowData": pt.getRowData,
	"getColumnData": pt.getColumnData,
	"getRowId": pt.getRowId,
	"getAllRowIds": pt.getAllRowIds,
	"getSortedRowIds": pt.getSortedRowIds,
	"getRowIndex": pt.getRowIndex,
	"getRowCount": pt.getRowCount,
	"getDataAt": pt.getDataAt,
	"getRowDataAt": pt.getRowDataAt,
	"getPreviousData": pt.getPreviousData,
	"getMultipleRowData": pt.getMultipleRowData,
	"getAllRowData": pt.getAllRowData,

	"setData": pt.setData,
	"setDataAt": pt.setDataAt,
	"setRowData": pt.setRowData,
	"setRowDataAt": pt.setRowDataAt,
	"setColumnData": pt.setColumnData,

	"insertRow": pt.insertRow,

	"removeRow": pt.removeRow,
	"removeRows": pt.removeRows,
	"moveRow": pt.moveRow,
	"swapRow": pt.swapRow,

	"hideRow": pt.hideRow,
	"hideRows": pt.hideRows,
	"showRows": pt.showRows,
	"unhideAllRows": pt.unhideAllRows,
	"hasHiddenRow": pt.hasHiddenRow,

	"getDataTable": pt.getDataTable,
	"getDataSource": pt.getDataSource,
	"setDataSource": pt.setDataSource,

	"setConflationRate": pt.setConflationRate,
	"getConflationRate": pt.getConflationRate,

	"sort": pt.sort,
	"sortOnce": pt.sortOnce,
	"getSortingLogics": pt.getSortingLogics,
	"setSortingLogic": pt.setSortingLogic,
	"setColumnSortingLogic": pt.setColumnSortingLogic,
	"isSorting": pt.isSorting,

	"filterIn": pt.filterIn,
	"filterOut": pt.filterOut,
	"filterInOnce": pt.filterInOnce,
	"filterOutOnce": pt.filterOutOnce,
	"clearFilter": pt.clearFilter,

	"disablePageCorrection": pt.disablePageCorrection,
	"setPage": pt.setPage,
	"gotoPage": pt.gotoPage,
	"nextPage": pt.nextPage,
	"prevPage": pt.prevPage,
	"previousPage": pt.previousPage,
	"lastPage": pt.lastPage,
	"firstPage": pt.firstPage,
	"getCurrentPage": pt.getCurrentPage,
	"isOnLastPage": pt.isOnLastPage,
	"isOnFirstPage": pt.isOnFirstPage,
	"getPageSize": pt.getPageSize,
	"getPageCount": pt.getPageCount,
	"getTotalPages": pt.getTotalPages,
	"setPageSize": pt.setPageSize,
	"getPageIndex": pt.getPageIndex,

	"groupBy": pt.groupBy,
	"addGroup": pt.addGroup,
	"hasGroup": pt.hasGroup,
	"sortGroups": pt.sortGroups,
	"moveGroup": pt.moveGroup,
	"setPredefinedGroups": pt.setPredefinedGroups,

	"addFooter": pt.addFooter,
	"removeFooter": pt.removeFooter,
	"getFooterRowIds": pt.getFooterRowIds,
	"getFooterRowIndex": pt.getFooterRowIndex,

	"enableMultiGroup": pt.enableMultiGroup,
	"getGroupByRowId": pt.getGroupByRowId,
	"getGroup": pt.getGroup,
	"getAllGroups": pt.getAllGroups,
	"getGroupList": pt.getGroupList,
	"getGroupId": pt.getGroupId,
	"getGroupValue": pt.getGroupValue,
	"getGroupRowId": pt.getGroupRowId,
	"getGroupRows": pt.getGroupRows,
	"getGroupLevel": pt.getGroupLevel,

	"enableColumnStats": pt.enableColumnStats,
	"getColumnStats": pt.getColumnStats,

	"hide": pt.hide,
	"isHidden": pt.isHidden,
	"isHiddenRow": pt.isHiddenRow,
	"collapse": pt.collapse,
	"collapseAllGroups": pt.collapseAllGroups,
	"toggleCollapsedState": pt.toggleCollapsedState,
	"isCollapsed": pt.isCollapsed,
	"enableContentAsHeader": pt.enableContentAsHeader,

	"getVisibleRowIds": pt.getVisibleRowIds,
	"getVisibleRowCount": pt.getVisibleRowCount,
	"isRowDataInGroup": pt.isRowDataInGroup,
	"isRowIdInGroup": pt.isRowIdInGroup,

	"addRowExpansion": pt.addRowExpansion,
	"removeRowExpansion": pt.removeRowExpansion,
	"toggleRowExpansion": pt.toggleRowExpansion,
	"removeAllRowExpansions": pt.removeAllRowExpansions,
	"getRowsWithExpansion": pt.getRowsWithExpansion,
	"getExpansionParents": pt.getExpansionParents,
	"hasRowExpansion": pt.hasRowExpansion,
	"isRowExpansion": pt.isRowExpansion,
	"getRowExpansionId": pt.getRowExpansionId,
	"getRowExpansionIndex": pt.getRowExpansionIndex,

	"searchAll": pt.searchAll,
	"searchPrev": pt.searchPrev,
	"searchNext": pt.searchNext,

	"stall": pt.stall,
	"enableAutoGroupRemoval": pt.enableAutoGroupRemoval,
	"enableAutoGroupHiding": pt.enableAutoGroupHiding,

	"synchronizeRowOrder": pt.synchronizeRowOrder,
	"setSegmentSeparator": pt.setSegmentSeparator,
	"unsetAllSegmentSeparators": pt.unsetAllSegmentSeparators,
	"hasSegmentation": pt.hasSegmentation,
	"isSegmentSeparator": pt.isSegmentSeparator,
	"getSegmentParentRowId": pt.getSegmentParentRowId,

	"collapseSegment": pt.collapseSegment,
	"expandSegment": pt.expandSegment,
	"expandAllSegments": pt.expandAllSegments,
	"isSegmentCollapsed": pt.isSegmentCollapsed,
	"setSegmentCollapsingLogic": pt.setSegmentCollapsingLogic,
	"fillSegment": pt.fillSegment,
	"fillSegments": pt.fillSegments,
	"addSegmentChild": pt.addSegmentChild,
	"addSegmentChildren": pt.addSegmentChildren,
	"removeSegmentChild": pt.removeSegmentChild,
	"removeSegmentChildren": pt.removeSegmentChildren,
	"removeAllSegmentChildren": pt.removeAllSegmentChildren,
	"getSegmentIds": pt.getSegmentIds,
	"getSegmentChildIds": pt.getSegmentChildIds,
	"sortSegments": pt.sortSegments,
	"getWrapSize": pt.getWrapSize,
	"getWrappedViews": pt.getWrappedViews,
	"wrapView": pt.wrapView,

	"dump": pt.dump,
	"log": pt.log
};
// Export methods for Closure's advanced compilation
for(var methodName in methodMap) {
	goog.exportProperty(pt, methodName, methodMap[methodName]);
}
})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="AdFin.html">AdFin</a></li><li><a href="DateTime.html">DateTime</a></li><li><a href="Info.html">Info</a></li><li><a href="Logic.html">Logic</a></li><li><a href="Math.html">Math</a></li><li><a href="Realtime.html">Realtime</a></li><li><a href="Statistic.html">Statistic</a></li><li><a href="Text.html">Text</a></li><li><a href="tr.ElementFrameWork.html">ElementFrameWork</a></li><li><a href="tr.PipDefinition.html">PipDefinition</a></li></ul><h3>Classes</h3><ul><li><a href="tr.ADCSubscription.html">ADCSubscription</a></li><li><a href="tr.AdFinSubscription.html">AdFinSubscription</a></li><li><a href="tr.cgrid.editor.TextBox.html">TextBox</a></li><li><a href="tr.cgrid.filter.TextBox.html">TextBox</a></li><li><a href="tr.cgrid.formatter.AsyncFormatter.html">AsyncFormatter</a></li><li><a href="tr.cgrid.formatter.CheckBox.html">CheckBox</a></li><li><a href="tr.cgrid.formatter.UpDownColor.html">UpDownColor</a></li><li><a href="tr.ColumnStats.html">ColumnStats</a></li><li><a href="tr.CompositeGrid.html">CompositeGrid</a></li><li><a href="tr.DataCache.html">DataCache</a></li><li><a href="tr.DataTable.html">DataTable</a></li><li><a href="tr.DataView.html">DataView</a></li><li><a href="tr.DropDown.html">DropDown</a></li><li><a href="tr.ElementControl.html">ElementControl</a></li><li><a href="tr.ElementWrapper.html">ElementWrapper</a></li><li><a href="tr.Event.html">Event</a></li><li><a href="tr.EventDispatcher.html">EventDispatcher</a></li><li><a href="tr.EventDispatcher.extendClass-tempCtor.html">tempCtor</a></li><li><a href="tr.EventManager.html">EventManager</a></li><li><a href="tr.FieldFormatter.html">FieldFormatter</a></li><li><a href="tr.fn.Engine.html">Engine</a></li><li><a href="tr.fn.Formula.html">Formula</a></li><li><a href="tr.fn.VariableToken.html">VariableToken</a></li><li><a href="tr.Grid.html">Grid</a></li><li><a href="tr.grid.BidOfferSpan.html">BidOfferSpan</a></li><li><a href="tr.grid.Blinker.html">Blinker</a></li><li><a href="tr.grid.Cell.html">Cell</a></li><li><a href="tr.grid.CellBlinkingPlugin.html">CellBlinkingPlugin</a></li><li><a href="tr.grid.CellEditingPlugin.html">CellEditingPlugin</a></li><li><a href="tr.grid.CellFloatingPanel.html">CellFloatingPanel</a></li><li><a href="tr.grid.CellPainter.html">CellPainter</a></li><li><a href="tr.grid.CellSpan.html">CellSpan</a></li><li><a href="tr.grid.CellSpans.html">CellSpans</a></li><li><a href="tr.grid.CellWriter.html">CellWriter</a></li><li><a href="tr.grid.CheckboxColumnPlugin.html">CheckboxColumnPlugin</a></li><li><a href="tr.grid.ColumnFilterPlugin.html">ColumnFilterPlugin</a></li><li><a href="tr.grid.ColumnSelectionPlugin.html">ColumnSelectionPlugin</a></li><li><a href="tr.grid.ColumnStackingPlugin.html">ColumnStackingPlugin</a></li><li><a href="tr.grid.ColumnWidthAdjustingPlugin.html">ColumnWidthAdjustingPlugin</a></li><li><a href="tr.grid.Conflator.html">Conflator</a></li><li><a href="tr.grid.DataSourceTreePlugin.html">DataSourceTreePlugin</a></li><li><a href="tr.grid.DirectContentBindingPlugin.html">DirectContentBindingPlugin</a></li><li><a href="tr.grid.DragAndDropTitlePlugin.html">DragAndDropTitlePlugin</a></li><li><a href="tr.grid.DraggableContentPlugin.html">DraggableContentPlugin</a></li><li><a href="tr.grid.FindBar.html">FindBar</a></li><li><a href="tr.grid.FindBarPlugin.html">FindBarPlugin</a></li><li><a href="tr.grid.GroupStatisticsPlugin.html">GroupStatisticsPlugin</a></li><li><a href="tr.grid.HeatMapRenderer.html">HeatMapRenderer</a></li><li><a href="tr.grid.HScrollbar.html">HScrollbar</a></li><li><a href="tr.grid.IndexMarker.html">IndexMarker</a></li><li><a href="tr.grid.MovableHeaderPlugin.html">MovableHeaderPlugin</a></li><li><a href="tr.grid.NumberFormatter.html">NumberFormatter</a></li><li><a href="tr.grid.PercentBar.html">PercentBar</a></li><li><a href="tr.grid.PercentBarRenderer.html">PercentBarRenderer</a></li><li><a href="tr.grid.Plugin.html">Plugin</a></li><li><a href="tr.grid.RangeBar.html">RangeBar</a></li><li><a href="tr.grid.ResizableTitlePlugin.html">ResizableTitlePlugin</a></li><li><a href="tr.grid.Reverter.html">Reverter</a></li><li><a href="tr.grid.RowHeightAdjustingPlugin.html">RowHeightAdjustingPlugin</a></li><li><a href="tr.grid.RowSelectionPlugin.html">RowSelectionPlugin</a></li><li><a href="tr.grid.Scrollbar.html">Scrollbar</a></li><li><a href="tr.grid.SectionSettings.html">SectionSettings</a></li><li><a href="tr.grid.SmartTooltipsPlugin.html">SmartTooltipsPlugin</a></li><li><a href="tr.grid.SortableTitlePlugin.html">SortableTitlePlugin</a></li><li><a href="tr.grid.Virtualizer.html">Virtualizer</a></li><li><a href="tr.grid.VScrollbar.html">VScrollbar</a></li><li><a href="tr.grid.ZoomPlugin.html">ZoomPlugin</a></li><li><a href="tr.HttpRequest.html">HttpRequest</a></li><li><a href="tr.IntervalSubscription.html">IntervalSubscription</a></li><li><a href="tr.LayoutGrid.html">LayoutGrid</a></li><li><a href="tr.ListMenu.html">ListMenu</a></li><li><a href="tr.MenuItem.html">MenuItem</a></li><li><a href="tr.MockArchive.html">MockArchive</a></li><li><a href="tr.MockJET.html">MockJET</a></li><li><a href="tr.MockQuotes.html">MockQuotes</a></li><li><a href="tr.MockQuotes2.html">MockQuotes2</a></li><li><a href="tr.MockSubscription.html">MockSubscription</a></li><li><a href="tr.MockSubscriptions.html">MockSubscriptions</a></li><li><a href="tr.Popup.html">Popup</a></li><li><a href="tr.PopupMenu.html">PopupMenu</a></li><li><a href="tr.PrintTrait.html">PrintTrait</a></li><li><a href="tr.RequestQueue.html">RequestQueue</a></li><li><a href="tr.Segment.html">Segment</a></li><li><a href="tr.SegmentCollection.html">SegmentCollection</a></li><li><a href="tr.TSISubscription.html">TSISubscription</a></li><li><a href="tr.WrappedView.html">WrappedView</a></li></ul><h3>Interfaces</h3><ul><li><a href="tr.cgrid.ICompositeExtension.html">ICompositeExtension</a></li><li><a href="tr.grid.IPlugin.html">IPlugin</a></li><li><a href="tr.IElementControl.html">IElementControl</a></li><li><a href="tr.ILayoutGrid.html">ILayoutGrid</a></li></ul><h3>Events</h3><ul><li><a href="tr.CompositeGrid.html#event:cellClicked">cellClicked</a></li><li><a href="tr.CompositeGrid.html#event:cellDblClicked">cellDblClicked</a></li><li><a href="tr.CompositeGrid.html#event:cellMouseDown">cellMouseDown</a></li><li><a href="tr.CompositeGrid.html#event:cellRightClicked">cellRightClicked</a></li><li><a href="tr.CompositeGrid.html#event:columnSorted">columnSorted</a></li><li><a href="tr.CompositeGrid.html#event:editorAttached">editorAttached</a></li><li><a href="tr.CompositeGrid.html#event:editorDetached">editorDetached</a></li><li><a href="tr.CompositeGrid.html#event:filterAdded">filterAdded</a></li><li><a href="tr.CompositeGrid.html#event:filterCleared">filterCleared</a></li><li><a href="tr.CompositeGrid.html#event:filterModified">filterModified</a></li><li><a href="tr.CompositeGrid.html#event:filterRemoved">filterRemoved</a></li><li><a href="tr.CompositeGrid.html#event:mouseLeaveCell">mouseLeaveCell</a></li><li><a href="tr.CompositeGrid.html#event:mouseOverCell">mouseOverCell</a></li><li><a href="tr.CompositeGrid.html#event:pageChanged">pageChanged</a></li><li><a href="tr.CompositeGrid.html#event:selectionChanged">selectionChanged</a></li><li><a href="tr.DataCache.html#event:dataChanged">dataChanged</a></li><li><a href="tr.DataCache.html#event:dataComposed">dataComposed</a></li><li><a href="tr.DataTable.html#event:dataChanged">dataChanged</a></li><li><a href="tr.DataTable.html#event:dataComposed">dataComposed</a></li><li><a href="tr.DataView.html#event:beforeFiltering">beforeFiltering</a></li><li><a href="tr.DataView.html#event:beforeGroupAdded">beforeGroupAdded</a></li><li><a href="tr.DataView.html#event:dataChanged">dataChanged</a></li><li><a href="tr.DataView.html#event:groupAdded">groupAdded</a></li><li><a href="tr.DataView.html#event:groupCriteriaChanged">groupCriteriaChanged</a></li><li><a href="tr.DataView.html#event:pageCountChanged">pageCountChanged</a></li><li><a href="tr.DataView.html#event:pageIndexChanged">pageIndexChanged</a></li><li><a href="tr.DataView.html#event:preDisposed">preDisposed</a></li><li><a href="tr.DataView.html#event:wrapCountChanged">wrapCountChanged</a></li><li><a href="tr.DataView.html#event:wrapSizeChanged">wrapSizeChanged</a></li><li><a href="tr.Formula.html#event:dataCacheChanged">dataCacheChanged</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:cancelled">cancelled</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:change">change</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:closed">closed</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:editorOpened">editorOpened</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:preEditorOpening">preEditorOpening</a></li><li><a href="tr.grid.CheckboxColumnPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.ColumnFilterPlugin.html#event:click">click</a></li><li><a href="tr.grid.ColumnFilterPlugin.html#event:iconCreated">iconCreated</a></li><li><a href="tr.grid.ColumnStackingPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.ColumnStackingPlugin.html#event:iconCreated">iconCreated</a></li><li><a href="tr.grid.DragAndDropTitlePlugin.html#event:columnMoved">columnMoved</a></li><li><a href="tr.grid.DragAndDropTitlePlugin.html#event:dragged">dragged</a></li><li><a href="tr.grid.DraggableContentPlugin.html#event:drag">drag</a></li><li><a href="tr.grid.DraggableContentPlugin.html#event:dragEnd">dragEnd</a></li><li><a href="tr.grid.DraggableContentPlugin.html#event:dragStart">dragStart</a></li><li><a href="tr.grid.FindBarPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.MovableHeaderPlugin.html#event:dragged">dragged</a></li><li><a href="tr.grid.MovableHeaderPlugin.html#event:groupMoved">groupMoved</a></li><li><a href="tr.grid.MovableHeaderPlugin.html#event:sectionMoved">sectionMoved</a></li><li><a href="tr.grid.RowSelectionPlugin.html#event:selectionChanged">selectionChanged</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:columnSorted">columnSorted</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:preClicked">preClicked</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:preDataSorting">preDataSorting</a></li><li><a href="tr.Grid.html#event:columnAdded">columnAdded</a></li><li><a href="tr.Grid.html#event:columnAlignmentChanged">columnAlignmentChanged</a></li><li><a href="tr.Grid.html#event:columnRemoved">columnRemoved</a></li><li><a href="tr.Grid.html#event:columnVisibilityChanged">columnVisibilityChanged</a></li><li><a href="tr.Grid.html#event:dataSourceChanged">dataSourceChanged</a></li><li><a href="tr.Grid.html#event:postSectionDataBinding">postSectionDataBinding</a></li><li><a href="tr.Grid.html#event:rowExpansionBinding">rowExpansionBinding</a></li><li><a href="tr.Grid.html#event:rowHighlighted">rowHighlighted</a></li><li><a href="tr.Grid.html#event:sectionAdded">sectionAdded</a></li><li><a href="tr.Grid.html#event:widthChanged">widthChanged</a></li><li><a href="tr.HttpRequest.html#event:abort">abort</a></li><li><a href="tr.HttpRequest.html#event:error">error</a></li><li><a href="tr.HttpRequest.html#event:load">load</a></li><li><a href="tr.HttpRequest.html#event:loadend">loadend</a></li><li><a href="tr.HttpRequest.html#event:loadstart">loadstart</a></li><li><a href="tr.HttpRequest.html#event:timeout">timeout</a></li><li><a href="tr.IElementControl.html#event:blur">blur</a></li><li><a href="tr.IElementControl.html#event:change">change</a></li><li><a href="tr.IElementControl.html#event:click">click</a></li><li><a href="tr.IElementControl.html#event:contextmenu">contextmenu</a></li><li><a href="tr.IElementControl.html#event:dblclick">dblclick</a></li><li><a href="tr.IElementControl.html#event:drag">drag</a></li><li><a href="tr.IElementControl.html#event:dragend">dragend</a></li><li><a href="tr.IElementControl.html#event:dragenter">dragenter</a></li><li><a href="tr.IElementControl.html#event:dragleave">dragleave</a></li><li><a href="tr.IElementControl.html#event:dragover">dragover</a></li><li><a href="tr.IElementControl.html#event:dragstart">dragstart</a></li><li><a href="tr.IElementControl.html#event:drop">drop</a></li><li><a href="tr.IElementControl.html#event:focus">focus</a></li><li><a href="tr.IElementControl.html#event:formchange">formchange</a></li><li><a href="tr.IElementControl.html#event:forminput">forminput</a></li><li><a href="tr.IElementControl.html#event:input">input</a></li><li><a href="tr.IElementControl.html#event:invalid">invalid</a></li><li><a href="tr.IElementControl.html#event:keydown">keydown</a></li><li><a href="tr.IElementControl.html#event:keypress">keypress</a></li><li><a href="tr.IElementControl.html#event:keyup">keyup</a></li><li><a href="tr.IElementControl.html#event:mousedown">mousedown</a></li><li><a href="tr.IElementControl.html#event:mousemove">mousemove</a></li><li><a href="tr.IElementControl.html#event:mouseout">mouseout</a></li><li><a href="tr.IElementControl.html#event:mouseover">mouseover</a></li><li><a href="tr.IElementControl.html#event:mouseup">mouseup</a></li><li><a href="tr.IElementControl.html#event:mousewheel">mousewheel</a></li><li><a href="tr.IElementControl.html#event:reset">reset</a></li><li><a href="tr.IElementControl.html#event:scroll">scroll</a></li><li><a href="tr.IElementControl.html#event:select">select</a></li><li><a href="tr.IElementControl.html#event:submit">submit</a></li><li><a href="tr.ILayoutGrid.html#event:blur">blur</a></li><li><a href="tr.ILayoutGrid.html#event:change">change</a></li><li><a href="tr.ILayoutGrid.html#event:click">click</a></li><li><a href="tr.ILayoutGrid.html#event:contextmenu">contextmenu</a></li><li><a href="tr.ILayoutGrid.html#event:dblclick">dblclick</a></li><li><a href="tr.ILayoutGrid.html#event:drag">drag</a></li><li><a href="tr.ILayoutGrid.html#event:dragend">dragend</a></li><li><a href="tr.ILayoutGrid.html#event:dragenter">dragenter</a></li><li><a href="tr.ILayoutGrid.html#event:dragleave">dragleave</a></li><li><a href="tr.ILayoutGrid.html#event:dragover">dragover</a></li><li><a href="tr.ILayoutGrid.html#event:dragstart">dragstart</a></li><li><a href="tr.ILayoutGrid.html#event:drop">drop</a></li><li><a href="tr.ILayoutGrid.html#event:focus">focus</a></li><li><a href="tr.ILayoutGrid.html#event:formchange">formchange</a></li><li><a href="tr.ILayoutGrid.html#event:forminput">forminput</a></li><li><a href="tr.ILayoutGrid.html#event:input">input</a></li><li><a href="tr.ILayoutGrid.html#event:invalid">invalid</a></li><li><a href="tr.ILayoutGrid.html#event:keydown">keydown</a></li><li><a href="tr.ILayoutGrid.html#event:keypress">keypress</a></li><li><a href="tr.ILayoutGrid.html#event:keyup">keyup</a></li><li><a href="tr.ILayoutGrid.html#event:mousedown">mousedown</a></li><li><a href="tr.ILayoutGrid.html#event:mousemove">mousemove</a></li><li><a href="tr.ILayoutGrid.html#event:mouseout">mouseout</a></li><li><a href="tr.ILayoutGrid.html#event:mouseover">mouseover</a></li><li><a href="tr.ILayoutGrid.html#event:mouseup">mouseup</a></li><li><a href="tr.ILayoutGrid.html#event:mousewheel">mousewheel</a></li><li><a href="tr.ILayoutGrid.html#event:reset">reset</a></li><li><a href="tr.ILayoutGrid.html#event:scroll">scroll</a></li><li><a href="tr.ILayoutGrid.html#event:select">select</a></li><li><a href="tr.ILayoutGrid.html#event:submit">submit</a></li><li><a href="tr.LayoutGrid.html#event:rowCountChanged">rowCountChanged</a></li><li><a href="tr.LayoutGrid.html#event:rowHeightChanged">rowHeightChanged</a></li><li><a href="tr.LayoutGrid.html#event:rowHighlighted">rowHighlighted</a></li><li><a href="tr.Popup.html#event:hidden">hidden</a></li><li><a href="tr.Popup.html#event:shown">shown</a></li><li><a href="tr.PopupMenu.html#event:hidden">hidden</a></li><li><a href="tr.PopupMenu.html#event:shown">shown</a></li><li><a href="tr.PrintTrait.html#event:afterprint">afterprint</a></li><li><a href="tr.PrintTrait.html#event:beforeprint">beforeprint</a></li><li><a href="tr.PrintTrait.html#event:pageCounting">pageCounting</a></li><li><a href="tr.WrappedView.html#event:dataChanged">dataChanged</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cellRef%255Bundefined%255D">cellRef[undefined]</a></li><li><a href="global.html#e%255Bundefined%255D">e[undefined]</a></li><li><a href="global.html#.textContent">.textContent</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#input%255Bundefined%255D">input[undefined]</a></li><li><a href="global.html#q%255Bundefined%255D">q[undefined]</a></li><li><a href="global.html#sortingDef%255B1%255D">sortingDef[1]</a></li></ul>
</nav>


<script src="scripts/linenumber.js"> </script>
<script src="scripts/prettify.js"> </script>
<script> prettyPrint(); </script>
</body>
</html>
