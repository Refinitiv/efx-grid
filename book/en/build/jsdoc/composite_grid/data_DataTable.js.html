<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: data/DataTable.js</title>

    <script src="scripts/prettify.js"> </script>
    <script src="scripts/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/default.css">
    <link type="text/css" rel="stylesheet" href="styles/elf-template.css">
</head>

<body>

<div id="main-template" class="elf-template">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>goog.provide("tr.DataTable");
goog.require("tr.DataCache");
goog.require("tr.SegmentCollection");

/** Trigger when data within the table has been changed
* @event tr.DataTable#dataChanged
* @property {boolean} globalChange Indicates a big change. User should expect all data has been change
* @property {string} type Type of changes. Possible values are "inserted", "removed", "updated", and undefined
* @property {string} rid Row Id
* @property {Object.&lt;string, *&gt;} rowData Column values of the changed row in JSON object format
*/

/** Trigger before tr.DataTable#dataChanged. Perform any data update during the event will NOT cause more dataChanged events
* @event tr.DataTable#dataComposed
*/

/** @constructor
* @extends {tr.DataCache}
*/
tr.DataTable = function() {
	tr.DataTable.base(this, 'constructor');
	
	this._removeRows = this._removeRows.bind(this);
	this._bySegmentSeparator = this._bySegmentSeparator.bind(this);

	this._prevData = {};
	this._rids = [];

	this._compMap = {};
};
goog.inherits(tr.DataTable, tr.DataCache);

/** @private
* @type {Object.&lt;string, Object.&lt;string, *&gt;&gt;}
*/
tr.DataTable.prototype._prevData = null; // Mainly used for blinking
/** @private
* @type {!Array.&lt;string&gt;}
*/
tr.DataTable.prototype._rids;
/** @private
* @type {boolean}
*/
tr.DataTable.prototype._frozen = false;
/** @private
* @type {number}
*/
tr.DataTable.prototype._runningId = 0;

/** Comparer map that will be shared across all child DataViews
* @private
* @type {Object.&lt;string, tr.DataTable.SortLogic&gt;}
*/
tr.DataTable.prototype._compMap = null;

/** @private
* @type {tr.SegmentCollection}
*/
tr.DataTable.prototype._segments = null;
/** @private
* @type {boolean}
*/
tr.DataTable.prototype._autoSegmentFilling = false;
/** @private
* @type {Object}
*/
tr.DataTable.prototype._removedRows = null;
/** @private
* @type {Function}
*/
tr.DataTable.prototype._userSegmentComparer = null;


/** @typedef {Function} tr.DataTable~SortLogic
* @description SortLogic function is used for comparison between two values during sorting. &lt;br&gt;
* The function should return:&lt;br&gt;
* negative value to put val1 before val2, &lt;br&gt;
* positive value to put val2 before val1. &lt;br&gt;
* zero or falsy value to keep val1 and val2 unchanged.
* @property {*} val1 Value from a row
* @property {*} val2 Value from another row
* @property {number=} order 1 indicates ascending order, and -1 indicates descending order
* @property {*=} contextObject Any given user context
* @example
* var customComparer = function(a, b, order) {
*   if(a + 10 &lt; b) { return -order; }
*   if(b + 10 &lt; a) { return order; } 
*   return 0; // a and b are less than 10 difference apart
* };
*/
tr.DataTable.SortLogic;


/** @override
*/
tr.DataTable.prototype.dispose = function() {
	this.unlistenAll();
	this.clearAllData(true);

	this._compMap = null; // Release user function that may be bound
	this._segments = null;
};

/** {@link tr.DataCache#getColumnData}
* @override
*/
tr.DataTable.prototype.getColumnData = function(cid) {
	var rows = new Array(this._rids.length);
	for(var i = this._rids.length; --i &gt;= 0;) {
		rows[i] = this._rows[this._rids[i]][cid];
	}
	return rows;
};
/** @public
* @param {number} rowIndex
* @return {string}
*/
tr.DataTable.prototype.getRowId = function(rowIndex) {
	return this._rids[rowIndex] || "";
};
/** {@link tr.DataCache#getAllRowIds}
* @override
* @param {boolean=} opt_shallowCopy Default value is false. Set to true for speed
*/
tr.DataTable.prototype.getAllRowIds = function(opt_shallowCopy) {
	if(opt_shallowCopy) {
		return this._rids;
	}
	return this._rids.slice(0); // Fastest way to clone an array
};
/** @public
* @param {string} rid
* @return {number}
*/
tr.DataTable.prototype.getRowIndex = function(rid) {
	return this._rids.indexOf(rid);
};
/** @public
* @return {number}
*/
tr.DataTable.prototype.getRowCount = function() {
	return this._rids.length;
};
/** @public
* @param {number} rowIndex
* @param {string} cid
*/
tr.DataTable.prototype.getDataAt = function(rowIndex, cid) {
	return this.getData(this._rids[rowIndex], cid);
};
/** @public
* @param {number} rowIndex
* @return {Object.&lt;string, *&gt;}
*/
tr.DataTable.prototype.getRowDataAt = function(rowIndex) {
	return this.getRowData(this._rids[rowIndex]);
};
/** Get previously set data. This is good for blinking changed data
* @public
* @param {string} rid
* @param {string} cid
*/
tr.DataTable.prototype.getPreviousData = function(rid, cid) {
	var row = this._prevData[rid] || null;
	if(row) {
		return row[cid];
	}
	return undefined;
};

/** Set data to individual cell
* @override
* @param {string} rid Row Id
* @param {string} cid Column Id
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype.setData = function(rid, cid, value) { // Data changed event may be dispatched
	if(!this._needFiring()) {
		return this._setData(rid, cid, value);
	}
	var values = {};
	values[cid] = value;
	return this.setRowData(rid, values);
};
/** Set data in row manner
* @override
* @param {string} rid Row Id
* @param {Object.&lt;string, *&gt;=} values Object where the key is column Id and value is the data to be set
* @param {Object=} eventArg Additional arguments to be attached to the event fired
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataTable#dataChanged
* @example
* var dt = new DataTable();
* dt.setRowData("row 1", {"column 1": "a", "column 2": 1, "column 3": null});
* dt.log(); // See console for the results
*/
tr.DataTable.prototype.setRowData = function(rid, values, eventArg) { // Data changed event may be dispatched
	if(!rid) {
		return false;
	}

	var row = this.getRowData(rid);
	var dirty = false;
	var type = "updated";
	var segmentChanged = false;

	if(values) {
		if(!row) {
			type = "inserted";
			row = values;
			this._rows[rid] = row; // WARNING: Dangerous use of external reference. User may modify data without using DataTable's API
			this._prevData[rid] = {};
			if(eventArg) {
				var nextRid = /** @type{string} */(eventArg["nextRid"]); // Used for insertion only
				var rowIndex = (nextRid != null) ? this.getRowIndex(nextRid) : -1;
				if(rowIndex &lt; 0) {
					rowIndex = /** @type{number} */(eventArg["fallback"]);
				}
				if(rowIndex == null || rowIndex &lt; 0 || rowIndex &gt;= this._rids.length) {
					this._rids.push(rid);
				} else {
					this._rids.splice(rowIndex, 0, rid);
					segmentChanged = !this._isLastSegment(rowIndex);
				}
			} else {
				this._rids.push(rid);
			}
		} else {
			var prevData = this._prevData[rid];
			for (var cid in values) {
				prevData[cid] = row[cid];
				row[cid] = values[cid];
			}
		}
		dirty = true;
	} else {
		if(row) {
			type = "removed";
			// WARNING: Even if row is removed we still keep previous data
			// delete this._prevData[rid];
			this._prevData[rid] = this._rows[rid]; // Move reference from the removed row to history
			delete this._rows[rid];
			if(this._segments) {
				segmentChanged = this._segments.containsSegment(rid); // TODO: Handle this case where the segment separator row is removed
			}
			for(var i = this._rids.length; --i &gt;= 0;) {
				if(this._rids[i] === rid) {
					this._rids.splice(i, 1);
					break;
				}
			}
			dirty = true;
		}
	}

	if(dirty &amp;&amp; this._needFiring()) {
		this._autoFillSegments();
		var e = eventArg || {};
		e["rid"] = rid;
		e["changes"] = values; // WARNING: External user data is passed along
		e["rowData"] = row;
		e["type"] = type;
		if(segmentChanged) {
			e["segmentChanged"] = true;
		}
		this._dispatchDataChange(e);
	}
	return dirty;
};
/** Set data in a column manner. This is faster than repeatedly calling {@link tr.DataTable#setData}
* @public
* @param {string} cid
* @param {Array.&lt;*&gt;} valueList
* @param {Array.&lt;string&gt;=} opt_ridList Specify row id to be set corresponding to the data item
* @example
* var dt = new DataTable();
* dt.setColumnData("column 1", ["1st row data", "2nd row data", "3rd row data"]);
* dt.log(); // See console for the results
*/
tr.DataTable.prototype.setColumnData = function(cid, valueList, opt_ridList) { // Data changed event may be dispatched
	var rLen = (valueList) ? valueList.length : 0;
	if(rLen &lt; 0) { return; }

	var prevFrozen = this._frozen;
	this.freeze();
	var rids = this._generateRids(rLen, opt_ridList);

	for(var r = 0; r &lt; rLen; ++r) {
		this._setData(rids[r], cid, valueList[r]);
	}

	this.freeze(prevFrozen);
};
/** Add, update, and remove data in batch by using JSON object. This is faster than repeatedly calling {@link tr.DataTable#setRowData}. &lt;br&gt;
Any existing row, that is not matched by the same row id provided in the argument, remains the same. &lt;br&gt;
Any existing row with the same row id from the provided argument will be updated. &lt;br&gt;
Row id with null value will cause a removal of the row with the same id.
* @public
* @param {Object.&lt;string, Object.&lt;string, *&gt;&gt;} obj Object is 2 level nested object where 1st level key is row Id and 2nd level key is column Id
* @see {@link tr.DataTable#addRows}
* @see {@link tr.DataTable#setDataFrom2DArray}
* @example
* var data = {
*   "rowId 1": {"column 1": "a", "column 2": 1, "column 3": 2},
*   "rowId 2": {"column 1": "b", "column 2": 3, "column 3": 4},
*   "rowId 4": {"column 1": "d", "group_criteria": 1} // Rows don't need to be in uniform structure
* };
* var dt = new DataTable();
* dt.setDataFromObjectMap(data);
* dt.log(); // See console for the results
* dt.setDataFromObjectMap({"rowId 1": null}); // Remove the row with "rowId 1"
* dt.setDataFromObjectMap({"rowId 2": {"column 1": "newValue"} }); // Update existing row
*/
tr.DataTable.prototype.setDataFromObjectMap = function(obj) {
	if(!obj) { 
		return; 
	}
	if(Array.isArray(obj)) {
		this.addRows(/** @type{Array.&lt;Object&gt;} */(obj));
		return;
	}
	
	var prevFrozen = this._frozen;
	this.freeze();

	for(var rid in obj) {
		this.setRowData(rid, obj[rid]);
	}

	this.freeze(prevFrozen);
};
/** Set data in batch from 2 dimensional array. This is faster than repeatedly calling {@link tr.DataTable#setRowData}
* @public
* @param {Array.&lt;Array.&lt;*&gt;&gt;} ary Row based array
* @param {Array.&lt;string&gt;=} opt_cidList
* @param {Array.&lt;string&gt;=} opt_ridList
* @see {@link tr.DataTable#addRows}
* @see {@link tr.DataTable#setDataFromObjectMap}
* @example
* var data = [
*   ["a", 1, 2],
*   ["b", 3, 4],
*   ["c", 5, 6]
* ];
* var dt = new DataTable();
* dt.setDataFrom2DArray(data, ["column 1", "column 2", "column 3"]);
* dt.log(); // See console for the results
*/
tr.DataTable.prototype.setDataFrom2DArray = function(ary, opt_cidList, opt_ridList) {
	var rLen = (ary) ? ary.length : 0;
	if(rLen &lt; 0) { return; }

	var prevFrozen = this._frozen;
	this.freeze();

	var c = 0;
	var rids = this._generateRids(rLen, opt_ridList);

	for(var r = 0; r &lt; rLen; ++r) {
		var row = ary[r];
		var rid = rids[r];
		if(opt_cidList) {
			for(c = row.length; --c &gt;= 0;) {
				this._setData(rid, opt_cidList[c], row[c]);
			}
		} else {
			for(c = row.length; --c &gt;= 0;) {
				this._setData(rid, "" + c, row[c]); // Auto-generate column id
			}
		}
	}

	this.freeze(prevFrozen);
};

/** Set data to individual cell by specified row index instead of row Id
* @public
* @param {number} rowIndex Invalid row index will not produce any effect
* @param {string} cid
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype.setDataAt = function(rowIndex, cid, value) { // Data changed event may be dispatched
	var rid = this.getRowId(rowIndex);
	return (rid) ? this.setData(rid, cid, value) : false;
};
/** @public
* @param {number} rowIndex Invalid row index will not produce any effect
* @param {Object.&lt;string, *&gt;=} values Object where the key is column Id and value is the data to be set
* @param {Object=} opt_eventArg
* @return {boolean} Return true if there is any change, and false otherwise
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype.setRowDataAt = function(rowIndex, values, opt_eventArg) { // Data changed event may be dispatched
	var rid = this.getRowId(rowIndex);
	return (rid) ? this.setRowData(rid, values, opt_eventArg) : false;
};
/** Add new row of data to the end of the Data Table
* @public
* @param {Object.&lt;string, *&gt;=} values field-value pair object
* @param {string|null=} rid If the given row Id already exists, data is updated and no new row is added. Leave blank or null to let DataTable generate unique row Id
* @return {string} Return Row id that has been inserted or changed
* @fires tr.DataTable#dataChanged
* @example
* var dt = new DataTable();
* dt.addRow({"column 1": "a", "column 2": 1, "column 3": null});
* dt.addRow({"column 1": "b", "column 2": 5, "column 3": {"someKey": 10}});
* dt.log(); // See console for the results
*/
tr.DataTable.prototype.addRow = function(values, rid) {
	if(!values) { values = {}; }
	rid = this._generateUniqueRid(values, rid);
	
	this.setRowData(rid, values);
	return rid;
};
/** Add multiple rows all at once. This is used to improve the performance. dataChagned with globalChange flag will be fired, if multiple rows are added.
* @public
* @param {Array.&lt;Object&gt;} rows Array of field-value pair object.
* @param {Array.&lt;string&gt;=} rids If the given row Id already exists, data is updated and no new row is added. Leave blank or null to let DataTable generate unique row Id
* @fires tr.DataTable#dataChanged
* @see {@link tr.DataTable#setDataFrom2DArray}
* @see {@link tr.DataTable#setDataFromObjectMap}
* @example
* var dt = new DataTable();
* dt.addRows([
*   {"field1": "a", "field2": 1, "field3": null},
*   {"field1": "b", "field2": 5, "field3": {"someKey": 10}},
*   {"field1": "c", "field2": 7, "field3": [1, 2, 3]},
*   {"field1": "c", "field4": "some value"} // Rows don't need to be in uniform structure
* ]); // 4 rows are added
* dt.log(); // See console for the results
*/
tr.DataTable.prototype.addRows = function(rows, rids) {
	if(!Array.isArray(rows)) {
		return;
	}
	var len = rows.length;
	if(!len) {
		return;
	} else if(len === 1) {
		this.addRow(rows[0], rids ? rids[0] : null);
		return;
	}
	if(!rids) {
		rids = [];
	}
	var prevFrozen = this._frozen;
	this.freeze();
	for(var i = 0; i &lt; len; ++i) {
		this.addRow(rows[i], rids[i]);
	}
	this.freeze(prevFrozen);
};

/** Insert a new row as the first row
* @public
* @param {Object.&lt;string, *&gt;=} opt_values
* @param {string|null=} opt_rid If the given row Id already exists, data is updated and no new row is added. Leave blank or null to let DataTable generate unique row Id
* @return {string} Return Row id that has been inserted or changed
* @fires tr.DataTable#dataChanged
* @see {@link tr.DataTable#insertRow}
*/
tr.DataTable.prototype.unshiftRow = function(opt_values, opt_rid) {
	return this.insertRow(0, opt_values, opt_rid);
};
/** @public
* @param {string|number|null=} rowRef
* @param {Object.&lt;string, *&gt;=} values Key/value pair object map
* @param {string|null=} rid If the given row Id already exists, data is updated and no new row is added. Leave blank or null to let DataTable generate unique row Id
* @return {string} Return Row id that has been inserted or changed
* @fires tr.DataTable#dataChanged
* @see {@link tr.DataTable#unshiftRow}
* @see {@link tr.DataTable#removeRow}
*/
tr.DataTable.prototype.insertRow = function(rowRef, values, rid) {
	var arg = {};
	if(typeof rowRef === "number") {
		arg["nextRid"] = this._rids[rowRef];
		arg["fallback"] = rowRef; // Fallback index in case of no nextRid found
	} else {
		arg["nextRid"] = /** @type{string} */(rowRef);
	}
	
	if(!values) { values = {}; }
	rid = this._generateUniqueRid(values, rid);
	
	this.setRowData(rid, values, arg);
	return rid;
};
/** @public
 * @param {string|number} rowRef
 * @param {Object=} opt_values
 * @param {string=} opt_rid
 * @return {string}
 * @fires tr.DataTable#dataChanged
 */
tr.DataTable.prototype.insertAfter = function(rowRef, opt_values, opt_rid) {
	var rowIndex = (typeof rowRef === "string") ? this.getRowIndex(rowRef) : /** @type{number}*/ (rowRef);
	
	if(!(rowIndex &gt;= 0) || rowIndex &gt;= this._rids.length - 1) {
		return this.addRow(opt_values, opt_rid);
	}
	return this.insertRow(rowIndex + 1, opt_values, opt_rid);
};

/** @public
* @param {number|string} rowRef Reference to the row to be removed
* @see {@link tr.DataTable#removeRows}
*/
tr.DataTable.prototype.removeRow = function(rowRef) { // Data changed event may be dispatched
	if(typeof rowRef === "number") {
		this.setRowData(this.getRowId(rowRef), null);
	} else {
		this.setRowData(/** @type{string} */(rowRef), null);
	}
};
/** @public
* @param {Array.&lt;number|string&gt;} refs Reference to the rows to be removed
* @see {@link tr.DataTable#removeAllRows}
*/
tr.DataTable.prototype.removeRows = function(refs) {
	if(refs.length === 1) {
		var rid = refs[0];
		if (typeof rid === "number") {
			this.removeRow(rid);
		} else {
			this.setRowData(rid, null);
		}
		return;
	}

	var i;
	var dirty = false;
	this._removedRows = {};
	for (i = refs.length; --i &gt;= 0;) {
		rid = refs[i];
		if (typeof rid === "number") {
			rid = this.getRowId(rid);
		}

		var row = this.getRowData(rid);
		if(row) {
			this._prevData[rid] = this._rows[rid];
			this._removedRows[rid] = 1;
			delete this._rows[rid];
			dirty = true;
		}
	}
	if(dirty) {
		this._rids = this._rids.filter(this._removeRows);
		this._removedRows = null;
		this.dispatchGlobalChange();
	} else {
		this._removedRows = null;
	}
};

/** @private
* @param {string} rid
* @return {boolean}
*/
tr.DataTable.prototype._removeRows = function(rid) {
	return !this._removedRows[rid];
};
/** Remove all existing rows
* @override
*/
tr.DataTable.prototype.clearAllData = function(suppressEvent) {
	tr.DataTable.base(this, "clearAllData", true);
	this._prevData = {};

	if(this._rids.length) {
		this._rids.length = 0;

		this.dispatchGlobalChange(suppressEvent);
	}
};
/** Alias to {@link tr.DataTable#clearAllData}
* @public
* @function
* @param {boolean=} suppressEvent
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype.removeAllRows = tr.DataTable.prototype.clearAllData;
/** @private
* @function
* @param {number} a
* @param {number} b
* @return {number}
*/
tr.DataTable._ascendingOrder = function(a, b) { return a - b; };
/** @public
* @param {Array.&lt;number&gt;|number} fromIndex
* @param {number} toIndex
* @param {boolean=} suppressEvent
* @return {Array.&lt;string&gt;|string} Return row id(s). Return null if nothing has changed
*/
tr.DataTable.prototype.moveRow = function(fromIndex, toIndex, suppressEvent) {
	var output = null;
	var rid = "";
	if(!(toIndex &gt;= 0 &amp;&amp; toIndex &lt; this._rids.length)) {
		toIndex = this._rids.length;
	}

	if (Array.isArray(fromIndex)) {
		var fromIndices = fromIndex;
		fromIndices.sort(tr.DataTable._ascendingOrder);
		var movedRids = [];
		for (var i = fromIndices.length; --i &gt;= 0;) {
			var idx = fromIndices[i];
			rid = this._rids[idx];
			if(rid) {
				movedRids.unshift(rid);
				this._rids.splice(idx, 1); // WARNING: splice method is slow
				if (idx &lt; toIndex) {
					--toIndex;
				}
			}
		}
		if(movedRids.length) {
			this._rids.splice.apply(this._rids, [toIndex, 0].concat(movedRids));
			output = movedRids;
		}
	} else {
		if (fromIndex &lt; 0) {
			fromIndex = 0;
		}

		if(fromIndex !== toIndex &amp;&amp; (fromIndex + 1) !== toIndex) {
			rid = this._rids.splice(fromIndex, 1)[0];
			if (rid) {
				if (fromIndex &lt; toIndex) {
					--toIndex;
				}
				this._rids.splice(toIndex, 0, rid);
				output = rid;
			}
		}
	}

	if(output) {
		if(this._segments) {
			this._sort(null); // Reorder segment members
		}
		this._dispatchPositionChange(suppressEvent);
	}
	return output;
};
/** @public
* @ignore
* @param {Array.&lt;string&gt;} fromRids
* @param {string} toRid If rid is empty string, insert the rid to the last index
* @param {boolean=} suppressEvent
* @return {Array.&lt;string&gt;|string} rid
*/
tr.DataTable.prototype._moveRow = function(fromRids, toRid, suppressEvent) {
	var len = fromRids.length;
	if(!len) { 
		return null;
	}

	var fromIndices = new Array(len);
	for(var i = 0; i &lt; len; ++i) {
		fromIndices[i] = this.getRowIndex(fromRids[i]);
	}

	var toIndex = (toRid) ? this.getRowIndex(toRid) : this._rids.length;
	if(len &gt; 1) {
		return this.moveRow(fromIndices, toIndex, suppressEvent);
	}
	return this.moveRow(fromIndices[0], toIndex, suppressEvent);
};

/** Move rows in chunk by specifying chunk size in the third parameter. 
* @public
* @param {number|string} startIndex
* @param {number|string} toIndex
* @param {number=} opt_count
* @param {boolean=} suppressEvent
* @return {Array.&lt;string&gt;} rids Return null if nothing has changed
* @see {@link tr.DataTable#moveRow}
*/
tr.DataTable.prototype.moveRows = function(startIndex, toIndex, opt_count, suppressEvent) {
	if(typeof startIndex === "string") {
		startIndex = this.getRowIndex(startIndex);
	}
	if(typeof toIndex === "string") {
		toIndex = this.getRowIndex(toIndex);
	}
	if(startIndex &lt; 0) { startIndex = 0; }
	if(toIndex &lt; 0) { toIndex = this._rids.length; }
	if(!opt_count) { opt_count = 1; }

	var endIndex = startIndex + opt_count - 1;
	var targetIndex = toIndex;
	if (toIndex &gt;= startIndex) {
		if (toIndex &lt;= endIndex) {
			targetIndex = startIndex;
		} else {
			targetIndex = toIndex - opt_count;
		}
	}

	if ((opt_count &gt; 0) &amp;&amp; (endIndex &lt;= this._rids.length)) {
		if (targetIndex &gt; this._rids.length) {
			targetIndex = this._rids.length;
		}

		var rows = this._rids.splice(startIndex, opt_count);
		var args = [targetIndex, 0].concat(rows);
		Array.prototype.splice.apply(this._rids, args);

		if(this._segments) {
			this._sort(null); // Reorder segment members
		}
		this._dispatchPositionChange(suppressEvent);
		return rows;
	}
	
	return null;
};

/** This method is deprecated in favor of more sophisticate {@link tr.DataTable#moveRow}
* @public
* @param {number} fromIndex
* @param {number} toIndex
*/
tr.DataTable.prototype.swapRow = function(fromIndex, toIndex) { // No event is fired. No effect on other views
	var len = this._rids.length;
	if(fromIndex &lt; 0 || fromIndex &gt;= len) { return; }
	if(toIndex &lt; 0 || toIndex &gt;= len) { return; }

	var rid = this._rids[fromIndex];
	this._rids[fromIndex] = this._rids[toIndex];
	this._rids[toIndex] = rid;
};

/** @public
* @function
* @param {string} rid
*/
tr.DataTable.prototype.clearRowData = tr.DataTable.prototype.removeRow;
/** {@link tr.DataCache#clearColumnData}
* @override
*/
tr.DataTable.prototype.clearColumnData = function(colId, suppressEvent) {
	var cids = (typeof colId === "string") ? [/** @type {string} */(colId)] : /** @type {Array.&lt;string&gt;} */(colId);
	for(var i = cids.length; --i &gt;= 0;) {
		var cid = cids[i];
		if(cid) {
			for(var rid in this._rows) {
				delete this._rows[rid][cid];
				delete this._prevData[rid][cid];
			}
		}
	}

	this.dispatchGlobalChange(suppressEvent);
};

/** Get parent data source. Note that DataTable cannot be child of other data source. So the returned value will always be null.
* @public
* @return {null}
*/
tr.DataTable.prototype.getDataSource = function() {
	return null; // No other source
};
/** @public
* @param {*} source
*/
tr.DataTable.prototype.setDataSource = function(source) {};

/**
* @public
* @ignore
* @return {Object.&lt;string, tr.DataTable.SortLogic&gt;}
*/
tr.DataTable.prototype.getSortingLogics = function() {
	return this._compMap;
};
/** @public
* @param {string|Array.&lt;string&gt;} cid Column id
* @param {string|number|Array.&lt;string|number&gt;=} sortOrders "a"|"d"|"n"
* @param {tr.DataTable.SortLogic=} customComparer
* @param {*=} contextObj Context object that will be provided as the forth parameter of the given comparer method
* @return {boolean} Return true if there is any change, otherwise false
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype.sortOnce = function(cid, sortOrders, customComparer, contextObj) {
	var sortingDefs = tr.DataTable._buildSortContext(
		[], 
		cid, 
		sortOrders,
		customComparer || this._compMap,
		contextObj // User context
	);

	if(this._sort(sortingDefs)) {
		this._dispatchPositionChange();
		return true;
	}
	return false;
};
/** @public
* @param {tr.DataTable.SortLogic} func
* @example
* customLogic = function(a, b, sortOrder) {
*   return (a - b) * sortOrder; // for numeric comparison
* };
* var dt = new DataTable();
* dt.setSortingLogic(customLogic);
* dt.sortOnce("Column id", "ascending");
*/
tr.DataTable.prototype.setSortingLogic = function(func) {
	this._compMap["_default"] = func;
};
/** Specified sorting logic for the column with the given column id. This will override logic set by {@link tr.DataTable#setSortingLogic}, when the column is sorted
* @public
* @param {string} cid
* @param {tr.DataTable.SortLogic} func Use null to remove current sorting logic
*/
tr.DataTable.prototype.setColumnSortingLogic = function(cid, func) {
	this._compMap[cid] = func;
};

/** Freeze data table so that no event is fired for data processing until executing {@link tr.DataTable#unfreeze} method
* @public
* @param {boolean=} bool
* @return {boolean} Previous freeze state before the execution
* @fires tr.DataTable#dataChanged
* @example
* var prevState = dt.freeze();
* for(var i = 0; i &lt; 100; ++i) {
*   dt.insertRow({}); // no event is fired
* }
* dt.freeze(prevState); // Restore previous freeze states
*/
tr.DataTable.prototype.freeze = function(bool) {
	bool = bool !== false;
	var prevState = this._frozen;
	if(prevState !== bool) {
		this._frozen = bool;
		this._autoFillSegments();
		this.dispatchGlobalChange();
	}
	return prevState;
};
/** @public
* @param {boolean=} bool
* @return {boolean} Previous freeze state before the execution
*/
tr.DataTable.prototype.unfreeze = function(bool) {
	return this.freeze(bool === false);
};
/** @public
* @return {boolean} Current freeze state
*/
tr.DataTable.prototype.isFrozen = function() {
	return this._frozen;
};


/** 
* @public
* @param {string} rid
* @param {boolean=} enabled
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.setSegmentSeparator = function(rid, enabled) {
	var change = false;
	if(typeof rid === "string") {
		if(enabled !== false) {
			if(!this._segments) {
				this._segments = new SegmentCollection();
			}
			if(this._segments.addSegment(rid)) {
				change = true;
			}
		} else if(this._segments) {
			if(this._segments.removeSegment(rid)) {
				change = true;
				if(!this._segments.getSegmentCount()) {
					this._segments = null;
				}
			}
		}
	}
	if(change &amp;&amp; this._needFiring()) {
		if(this._autoFillSegments()) {
			this.dispatchGlobalChange();
		} else {
			var rowData = this._rows[rid] || null;
			if(rowData) {
				this._dispatchDataChange({
					"rid": rid,
					"changes": {},
					"rowData": rowData,
					"type": "updated",
					"segmentChanged": true
				});
			}
		}
	}
	
	return change;
};
/** @public
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.unsetAllSegmentSeparators = function() {
	if(this._segments) {
		this._segments = null;
		this.dispatchGlobalChange();
		return true;
	}
	return false;
};
/** 
* @public
* @return {boolean}
*/
tr.DataTable.prototype.hasSegmentation = function() {
	return this._segments ? true : false;
};
/** 
* @public
* @param {string} rid
* @return {boolean}
*/
tr.DataTable.prototype.isSegmentSeparator = function(rid) {
	if(this._segments) {
		return this._segments.containsSegment(rid);
	}
	return false;
};
/**
* @public
* @param {string} rid
* @return {string} parent row id of this segmentation. If the parent row id for this segmentation cannot be found, return ""
*/
tr.DataTable.prototype.getSegmentParentRowId = function(rid) {
	if(this._segments) {
		return this._segments.getParentRowId(rid);
	}
	return "";
};
/** 
* @public
* @param {Array.&lt;string&gt;=} rids If no row id is given, row ids of this data table is used instead
* @return {Array.&lt;number&gt;} Return null if there is no segmentation
*/
tr.DataTable.prototype.getSegmentValues = function(rids) {
	if(this._segments) {
		return this._segments.getSegmentValues(rids || this._rids);
	}
	return null;
};
/** 
* @private
* @param {number} at Row index
* @return {boolean} Return true if the given row is in the last segment
*/
tr.DataTable.prototype._isLastSegment = function(at) {
	var segmentSeparators = this._segments;
	if(segmentSeparators) {
		var rids = this._rids;
		var rowCount = rids.length;
		for(var r = at + 1; r &lt; rowCount; ++r) {
			if(segmentSeparators.containsSegment(rids[r])) {
				return false;
			}
		}
	}
	return true;
};
/** 
* @public
* @ignore
* @return {tr.SegmentCollection} Return null if there is no segmentation
*/
tr.DataTable.prototype._getSegmentSeparators = function() {
	return this._segments;
};
/** @public
* @param {boolean=} enabled
* @ignore
*/
tr.DataTable.prototype.enableAutoSegmentFilling = function(enabled) {
	this._autoSegmentFilling = enabled != false;
	this._autoFillSegments();
};
/** @private
* @return {boolean} Return true if the fill segments have changed, otherwise return false
*/
tr.DataTable.prototype._autoFillSegments = function() {
	if(this._autoSegmentFilling) {
		return this.fillSegments();
	}
	return false;
};
/** Remove existing segment children and fill the segments with all contnet rows before the next segment separator
* @public
* @param {string} segmentId Row id
*/
tr.DataTable.prototype.fillSegment = function(segmentId) {
	if(this._segments) {
		this._segments.fillSegment(segmentId, this._rids);
	}
};
/** Remove all existing segment children in each segment and fill the segments with all contnet rows before the next segment separator
* @public
* @return {boolean} Return true if the fill segments have changed, otherwise return false
*/
tr.DataTable.prototype.fillSegments = function() {
	if(this._segments) {
		return this._segments.fillSegments(this._rids);
	}
	return false;
};
/** @public
* @param {string} segmentId Row id
* @param {string} rid Row id
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.addSegmentChild = function(segmentId, rid) {
	if(this._segments) {
		var dirty = this._segments.addSegmentChild(segmentId, rid);
		if(dirty) {
			if(this._sort(null)) {
				this._dispatchPositionChange();
			}
			return true;
		}
	}
	return false;
};
/** @public
* @param {string} segmentId Row id
* @param {Array.&lt;string&gt;} rids Row id
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.addSegmentChildren = function(segmentId, rids) {
	if(this._segments) {
		var dirty = this._segments.addSegmentChildren(segmentId, rids);
		if(dirty) {
			if(this._sort(null)) {
				this._dispatchPositionChange();
			}
			return true;
		}
	}
	return false;
};
/** @public
* @param {string} segmentId Row id
* @param {string} rid Row id
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.removeSegmentChild = function(segmentId, rid) {
	if(this._segments) {
		return this._segments.removeSegmentChild(segmentId, rid);
	}
	return false;
};
/** @public
* @param {string} segmentId Row id
* @param {Array.&lt;string&gt;} rids Row id
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.removeSegmentChildren = function(segmentId, rids) {
	if(this._segments) {
		return this._segments.removeSegmentChildren(segmentId, rids);
	}
	return false;
};
/** @public
* @return {boolean} Return true if there is any change
*/
tr.DataTable.prototype.removeAllSegmentChildren = function() {
	if(this._segments) {
		return this._segments.removeAllSegmentChildren();
	}
	return false;
};
/** Get row ids of all segment separator
* @public
* @return {Array.&lt;string&gt;} Return null if there is no segment separator
*/
tr.DataTable.prototype.getSegmentIds = function() {
	if(this._segments) {
		return this._segments.getSegmentIds();
	}
	return null;
};
/** Get row ids of all children from the specified segment
* @public
* @param {string} segmentId
* @return {Array.&lt;string&gt;} Returns array of row ids. Returns null if there is no child or no segment separator found
*/
tr.DataTable.prototype.getSegmentChildIds = function(segmentId) {
	if(this._segments) {
		var segment = this._segments.getSegment(segmentId);
		if(segment) {
			var chdr = segment.getChildIds();
			return chdr.length ? chdr : null;
		}
	}
	return null;
};
/** Sort all of existing segments by given compare function
* @public
* @param {Function} compare 
*/
tr.DataTable.prototype.sortSegments = function (compare) {
	if(!this._segments || typeof compare !== "function") {
		return;
	}
	var rids = this._rids;
	var segments = this._segments;
	var segmentCount = segments.getSegmentCount();
	var segmentList = [];
	var origOrder = [];
	var itemCount = 0;
	var rowCount = rids.length;
	var rid = "";
	var segment = null;
	var i;
	for(i = 0; i &lt; rowCount; ++i) {
		rid = rids[i];
		segment = segments.getSegment(rid);
		if(segment) {
			origOrder.push(i);
			segmentList.push(segment);
			if(++itemCount &gt;= segmentCount) {
				break;
			}
		}
	}
	
	this._userSegmentComparer = compare;
	segmentList.sort(this._bySegmentSeparator);
	this._userSegmentComparer = null;
	
	var dirty = false;
	for(i = 0; i &lt; itemCount; ++i) {
		var idx = origOrder[i];
		rid = rids[idx];
		segment = segmentList[i];
		var newRid = segment.getId();
		if(rid !== newRid) {
			rids[idx] = newRid;
			dirty = true;
		}
	}
	
	if(dirty) {
		this._sort(null);
		this._dispatchPositionChange();
	}
};
/** Sort all of existing segments by given compare function
* @private
* @param {tr.Segment} segmentA 
* @param {tr.Segment} segmentB
* @return {number} 
*/
tr.DataTable.prototype._bySegmentSeparator = function (segmentA, segmentB) {
	return /** @type{number} */(this._userSegmentComparer(
		this.getRowData(segmentA.getId()), 
		this.getRowData(segmentB.getId())
	));
};


/** 
* @public
* @ignore
* @param {Array.&lt;Array&gt;} sortingDefs
* @return {boolean} Return true if there is any change, otherwise false
*/
tr.DataTable.prototype._sort = function(sortingDefs) {
	var rids = this._rids;
	var dataRows = this.getMultipleRowData(rids);
	var segmentValues = this.getSegmentValues(rids);
	var change = tr.DataTable._performMultiLevelSorting(dataRows, sortingDefs, segmentValues);

	if(change) {
		this._rids = tr.DataTable._reorderItems(rids, change);
		return true;
	}
	return false;
};

/** Simulate data changed event by firing global change event argument to all listeners&lt;br&gt;
* Normally this will force data view to do sorting, filtering, and grouping again
* @public
* @param {boolean=} suppressEvent
* @fires tr.DataTable#dataComposed
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype.dispatchGlobalChange = function(suppressEvent) {
	if(!suppressEvent &amp;&amp; this._needFiring()) {
		this._dispatchDataChange(tr.DataTable._globalChangeArg);
	}
};
/** Position change will not cause dataComposed to be fired
* @private
* @param {boolean=} suppressEvent
* @fires tr.DataTable#dataChanged
*/
tr.DataTable.prototype._dispatchPositionChange = function(suppressEvent) {
	if(!suppressEvent &amp;&amp; this._needFiring()) {
		this._dispatch("dataChanged", tr.DataTable._positionChangeArg);
	}
};

/** {@link tr.DataCache#dump} Construct a JSON object that is compatible with console.table()
* @override
* @param {Object=} opt_options {@link tr.DataCache#dump}
* @return {!Array.&lt;Object&gt;} Return a JSON object that is compatible with console.table()
* @see {@link tr.DataCache#dump}
*/
tr.DataTable.prototype.dump = function(opt_options) {
	return tr.DataCache.constructTable(this.getMultipleRowData(this._rids), opt_options, this._rids);
};


/** @private
* @param {string} rid
* @param {string} cid
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
*/
tr.DataTable.prototype._setData = function(rid, cid, value) {
	var row = this.getRowData(rid);

	if(!row) {
		row = {};
		this._rows[rid] = row;
		this._prevData[rid] = {};
		this._rids.push(rid);
	}
	this._prevData[rid][cid] = row[cid];
	row[cid] = value;
	return true;
};
/** @private
*/
tr.DataTable.prototype._generateRids = function(len, opt_ridList) {
	var r = 0, rids;
	if(opt_ridList) {
		rids = opt_ridList;
	} else {
		rids = [];
		var rowCount = this._rids.length;
		while(r &lt; rowCount &amp;&amp; r &lt; len) {
			rids.push(this._rids[r++]);
		}
	}
	r = rids.length;
	while(r &lt; len) {
		rids.push("" + r++); // Auto-generate row id
	}
	return rids;
};
/** @private
* @param {Object} values
* @param {string|null=} rid
* @return {string}
*/
tr.DataTable.prototype._generateUniqueRid = function(values, rid) {
	if(!rid) {
		if(values["ROW_ID"]) {
			return values["ROW_ID"];
		}
		rid = "_" + this._runningId++;
		while(this._rows[rid]) {
			rid = "_" + this._runningId++;
		}
	}
	return rid;
};

/** @private
* @return {boolean}
*/
tr.DataTable.prototype._needFiring = function() {
	return !this._frozen &amp;&amp; !this._composing;
};

/** Deprecated
* @deprecated
* @public
* @function
*/
tr.DataTable.getSortingDefinitions = tr._deprecatedFunction;
/** @public
* @const
* @ignore
* @type {!Object}
*/
tr.DataTable._globalChangeArg = {"globalChange": true};
/** @public
* @const
* @ignore
* @type {!Object}
*/
tr.DataTable._positionChangeArg = {"globalChange": true, "positionChangeOnly": true};


/**
* @function
* @public
* @ignore
* @param {Array.&lt;Array&gt;} out_defs Output object. Array is used to optimize property accessing time.
* @param {string|Array.&lt;string&gt;} cids
* @param {string|number|Array.&lt;string|number&gt;=} sortOrders
* @param {Function|Array.&lt;Function&gt;|Object.&lt;string, tr.DataTable.SortLogic&gt;=} logics
* @param {*=} contextObj Context object that will be provided as the forth parameter of the given comparer method
* @return {!Array.&lt;Array&gt;}
*/
tr.DataTable._buildSortContext = function(out_defs, cids, sortOrders, logics, contextObj) {
	var aryColumnIds, aryOrders;
	if(Array.isArray(cids)) {
		aryColumnIds = /** @type{Array.&lt;string&gt;} */(cids);
		aryOrders = /** @type{Array.&lt;string|number&gt;} */(sortOrders);
	} else {
		aryColumnIds = [/** @type{string} */(cids)];
		aryOrders = (cids) ? [/** @type{string|number} */(sortOrders)] : [0];
	}

	var logic = null;
	var logicMap = null;
	if(typeof logics == "function") {
		logic = logics;
	} else {
		logicMap = /** @type{Array.&lt;Function&gt;|Object.&lt;string, tr.DataTable.SortLogic&gt;} */(logics);
	}
	var len = aryColumnIds.length;
	out_defs.length = len;
	for(var c = len; --c &gt;= 0;) {
		if (Array.isArray(logicMap)) {
			logic = logicMap[c];
		}
		var sortingDef = out_defs[c];
		if(!sortingDef) {
			sortingDef = out_defs[c] = new Array(5);
		}
		var columnId = aryColumnIds[c];
		sortingDef[0] = columnId; // text field
		sortingDef[1] = null; // Reserved for row data
		sortingDef[2] = logic || logicMap[columnId] || logicMap["_default"]; // sort logic
		if(!sortingDef[2]) {
			sortingDef[2] = tr.DataTable._defaultComparer;
		}
		sortingDef[3] = tr.DataTable._getSortOrder(aryOrders[c]); // sort order
		sortingDef[4] = contextObj;
	}
	return out_defs;
}; 
/** Performance is extremely vital in this method
* @public
* @ignore
* @function
* @param {number} a
* @param {number} b
* @param {number} order Not used by in this method
* @param {Array.&lt;Array&gt;} sortingDefs
* @return {number}
*/
tr.DataTable._multiColumnCompareLogic = function(a, b, order, sortingDefs) {
	var count = sortingDefs.length;
	var result = 0;
	for(var c = 0; c &lt; count; ++c) {
		var sortingDef = sortingDefs[c];
		result = tr.DataTable._singleColumnCompareLogic(a, b, sortingDef[3], sortingDef);
		if(result) {
			return result;
		}
	}
	return result;
};
/** Performance is extremely vital in this method
* @public
* @ignore
* @function
* @param {number} a
* @param {number} b
* @param {number} order
* @param {Array} sortingDef
* @return {number}
*/
tr.DataTable._singleColumnCompareLogic = function(a, b, order, sortingDef) {
	var values = /** @type{Array} */(sortingDef[1]);
	return /** @type{number} */(sortingDef[2](
		values[a], // Value1
		values[b], // Value2
		order, // Sort order (3)
		sortingDef[4] // Context object
	));
};
/** @public
* @function
* @ignore
* @param {!Array.&lt;Object&gt;} dataRows
* @param {Array.&lt;Array&gt;} sortingDefs
* @param {Array.&lt;number&gt;=} segmentValues
* @return {Array.&lt;number&gt;} Returns new item positions if there is any change, otherwise returns null
*/
tr.DataTable._performMultiLevelSorting = function(dataRows, sortingDefs, segmentValues) {
	var rowCount = dataRows ? dataRows.length : 0;
	var defCount = sortingDefs ? sortingDefs.length : 0;
	if(!rowCount) {
		return null;
	}

	// Populate data for each definition
	for(var c = 0; c &lt; defCount; ++c) {
		var sortingDef = sortingDefs[c];
		var columnId = sortingDef[0];
		var rows = sortingDef[1];
		if(rows) {
			rows.length = rowCount;
		} else {
			rows = sortingDef[1] = new Array(rowCount);
		}
		for(var r = 0; r &lt; rowCount; ++r) {
			rows[r] = dataRows[r][columnId];
		}
	}
	
	if(segmentValues) {
		var segmentDef = [ // TODO: Make this static variable
			"ROW_SEGMENT", // Dummy column id
			segmentValues, // Segment values
			tr.DataTable._segmentComparer,
			1, // Ascending order
			null // Context object
		];
		if(sortingDefs) {
			sortingDefs = sortingDefs.slice();
			sortingDefs.unshift(segmentDef);
		} else {
			sortingDefs = [segmentDef];
		}
		++defCount;
	}
	
	if(!defCount) {
		return null;
	}
	
	var sortOrder = 0;
	var sortLogic, sortContext;
	if(defCount &gt; 1) {
		sortLogic = tr.DataTable._multiColumnCompareLogic;
		sortContext = sortingDefs;
		sortOrder = 1; // sortOrder is not used by _multiColumnCompareLogic
	} else { // Single level sorting
		sortLogic = tr.DataTable._singleColumnCompareLogic;
		sortContext = sortingDefs[0];
		sortOrder = /** @type{number} */(sortContext[3]);
	}
	
	return tr.DataTable._mergeSort(rowCount, sortOrder, sortLogic, sortContext); 
};
/**
* @function
* @public
* @ignore
* @param {number} len Length of array item
* @param {number} order
* @param {tr.DataTable.SortLogic} comparer
* @param {*=} contextObj Context object that will be provided as the forth parameter of the given comparer method
* @return {Array.&lt;number&gt;} Returns new item positions if there is any change, otherwise returns null
*/
tr.DataTable._mergeSort = function(len, order, comparer, contextObj) {
	var change = false;

	var grpSize = 1;
	var iter, lhsFrom, rhsFrom, lhsTo, rhsTo;
	var subj = tr.DataTable._createIndexArray(len);
	var obj = subj.slice();

	while(grpSize &lt;= len) {
		iter = rhsTo = 0; // start from 0
		while(iter &lt; len) {
			lhsFrom = rhsTo;
			lhsTo = lhsFrom + grpSize;
			rhsFrom = lhsTo;
			rhsTo = rhsFrom + grpSize;
			if(rhsTo &gt; len) rhsTo = len;

			if(rhsFrom &lt; rhsTo) {
				while(true) { // Merge two groups together
					if(comparer(subj[lhsFrom], subj[rhsFrom], order, contextObj) &lt;= 0) {
						obj[iter++] = subj[lhsFrom];
						if(++lhsFrom &gt;= lhsTo) {
							while(rhsFrom &lt; rhsTo) {
								obj[iter++] = subj[rhsFrom];
								++rhsFrom;
							}
							break;
						}
					} else {
						change = true;
						obj[iter++] = subj[rhsFrom];
						if(++rhsFrom &gt;= rhsTo) {
							while(lhsFrom &lt; lhsTo) {
								obj[iter++] = subj[lhsFrom];
								++lhsFrom;
							}
							break;
						}
					}
				}
			} else {
				while(iter &lt; len) {
					obj[iter] = subj[iter];
					++iter;
				}
			}
		}

		var tmp = subj;
		subj = obj;
		obj = tmp;
		grpSize &lt;&lt;= 1;
	}
	return change ? subj : null;
};
/** reorderItems(["a", "b", "c", "d"], [1, 3, 0, 2]) === ["b", "d", "a", "c"]; (Move the first item to where its corresponding index is) &lt;br&gt;
* Not in-place reordering. Orders array will become the results
* @function
* @public
* @ignore
* @param {!Array} ary
* @param {Array} orders
* @return {!Array}
*/
tr.DataTable._reorderItems = function (ary, orders) {
	if(orders) {
		for(var i = ary.length; --i &gt;= 0;) {
			orders[i] = ary[orders[i]];
		}
		return orders;
	}
	return ary;
};
/** Create array of incremental series starting from 0 (e.g. [0, 1, 2, 3, ...])
* @private
* @function
* @ignore
* @param {number} len Length of the generated array
* @return {!Array.&lt;number&gt;}
*/
tr.DataTable._createIndexArray = function(len) {
	var ary = tr.DataTable._idxAryMap[len];
	if(!ary) {
		if(tr.DataTable._idxAryCount &gt; 50) { // Clear cache to avoid caching huge memory
			tr.DataTable._idxAryMap = {};
			tr.DataTable._idxAryCount = 0;
		}
		ary = tr.DataTable._idxAryMap[len] = new Array(len);
		tr.DataTable._idxAryCount++;
		
		for(var i = 0; i &lt; len; ++i) {
			ary[i] = i;
		}
	}
	return ary.slice(); // Fastest way to clone an array is to perform slice() method
};
/** @private
* @type {Object.&lt;number, Array.&lt;number&gt;&gt;}
*/
tr.DataTable._idxAryMap = {};
/** @private
* @type {number}
*/
tr.DataTable._idxAryCount = 0;

/** @private
* @function
* @param {number} a
* @param {number} b
* @return {number}
*/
tr.DataTable._segmentComparer = function(a, b) {
	if(a === b) {
		return 0;
	}
	return (a &lt; b) ? -1 : 1;
};
/** @private
* @function
* @param {*} a
* @param {*} b
* @param {number} order
* @return {number}
*/
tr.DataTable._defaultComparer = function(a, b, order) { // User data may contain invalid value such as undefined or null
	if(a == null || a !== a) {
		if(b == null || b !== b) {
			return 0;
		}
		return 1;
	}
	if(b == null || b !== b) {
		return -1;
	}

	if(a &lt; b) {
		return -order;
	}
	if(b &lt; a) {
		return order;
	}
	return 0;
};
/** @private
* @function
* @param {string|number=} sortOrder
*/
tr.DataTable._getSortOrder = function(sortOrder) {
	if(typeof sortOrder === "number") {
		return sortOrder;
	} else if(sortOrder &amp;&amp; typeof sortOrder === "string") {
		sortOrder = sortOrder.charAt(0).toLowerCase();
		if(sortOrder === "a") {
			return 1;
		} else if(sortOrder === "d") {
			return -1;
		}
	}
	return 0;
};


goog.exportSymbol("tr.DataTable", tr.DataTable);
tr.DataTable._proto = tr.DataTable.prototype;

goog.exportProperty(tr.DataTable._proto, "dispose", tr.DataTable._proto.dispose);

// goog.exportProperty(tr.DataTable._proto, "getData", tr.DataTable._proto.getData); derive
// goog.exportProperty(tr.DataTable._proto, "getRowData", tr.DataTable._proto.getRowData); derive
// goog.exportProperty(tr.DataTable._proto, "getMultipleRowData", tr.DataTable._proto.getMultipleRowData); derive
// goog.exportProperty(tr.DataTable._proto, "getAllRowData", tr.DataTable._proto.getAllRowData); derive

goog.exportProperty(tr.DataTable._proto, "getColumnData", tr.DataTable._proto.getColumnData); // override
goog.exportProperty(tr.DataTable._proto, "getRowId", tr.DataTable._proto.getRowId);
goog.exportProperty(tr.DataTable._proto, "getAllRowIds", tr.DataTable._proto.getAllRowIds); // override
goog.exportProperty(tr.DataTable._proto, "getRowIndex", tr.DataTable._proto.getRowIndex);
goog.exportProperty(tr.DataTable._proto, "getRowCount", tr.DataTable._proto.getRowCount);
goog.exportProperty(tr.DataTable._proto, "getDataAt", tr.DataTable._proto.getDataAt);
goog.exportProperty(tr.DataTable._proto, "getRowDataAt", tr.DataTable._proto.getRowDataAt);
goog.exportProperty(tr.DataTable._proto, "getPreviousData", tr.DataTable._proto.getPreviousData);

goog.exportProperty(tr.DataTable._proto, "setData", tr.DataTable._proto.setData); // override
goog.exportProperty(tr.DataTable._proto, "setRowData", tr.DataTable._proto.setRowData); // override
goog.exportProperty(tr.DataTable._proto, "setColumnData", tr.DataTable._proto.setColumnData);
goog.exportProperty(tr.DataTable._proto, "setDataFromObjectMap", tr.DataTable._proto.setDataFromObjectMap);
goog.exportProperty(tr.DataTable._proto, "setDataFrom2DArray", tr.DataTable._proto.setDataFrom2DArray);

goog.exportProperty(tr.DataTable._proto, "setDataAt", tr.DataTable._proto.setDataAt);
goog.exportProperty(tr.DataTable._proto, "setRowDataAt", tr.DataTable._proto.setRowDataAt);
goog.exportProperty(tr.DataTable._proto, "addRow", tr.DataTable._proto.addRow);
goog.exportProperty(tr.DataTable._proto, "addRows", tr.DataTable._proto.addRows);
goog.exportProperty(tr.DataTable._proto, "unshiftRow", tr.DataTable._proto.unshiftRow);
goog.exportProperty(tr.DataTable._proto, "insertRow", tr.DataTable._proto.insertRow);
goog.exportProperty(tr.DataTable._proto, "insertAfter", tr.DataTable._proto.insertAfter);
goog.exportProperty(tr.DataTable._proto, "removeRow", tr.DataTable._proto.removeRow);
goog.exportProperty(tr.DataTable._proto, "removeRows", tr.DataTable._proto.removeRows);
goog.exportProperty(tr.DataTable._proto, "removeAllRows", tr.DataTable._proto.removeAllRows);
goog.exportProperty(tr.DataTable._proto, "moveRow", tr.DataTable._proto.moveRow);
goog.exportProperty(tr.DataTable._proto, "moveRows", tr.DataTable._proto.moveRows);
goog.exportProperty(tr.DataTable._proto, "swapRow", tr.DataTable._proto.swapRow);

goog.exportProperty(tr.DataTable._proto, "clearAllData", tr.DataTable._proto.clearAllData); // override
goog.exportProperty(tr.DataTable._proto, "clearRowData", tr.DataTable._proto.clearRowData);
goog.exportProperty(tr.DataTable._proto, "clearColumnData", tr.DataTable._proto.clearColumnData); // override

goog.exportProperty(tr.DataTable._proto, "getDataSource", tr.DataTable._proto.getDataSource);
goog.exportProperty(tr.DataTable._proto, "setDataSource", tr.DataTable._proto.setDataSource);

goog.exportProperty(tr.DataTable._proto, "sortOnce", tr.DataTable._proto.sortOnce);
goog.exportProperty(tr.DataTable._proto, "setSortingLogic", tr.DataTable._proto.setSortingLogic);
goog.exportProperty(tr.DataTable._proto, "setColumnSortingLogic", tr.DataTable._proto.setColumnSortingLogic);

goog.exportProperty(tr.DataTable._proto, "freeze", tr.DataTable._proto.freeze);
goog.exportProperty(tr.DataTable._proto, "unfreeze", tr.DataTable._proto.unfreeze);
goog.exportProperty(tr.DataTable._proto, "isFrozen", tr.DataTable._proto.isFrozen);

goog.exportProperty(tr.DataTable._proto, "setSegmentSeparator", tr.DataTable._proto.setSegmentSeparator);
goog.exportProperty(tr.DataTable._proto, "unsetAllSegmentSeparators", tr.DataTable._proto.unsetAllSegmentSeparators);
goog.exportProperty(tr.DataTable._proto, "hasSegmentation", tr.DataTable._proto.hasSegmentation);
goog.exportProperty(tr.DataTable._proto, "isSegmentSeparator", tr.DataTable._proto.isSegmentSeparator);
goog.exportProperty(tr.DataTable._proto, "getSegmentParentRowId", tr.DataTable._proto.getSegmentParentRowId);

goog.exportProperty(tr.DataTable._proto, "getSegmentValues", tr.DataTable._proto.getSegmentValues);
goog.exportProperty(tr.DataTable._proto, "enableAutoSegmentFilling", tr.DataTable._proto.enableAutoSegmentFilling);
goog.exportProperty(tr.DataTable._proto, "fillSegment", tr.DataTable._proto.fillSegment);
goog.exportProperty(tr.DataTable._proto, "fillSegments", tr.DataTable._proto.fillSegments);
goog.exportProperty(tr.DataTable._proto, "addSegmentChild", tr.DataTable._proto.addSegmentChild);
goog.exportProperty(tr.DataTable._proto, "addSegmentChildren", tr.DataTable._proto.addSegmentChildren);
goog.exportProperty(tr.DataTable._proto, "removeSegmentChild", tr.DataTable._proto.removeSegmentChild);
goog.exportProperty(tr.DataTable._proto, "removeSegmentChildren", tr.DataTable._proto.removeSegmentChildren);
goog.exportProperty(tr.DataTable._proto, "removeAllSegmentChildren", tr.DataTable._proto.removeAllSegmentChildren);
goog.exportProperty(tr.DataTable._proto, "getSegmentIds", tr.DataTable._proto.getSegmentIds);
goog.exportProperty(tr.DataTable._proto, "getSegmentChildIds", tr.DataTable._proto.getSegmentChildIds);
goog.exportProperty(tr.DataTable._proto, "sortSegments", tr.DataTable._proto.sortSegments);

goog.exportProperty(tr.DataTable._proto, "dispatchGlobalChange", tr.DataTable._proto.dispatchGlobalChange);

goog.exportProperty(tr.DataTable._proto, "dump", tr.DataTable._proto.dump); // override
// goog.exportProperty(tr.DataTable._proto, "log", tr.DataTable._proto.log); derive

goog.exportProperty(tr.DataTable, "getSortingDefinitions", tr.DataTable.getSortingDefinitions);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="AdFin.html">AdFin</a></li><li><a href="DateTime.html">DateTime</a></li><li><a href="Info.html">Info</a></li><li><a href="Logic.html">Logic</a></li><li><a href="Math.html">Math</a></li><li><a href="Realtime.html">Realtime</a></li><li><a href="Statistic.html">Statistic</a></li><li><a href="Text.html">Text</a></li><li><a href="tr.ElementFrameWork.html">ElementFrameWork</a></li><li><a href="tr.PipDefinition.html">PipDefinition</a></li></ul><h3>Classes</h3><ul><li><a href="tr.ADCSubscription.html">ADCSubscription</a></li><li><a href="tr.AdFinSubscription.html">AdFinSubscription</a></li><li><a href="tr.cgrid.editor.TextBox.html">TextBox</a></li><li><a href="tr.cgrid.filter.TextBox.html">TextBox</a></li><li><a href="tr.cgrid.formatter.AsyncFormatter.html">AsyncFormatter</a></li><li><a href="tr.cgrid.formatter.CheckBox.html">CheckBox</a></li><li><a href="tr.cgrid.formatter.UpDownColor.html">UpDownColor</a></li><li><a href="tr.ColumnStats.html">ColumnStats</a></li><li><a href="tr.CompositeGrid.html">CompositeGrid</a></li><li><a href="tr.DataCache.html">DataCache</a></li><li><a href="tr.DataTable.html">DataTable</a></li><li><a href="tr.DataView.html">DataView</a></li><li><a href="tr.DropDown.html">DropDown</a></li><li><a href="tr.ElementControl.html">ElementControl</a></li><li><a href="tr.ElementWrapper.html">ElementWrapper</a></li><li><a href="tr.Event.html">Event</a></li><li><a href="tr.EventDispatcher.html">EventDispatcher</a></li><li><a href="tr.EventDispatcher.extendClass-tempCtor.html">tempCtor</a></li><li><a href="tr.EventManager.html">EventManager</a></li><li><a href="tr.FieldFormatter.html">FieldFormatter</a></li><li><a href="tr.fn.Engine.html">Engine</a></li><li><a href="tr.fn.Formula.html">Formula</a></li><li><a href="tr.fn.VariableToken.html">VariableToken</a></li><li><a href="tr.Grid.html">Grid</a></li><li><a href="tr.grid.BidOfferSpan.html">BidOfferSpan</a></li><li><a href="tr.grid.Blinker.html">Blinker</a></li><li><a href="tr.grid.Cell.html">Cell</a></li><li><a href="tr.grid.CellBlinkingPlugin.html">CellBlinkingPlugin</a></li><li><a href="tr.grid.CellEditingPlugin.html">CellEditingPlugin</a></li><li><a href="tr.grid.CellFloatingPanel.html">CellFloatingPanel</a></li><li><a href="tr.grid.CellPainter.html">CellPainter</a></li><li><a href="tr.grid.CellSpan.html">CellSpan</a></li><li><a href="tr.grid.CellSpans.html">CellSpans</a></li><li><a href="tr.grid.CellWriter.html">CellWriter</a></li><li><a href="tr.grid.CheckboxColumnPlugin.html">CheckboxColumnPlugin</a></li><li><a href="tr.grid.CollapsibleHeaderPlugin.html">CollapsibleHeaderPlugin</a></li><li><a href="tr.grid.ColumnFilterPlugin.html">ColumnFilterPlugin</a></li><li><a href="tr.grid.ColumnGroupingPlugin.html">ColumnGroupingPlugin</a></li><li><a href="tr.grid.ColumnSelectionPlugin.html">ColumnSelectionPlugin</a></li><li><a href="tr.grid.ColumnStackingPlugin.html">ColumnStackingPlugin</a></li><li><a href="tr.grid.ColumnWidthAdjustingPlugin.html">ColumnWidthAdjustingPlugin</a></li><li><a href="tr.grid.Conflator.html">Conflator</a></li><li><a href="tr.grid.DataSourceTreePlugin.html">DataSourceTreePlugin</a></li><li><a href="tr.grid.DirectContentBindingPlugin.html">DirectContentBindingPlugin</a></li><li><a href="tr.grid.DragAndDropTitlePlugin.html">DragAndDropTitlePlugin</a></li><li><a href="tr.grid.DraggableContentPlugin.html">DraggableContentPlugin</a></li><li><a href="tr.grid.FindBar.html">FindBar</a></li><li><a href="tr.grid.FindBarPlugin.html">FindBarPlugin</a></li><li><a href="tr.grid.GroupStatisticsPlugin.html">GroupStatisticsPlugin</a></li><li><a href="tr.grid.HeatMapRenderer.html">HeatMapRenderer</a></li><li><a href="tr.grid.HScrollbar.html">HScrollbar</a></li><li><a href="tr.grid.IndexMarker.html">IndexMarker</a></li><li><a href="tr.grid.MovableHeaderPlugin.html">MovableHeaderPlugin</a></li><li><a href="tr.grid.NumberFormatter.html">NumberFormatter</a></li><li><a href="tr.grid.PercentBar.html">PercentBar</a></li><li><a href="tr.grid.PercentBarRenderer.html">PercentBarRenderer</a></li><li><a href="tr.grid.Plugin.html">Plugin</a></li><li><a href="tr.grid.RangeBar.html">RangeBar</a></li><li><a href="tr.grid.ResizableTitlePlugin.html">ResizableTitlePlugin</a></li><li><a href="tr.grid.Reverter.html">Reverter</a></li><li><a href="tr.grid.RowHeightAdjustingPlugin.html">RowHeightAdjustingPlugin</a></li><li><a href="tr.grid.RowSelectionPlugin.html">RowSelectionPlugin</a></li><li><a href="tr.grid.Scrollbar.html">Scrollbar</a></li><li><a href="tr.grid.SectionSettings.html">SectionSettings</a></li><li><a href="tr.grid.SmartTooltipsPlugin.html">SmartTooltipsPlugin</a></li><li><a href="tr.grid.SortableTitlePlugin.html">SortableTitlePlugin</a></li><li><a href="tr.grid.TreeIndentingPlugin.html">TreeIndentingPlugin</a></li><li><a href="tr.grid.Virtualizer.html">Virtualizer</a></li><li><a href="tr.grid.VScrollbar.html">VScrollbar</a></li><li><a href="tr.grid.ZoomPlugin.html">ZoomPlugin</a></li><li><a href="tr.HttpRequest.html">HttpRequest</a></li><li><a href="tr.IntervalSubscription.html">IntervalSubscription</a></li><li><a href="tr.LayoutGrid.html">LayoutGrid</a></li><li><a href="tr.ListMenu.html">ListMenu</a></li><li><a href="tr.MenuItem.html">MenuItem</a></li><li><a href="tr.MockArchive.html">MockArchive</a></li><li><a href="tr.MockJET.html">MockJET</a></li><li><a href="tr.MockQuotes.html">MockQuotes</a></li><li><a href="tr.MockQuotes2.html">MockQuotes2</a></li><li><a href="tr.MockSubscription.html">MockSubscription</a></li><li><a href="tr.MockSubscriptions.html">MockSubscriptions</a></li><li><a href="tr.Popup.html">Popup</a></li><li><a href="tr.PopupMenu.html">PopupMenu</a></li><li><a href="tr.PrintTrait.html">PrintTrait</a></li><li><a href="tr.RequestQueue.html">RequestQueue</a></li><li><a href="tr.Segment.html">Segment</a></li><li><a href="tr.SegmentCollection.html">SegmentCollection</a></li><li><a href="tr.TSISubscription.html">TSISubscription</a></li></ul><h3>Interfaces</h3><ul><li><a href="tr.cgrid.ICompositeExtension.html">ICompositeExtension</a></li><li><a href="tr.grid.IPlugin.html">IPlugin</a></li><li><a href="tr.IElementControl.html">IElementControl</a></li><li><a href="tr.ILayoutGrid.html">ILayoutGrid</a></li></ul><h3>Events</h3><ul><li><a href="tr.CompositeGrid.html#event:cellClicked">cellClicked</a></li><li><a href="tr.CompositeGrid.html#event:cellDblClicked">cellDblClicked</a></li><li><a href="tr.CompositeGrid.html#event:cellMouseDown">cellMouseDown</a></li><li><a href="tr.CompositeGrid.html#event:cellRightClicked">cellRightClicked</a></li><li><a href="tr.CompositeGrid.html#event:columnSorted">columnSorted</a></li><li><a href="tr.CompositeGrid.html#event:editorAttached">editorAttached</a></li><li><a href="tr.CompositeGrid.html#event:editorDetached">editorDetached</a></li><li><a href="tr.CompositeGrid.html#event:filterAdded">filterAdded</a></li><li><a href="tr.CompositeGrid.html#event:filterCleared">filterCleared</a></li><li><a href="tr.CompositeGrid.html#event:filterModified">filterModified</a></li><li><a href="tr.CompositeGrid.html#event:filterRemoved">filterRemoved</a></li><li><a href="tr.CompositeGrid.html#event:mouseLeaveCell">mouseLeaveCell</a></li><li><a href="tr.CompositeGrid.html#event:mouseOverCell">mouseOverCell</a></li><li><a href="tr.CompositeGrid.html#event:pageChanged">pageChanged</a></li><li><a href="tr.CompositeGrid.html#event:selectionChanged">selectionChanged</a></li><li><a href="tr.DataCache.html#event:dataChanged">dataChanged</a></li><li><a href="tr.DataCache.html#event:dataComposed">dataComposed</a></li><li><a href="tr.DataTable.html#event:dataChanged">dataChanged</a></li><li><a href="tr.DataTable.html#event:dataComposed">dataComposed</a></li><li><a href="tr.DataView.html#event:beforeFiltering">beforeFiltering</a></li><li><a href="tr.DataView.html#event:beforeGroupAdded">beforeGroupAdded</a></li><li><a href="tr.DataView.html#event:dataChanged">dataChanged</a></li><li><a href="tr.DataView.html#event:groupAdded">groupAdded</a></li><li><a href="tr.DataView.html#event:groupCriteriaChanged">groupCriteriaChanged</a></li><li><a href="tr.DataView.html#event:pageCountChanged">pageCountChanged</a></li><li><a href="tr.DataView.html#event:pageIndexChanged">pageIndexChanged</a></li><li><a href="tr.DataView.html#event:preDisposed">preDisposed</a></li><li><a href="tr.Formula.html#event:dataCacheChanged">dataCacheChanged</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:cancelled">cancelled</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:change">change</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:closed">closed</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:editorOpened">editorOpened</a></li><li><a href="tr.grid.CellEditingPlugin.html#event:preEditorOpening">preEditorOpening</a></li><li><a href="tr.grid.CheckboxColumnPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.CollapsibleHeaderPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.CollapsibleHeaderPlugin.html#event:contentBindinig">contentBindinig</a></li><li><a href="tr.grid.CollapsibleHeaderPlugin.html#event:footerBinding">footerBinding</a></li><li><a href="tr.grid.CollapsibleHeaderPlugin.html#event:headerBinding">headerBinding</a></li><li><a href="tr.grid.ColumnFilterPlugin.html#event:click">click</a></li><li><a href="tr.grid.ColumnFilterPlugin.html#event:iconCreated">iconCreated</a></li><li><a href="tr.grid.ColumnGroupingPlugin.html#event:columnCollapsed">columnCollapsed</a></li><li><a href="tr.grid.ColumnGroupingPlugin.html#event:groupChanged">groupChanged</a></li><li><a href="tr.grid.ColumnGroupingPlugin.html#event:render">render</a></li><li><a href="tr.grid.ColumnStackingPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.ColumnStackingPlugin.html#event:iconCreated">iconCreated</a></li><li><a href="tr.grid.DragAndDropTitlePlugin.html#event:columnMoved">columnMoved</a></li><li><a href="tr.grid.DragAndDropTitlePlugin.html#event:dragged">dragged</a></li><li><a href="tr.grid.DraggableContentPlugin.html#event:drag">drag</a></li><li><a href="tr.grid.DraggableContentPlugin.html#event:dragEnd">dragEnd</a></li><li><a href="tr.grid.DraggableContentPlugin.html#event:dragStart">dragStart</a></li><li><a href="tr.grid.FindBarPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.MovableHeaderPlugin.html#event:dragged">dragged</a></li><li><a href="tr.grid.MovableHeaderPlugin.html#event:groupMoved">groupMoved</a></li><li><a href="tr.grid.MovableHeaderPlugin.html#event:sectionMoved">sectionMoved</a></li><li><a href="tr.grid.RowSelectionPlugin.html#event:selectionChanged">selectionChanged</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:columnSorted">columnSorted</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:preClicked">preClicked</a></li><li><a href="tr.grid.SortableTitlePlugin.html#event:preDataSorting">preDataSorting</a></li><li><a href="tr.grid.TreeIndentingPlugin.html#event:clicked">clicked</a></li><li><a href="tr.grid.TreeIndentingPlugin.html#event:contentBindinig">contentBindinig</a></li><li><a href="tr.grid.TreeIndentingPlugin.html#event:footerBinding">footerBinding</a></li><li><a href="tr.grid.TreeIndentingPlugin.html#event:headerBinding">headerBinding</a></li><li><a href="tr.Grid.html#event:columnAdded">columnAdded</a></li><li><a href="tr.Grid.html#event:columnAlignmentChanged">columnAlignmentChanged</a></li><li><a href="tr.Grid.html#event:columnRemoved">columnRemoved</a></li><li><a href="tr.Grid.html#event:columnVisibilityChanged">columnVisibilityChanged</a></li><li><a href="tr.Grid.html#event:dataSourceChanged">dataSourceChanged</a></li><li><a href="tr.Grid.html#event:postSectionDataBinding">postSectionDataBinding</a></li><li><a href="tr.Grid.html#event:rowExpansionBinding">rowExpansionBinding</a></li><li><a href="tr.Grid.html#event:rowHighlighted">rowHighlighted</a></li><li><a href="tr.Grid.html#event:sectionAdded">sectionAdded</a></li><li><a href="tr.Grid.html#event:widthChanged">widthChanged</a></li><li><a href="tr.HttpRequest.html#event:abort">abort</a></li><li><a href="tr.HttpRequest.html#event:error">error</a></li><li><a href="tr.HttpRequest.html#event:load">load</a></li><li><a href="tr.HttpRequest.html#event:loadend">loadend</a></li><li><a href="tr.HttpRequest.html#event:loadstart">loadstart</a></li><li><a href="tr.HttpRequest.html#event:timeout">timeout</a></li><li><a href="tr.IElementControl.html#event:blur">blur</a></li><li><a href="tr.IElementControl.html#event:change">change</a></li><li><a href="tr.IElementControl.html#event:click">click</a></li><li><a href="tr.IElementControl.html#event:contextmenu">contextmenu</a></li><li><a href="tr.IElementControl.html#event:dblclick">dblclick</a></li><li><a href="tr.IElementControl.html#event:drag">drag</a></li><li><a href="tr.IElementControl.html#event:dragend">dragend</a></li><li><a href="tr.IElementControl.html#event:dragenter">dragenter</a></li><li><a href="tr.IElementControl.html#event:dragleave">dragleave</a></li><li><a href="tr.IElementControl.html#event:dragover">dragover</a></li><li><a href="tr.IElementControl.html#event:dragstart">dragstart</a></li><li><a href="tr.IElementControl.html#event:drop">drop</a></li><li><a href="tr.IElementControl.html#event:focus">focus</a></li><li><a href="tr.IElementControl.html#event:formchange">formchange</a></li><li><a href="tr.IElementControl.html#event:forminput">forminput</a></li><li><a href="tr.IElementControl.html#event:input">input</a></li><li><a href="tr.IElementControl.html#event:invalid">invalid</a></li><li><a href="tr.IElementControl.html#event:keydown">keydown</a></li><li><a href="tr.IElementControl.html#event:keypress">keypress</a></li><li><a href="tr.IElementControl.html#event:keyup">keyup</a></li><li><a href="tr.IElementControl.html#event:mousedown">mousedown</a></li><li><a href="tr.IElementControl.html#event:mousemove">mousemove</a></li><li><a href="tr.IElementControl.html#event:mouseout">mouseout</a></li><li><a href="tr.IElementControl.html#event:mouseover">mouseover</a></li><li><a href="tr.IElementControl.html#event:mouseup">mouseup</a></li><li><a href="tr.IElementControl.html#event:mousewheel">mousewheel</a></li><li><a href="tr.IElementControl.html#event:reset">reset</a></li><li><a href="tr.IElementControl.html#event:scroll">scroll</a></li><li><a href="tr.IElementControl.html#event:select">select</a></li><li><a href="tr.IElementControl.html#event:submit">submit</a></li><li><a href="tr.ILayoutGrid.html#event:blur">blur</a></li><li><a href="tr.ILayoutGrid.html#event:change">change</a></li><li><a href="tr.ILayoutGrid.html#event:click">click</a></li><li><a href="tr.ILayoutGrid.html#event:contextmenu">contextmenu</a></li><li><a href="tr.ILayoutGrid.html#event:dblclick">dblclick</a></li><li><a href="tr.ILayoutGrid.html#event:drag">drag</a></li><li><a href="tr.ILayoutGrid.html#event:dragend">dragend</a></li><li><a href="tr.ILayoutGrid.html#event:dragenter">dragenter</a></li><li><a href="tr.ILayoutGrid.html#event:dragleave">dragleave</a></li><li><a href="tr.ILayoutGrid.html#event:dragover">dragover</a></li><li><a href="tr.ILayoutGrid.html#event:dragstart">dragstart</a></li><li><a href="tr.ILayoutGrid.html#event:drop">drop</a></li><li><a href="tr.ILayoutGrid.html#event:focus">focus</a></li><li><a href="tr.ILayoutGrid.html#event:formchange">formchange</a></li><li><a href="tr.ILayoutGrid.html#event:forminput">forminput</a></li><li><a href="tr.ILayoutGrid.html#event:input">input</a></li><li><a href="tr.ILayoutGrid.html#event:invalid">invalid</a></li><li><a href="tr.ILayoutGrid.html#event:keydown">keydown</a></li><li><a href="tr.ILayoutGrid.html#event:keypress">keypress</a></li><li><a href="tr.ILayoutGrid.html#event:keyup">keyup</a></li><li><a href="tr.ILayoutGrid.html#event:mousedown">mousedown</a></li><li><a href="tr.ILayoutGrid.html#event:mousemove">mousemove</a></li><li><a href="tr.ILayoutGrid.html#event:mouseout">mouseout</a></li><li><a href="tr.ILayoutGrid.html#event:mouseover">mouseover</a></li><li><a href="tr.ILayoutGrid.html#event:mouseup">mouseup</a></li><li><a href="tr.ILayoutGrid.html#event:mousewheel">mousewheel</a></li><li><a href="tr.ILayoutGrid.html#event:reset">reset</a></li><li><a href="tr.ILayoutGrid.html#event:scroll">scroll</a></li><li><a href="tr.ILayoutGrid.html#event:select">select</a></li><li><a href="tr.ILayoutGrid.html#event:submit">submit</a></li><li><a href="tr.LayoutGrid.html#event:rowCountChanged">rowCountChanged</a></li><li><a href="tr.LayoutGrid.html#event:rowHeightChanged">rowHeightChanged</a></li><li><a href="tr.LayoutGrid.html#event:rowHighlighted">rowHighlighted</a></li><li><a href="tr.Popup.html#event:hidden">hidden</a></li><li><a href="tr.Popup.html#event:shown">shown</a></li><li><a href="tr.PopupMenu.html#event:hidden">hidden</a></li><li><a href="tr.PopupMenu.html#event:shown">shown</a></li><li><a href="tr.PrintTrait.html#event:afterprint">afterprint</a></li><li><a href="tr.PrintTrait.html#event:beforeprint">beforeprint</a></li><li><a href="tr.PrintTrait.html#event:pageCounting">pageCounting</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cellRef%255Bundefined%255D">cellRef[undefined]</a></li><li><a href="global.html#e%255Bundefined%255D">e[undefined]</a></li><li><a href="global.html#.textContent">.textContent</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#input%255Bundefined%255D">input[undefined]</a></li><li><a href="global.html#q%255Bundefined%255D">q[undefined]</a></li><li><a href="global.html#sortingDef%255B1%255D">sortingDef[1]</a></li></ul>
</nav>


<script src="scripts/linenumber.js"> </script>
<script src="scripts/prettify.js"> </script>
<script> prettyPrint(); </script>
</body>
</html>
