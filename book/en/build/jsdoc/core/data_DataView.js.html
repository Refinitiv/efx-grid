<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: data/DataView.js</title>

    <script src="scripts/prettify.js"> </script>
    <script src="scripts/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/default.css">
    <link type="text/css" rel="stylesheet" href="styles/elf-template.css">
</head>

<body>

<div id="main-template" class="elf-template">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Ext from "../../../node_modules/tr-grid-util/es6/Ext.js";
import DataCache from "./DataCache.js";
import DataTable from "./DataTable.js";
import ColumnStats from "./ColumnStats.js";
import EventDispatcher from "../grid/event/EventDispatcher.js";
import Util from "../grid/util/util.js";
import { Conflator } from "../../../node_modules/tr-grid-util/es6/Conflator.js";

/** @event DataView#dataChanged
* @description Trigger when data within the data view has been changed. Not only actual change in data, but also position change will trigger this event.
* @property {boolean} globalChange Indicates a big change. User should expect all data has been change. With active sorting or filtering, this flag will always be true due to multiple changes in row position.
* @property {string} type Type of changes. Possible values are "inserted", "removed", "updated", and undefined
* @property {string} rid Row Id
* @property {Object.&lt;string, *&gt;} rowData Column values of the changed row in JSON object format
*/
/** @event DataView#pageIndexChanged
* @property {number} pageIndex
*/
/** @event DataView#pageCountChanged
* @property {number} pageCount
*/
/** @event DataView#preDisposed
*/
/** @event DataView#groupAdded
* @property {DataView} dataView Parent data view that create the new group
* @property {DataView} newGroup Child data view that is newly created
*/
/** @event DataView#beforeGroupAdded
* @description Fired each time before group added. Set property `cancel` to true to cancel adding of the new group
* @type {Object}
* @property {DataView} dataView Parent data view that create the new group
* @property {string} newGroupId
* @property {*} newGroupValue
* @property {string} newGroupRowId Unique row Id given for the group
*/
/** @event DataView#groupCriteriaChanged
* @type {Object}
*/
/** @event DataView#beforeFiltering
* @description Fired once before actual row filtering (before multiple execution of filter logic). This allow optimization by preparing data needed for the filtering
* @type {Object}
*/

/** DataView doesn't hold the actual data. It is just a transform view (by applying filtering or sorting) of the data from the {@link DataTable}
* @constructor
* @extends {EventDispatcher}
* @param {DataTable|DataView=} source
* @see {@link DataTable}
*/
var DataView = function(source) {
	var t = this; // For file minification
	t._groupFilterLogic = t._groupFilterLogic.bind(t);
	t._internalGroupSortingLogic = t._internalGroupSortingLogic.bind(t);

	t._onDataChanged = t._onDataChanged.bind(t);
	t._onGroupAdded = t._onGroupAdded.bind(t);
	t._onBeforeGroupAdded = t._onBeforeGroupAdded.bind(t);
	t._onRefreshTimeout = t._onRefreshTimeout.bind(t);

	t._rids = [];
	t._sortingDefs = [];
	t._columnStats = {};
	t._shared = {};

	t._conflator = new Conflator(this._onDataChanged, 0);
	t._conflator.disable();

	t._addEvents("dataChanged",
		"preDisposed",
		"pageIndexChanged",
		"pageCountChanged",
		"groupAdded",
		"beforeGroupAdded",
		"groupCriteriaChanged",
		"beforeFiltering"
	);

	t.setDataSource(source);
};
Ext.inherits(DataView, EventDispatcher);

/** List of row Ids with filtering and sorting transformation
* @private
* @type {!Array.&lt;string&gt;}
*/
DataView.prototype._rids; // Contains only data rows that have been filtered
/** List of row Ids with grouping transformation
* @private
* @type {Array.&lt;string&gt;}
*/
DataView.prototype._groupView = null; // Contains non-data rows (e.g. group headers, group footers) and exclude collapsed group data rows
/** List of row Ids with paging transformation
* @private
* @type {Array.&lt;string&gt;}
*/
DataView.prototype._pageView = null; // Cut-off version of _rids or _groupView
/** List of row Ids with expanding transformation
* @private
* @type {Array.&lt;string&gt;}
*/
DataView.prototype._expansionView = null; // The rids with row expansion

/** @private
* @type {Object.&lt;string, boolean&gt;}
*/
DataView.prototype._hiddenRids = null;
/** @private
* @type {Object.&lt;string, boolean&gt;}
*/
DataView.prototype._collapsedRids = null; // for segmentation
/** @private
* @type {Object.&lt;string, number&gt;}
*/
DataView.prototype._expansionMap = null;
/** @private
* @type {Object.&lt;string, string&gt;}
*/
DataView.prototype._expansionChildren = null;
/** @private
* @type {number}
*/
DataView.prototype._expansionCount = 0;

/** @private
* @type {DataTable}
*/
DataView.prototype._dt = null;
/** @private
* @type {DataTable|DataView}
*/
DataView.prototype._parent = null;
/** @private
* @type {Object}
*/
DataView.prototype._shared = null; // Shared options between data view in the same hierarchy

/** @private
* @type {Array.&lt;Array&gt;}
*/
DataView.prototype._sortingDefs = null;

/** @private
* @type {function(string, Object.&lt;string, *&gt;)|null}
*/
DataView.prototype._userFilter = null;
/** @private
* @type {boolean}
*/
DataView.prototype._filteringOut = false;

/** @private
* @type {number}
*/
DataView.prototype._refreshTimerId = 0;

/** @private
* @type {Function}
*/
DataView.prototype._groupSortingLogic = null;

/** @private
* @type {boolean}
*/
DataView.prototype._pageCorrection = true;
/** @private
* @type {number}
*/
DataView.prototype._pageSize = 0;
/** @private
* @type {number}
*/
DataView.prototype._pageIndex = 1;
/** @private
* @type {number}
*/
DataView.prototype._lastPageIndex = 0;

/** @private
* @type {Array.&lt;Function&gt;}
*/
DataView.prototype._groupCriteria = null; // Shared between groups
/** @private
* @type {Array.&lt;Array&gt;}
*/
DataView.prototype._preDefGroups = null;
/** @private
* @type {boolean}
*/
DataView.prototype._preDefGroupsDirty = false;
/** @private
* @type {Object.&lt;string, DataView&gt;}
*/
DataView.prototype._groupMembers = null; // Map of immediate child data views (key is id)
/** @private
* @type {Array.&lt;string&gt;}
*/
DataView.prototype._groupList = null; // List of immediate child's ids
/** Contains all descendant rows
* @private
* @type {DataCache}
*/
DataView.prototype._groupRows = null; // Shared between groups
/** @private
* @type {string}
*/
DataView.prototype._groupId = "";
/** @private
* @type {*}
*/
DataView.prototype._groupValue;
/** @private
* @type {string}
*/
DataView.prototype._groupRowId = "";
/** @private
* @type {Array.&lt;string&gt;}
*/
DataView.prototype._footerRowIds = null;
/** @private
* @type {number}
*/
DataView.prototype._groupLevel = 0;
/** @private
* @type {boolean}
*/
DataView.prototype._groupViewDirty = false;

/** @private
* @type {Object.&lt;string, ColumnStats&gt;}
*/
DataView.prototype._columnStats;

/** @private
* @type {boolean}
*/
DataView.prototype._hidden = false;
/** @private
* @type {boolean}
*/
DataView.prototype._hiddenHeaderRow = false;
/** @private
* @type {boolean}
*/
DataView.prototype._collapsed = false;
/** @private
* @type {boolean}
*/
DataView.prototype._showOnlyFirstMember = false;
/** @private
* @type {boolean}
*/
DataView.prototype._beingAdded = false;
/** @private
* @type {Conflator | null}
*/
DataView.prototype._conflator = null;

/** @public
* @fires DataView#preDisposed
*/
DataView.prototype.dispose = function() {
	this._dispatch("preDisposed", {});

	this.unlistenAll();
	this.setDataSource(null); // Remove this._dt and this._parent. WARNING: an event is fired
	this.groupBy(null); // Remove this._groupCriteria, this._groupRows and all of its children. WARNING: an event is fired

	this._conflator.dispose();
	this._sortingDefs = null;
	this._shared = null; // Remove shared options

	this._userFilter = this._groupSortingLogic = null;

	if(this._refreshTimerId) {
		clearTimeout(this._refreshTimerId);
		this._refreshTimerId = 0;
	}

	if(this._columnStats) {
		for(var field in this._columnStats) {
			this._columnStats[field].dispose();
		}
		this._columnStats = null;
	}
};

/** Get data by row id and column id (field)
* @public
* @param {string} rid
* @param {string} cid
* @returns {Object.&lt;string, *&gt;}
*/
DataView.prototype.getData = function(rid, cid) {
	return this._dt.getData(rid, cid);
};
/** Get entire row data by row id
* @public
* @param {string} rid
* @return {Object.&lt;string, *&gt;}
*/
DataView.prototype.getRowData = function(rid) {
	return this._dt.getRowData(rid);
};
/** @public
* @param {string} cid
* @param {boolean=} inclNonDataRow=false If enabled, group header rows are included
* @return {!Array}
*/
DataView.prototype.getColumnData = function(cid, inclNonDataRow) {
	var rids = this.getAllRowIds(true, inclNonDataRow);

	var rows = [];
	var len = rids.length;
	for(var r = 0; r &lt; len; ++r) {
		var rowData = this._dt.getRowData(rids[r]);
		if(rowData) {
			rows.push(rowData[cid]);
		} else if(inclNonDataRow) {
			rows.push(null);
		}
	}
	return rows;
};
/** @public
* @param {number} rowIndex
* @return {string}
* @see {@link DataView#getRowIndex}
*/
DataView.prototype.getRowId = function(rowIndex) {
	this._rebuildRowIdsFromChildren();

	return this._getRids()[rowIndex] || "";
};
/** @private
* @param {number|string} rowRef
* @return {string}
*/
DataView.prototype._toRowId = function(rowRef) {
	if(typeof rowRef === "number") {
		this._rebuildRowIdsFromChildren();
		return this._getRids()[rowRef] || "";
	}
	return /** @type{string} */(rowRef || "");
};
/** @private
* @param {Array.&lt;number|string&gt;} rowRefs
* @return {Array.&lt;string&gt;}
*/
DataView.prototype._toRowIds = function(rowRefs) {
	var rowCount = Array.isArray(rowRefs) ? rowRefs.length : 0;
	var ary = new Array(rowCount);
	var rids = this._getRids();
	for(var r = 0; r &lt; rowCount; ++r) {
		var rowRef = rowRefs[r];
		if(typeof rowRef === "number") {
			this._rebuildRowIdsFromChildren();
			ary[r] = rids[rowRef] || "";
		} else {
			ary[r] = rowRef || "";
		}
	}
	return ary;
};
/** Return all row ids with row data, excluding the group header rows (auto generated rows).&lt;br&gt;
* Do use getAllRowData to retrieve all data
* @public
* @param {boolean=} shallowCopy Default value is false. Set to true for speed
* @param {boolean=} inclNonDataRow=false If enabled, group header rows are included
* @return {!Array.&lt;string&gt;}
* @see {@link DataView#getAllRowData}
* @see {@link DataView#getMultipleRowData}
*/
DataView.prototype.getAllRowIds = function(shallowCopy, inclNonDataRow) {
	this._rebuildRowIdsFromChildren();

	// WARNING: this._pageView can contain non-data rows (group header rows), even if inclNonDataRow flag is false
	var rids = (inclNonDataRow) ? this._getRids() : (this._pageView || this._rids);

	return (shallowCopy) ? rids : rids.slice(0); // Fastest way to clone an array is Array.slice()
};
/** Return all data rows that is filtered and sorted, excluding header rows or paging. This method ignores pagination.
* @public
* @param {boolean=} opt_shallowCopy Default value is false. Set to true for speed
* @return {!Array.&lt;string&gt;}
*/
DataView.prototype.getSortedRowIds = function(opt_shallowCopy) {
	this._rebuildRowIdsFromChildren();
	if(opt_shallowCopy) {
		return this._rids;
	}
	return this._rids.slice(0); // Fastest way to clone an array
};
/** This method is quite slow
* @public
* @param {string} rid
* @return {number}
* @see {@link DataView#getRowId}
*/
DataView.prototype.getRowIndex = function(rid) {
	this._rebuildRowIdsFromChildren();

	return this._getRids().indexOf(rid);
};
/** @public
* @return {number}
*/
DataView.prototype.getRowCount = function() {
	return this._getRids().length;
};
/** @public
* @param {number} rowIndex
* @param {string} cid
* @returns {Object.&lt;string, *&gt;}
*/
DataView.prototype.getDataAt = function(rowIndex, cid) {
	return this._dt.getData(this.getRowId(rowIndex), cid);
};
/** This method is slow. When working with huge amount of rows, use getRowData in combination with getAllRowIds(true) instead of calling getRowDataAt multiple times.
* @public
* @param {number} rowIndex
* @return {Object.&lt;string, *&gt;}
*/
DataView.prototype.getRowDataAt = function(rowIndex) {
	return this._dt.getRowData(this.getRowId(rowIndex));
};
/** @public
* @param {string} rid
* @param {string} cid
* @returns {Object.&lt;string, *&gt;}
*/
DataView.prototype.getPreviousData = function(rid, cid) {
	return this._dt.getPreviousData(rid, cid);
};
/** @public
* @param {Array.&lt;string&gt;} rids
* @param {number=} opt_from
* @param {number=} opt_to EXCLUSIVE
* @return {!Array.&lt;Object&gt;}
*/
DataView.prototype.getMultipleRowData = function(rids, opt_from, opt_to) {
	return this._dt.getMultipleRowData(rids, opt_from, opt_to);
};
/** Return all rows with row data, excluding the group header rows (auto generated rows)
* @public
* @return {!Array.&lt;Object&gt;}
*/
DataView.prototype.getAllRowData = function() {
	return this.getMultipleRowData(this.getAllRowIds(true));
};

/** @public
* @param {string} rid
* @param {string} cid
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
* @fires DataView#dataChanged
*/
DataView.prototype.setData = function(rid, cid, value) {
	if(this._dt) {
		return this._dt.setData(rid, cid, value);
	}
	return false;
};
/** @public
* @param {string} rid
* @param {Object.&lt;string, *&gt;=} values
* @param {Object=} opt_eventArg
* @return {boolean} Return true if there is any change, and false otherwise
* @fires DataView#dataChanged
*/
DataView.prototype.setRowData = function(rid, values, opt_eventArg) {
	if(rid &amp;&amp; this._dt) {
		if (!this.isRowExpansion(rid)) {
			return this._dt.setRowData(rid, values, opt_eventArg);
		}
	}
	return false;
};
/** Set data in a column manner. This is faster than repeatedly calling {@link DataTable#setData}
* @public
* @param {string} cid
* @param {Array} valueList
* @param {Array.&lt;string&gt;=} opt_ridList Specify row id to be set corresponding to the data item
*/
DataView.prototype.setColumnData = function(cid, valueList, opt_ridList) {
	//  Note: This function should filter out row expansion before calling dt.setColumnData
	if(this._dt) {
		this._dt.setColumnData(cid, valueList, opt_ridList);
	}
};
/** This method is slow. When working with huge amount of rows, use setData in combination with getAllRowIds(true) instead of calling setDataAt multiple times.
* @public
* @param {number} rowIndex
* @param {string} cid
* @param {*} value
* @return {boolean} Return true if there is any change, and false otherwise
* @fires DataView#dataChanged
*/
DataView.prototype.setDataAt = function(rowIndex, cid, value) {
	var rid = this.getRowId(rowIndex);
	if(rid &amp;&amp; this._dt) {
		return this._dt.setData(rid, cid, value);
	}
	return false;
};
/** This method is slow. When working with huge amount of rows, use setRowData in combination with getAllRowIds(true) instead of calling setRowDataAt multiple times.
* @public
* @param {number} rowIndex
* @param {Object.&lt;string, *&gt;=} values
* @param {Object=} opt_eventArg
* @return {boolean} Return true if there is any change, and false otherwise
* @fires DataView#dataChanged
*/
DataView.prototype.setRowDataAt = function(rowIndex, values, opt_eventArg) {
	var rid = this.getRowId(rowIndex);
	return this.setRowData(rid, values, opt_eventArg);
};

/** @public
* @param {string|number} rowRef The position of the new row
* @param {Object.&lt;string, *&gt;=} opt_values
* @param {string|null=} opt_rid If the given row Id already exists, data is updated and no new row is added. Leave blank or null to let DataTable generate unique row Id
* @return {string} Return Row id that has been inserted or changed
*/
DataView.prototype.insertRow = function(rowRef, opt_values, opt_rid) { // Data changed event may be dispatched
	this._rebuildRowIdsFromChildren(); // TODO: Check if we need to rebuild row ids
	var nextRid = this._toRowId(rowRef);

	if(this._dt) {
		return this._dt.insertRow(nextRid, opt_values, opt_rid);
	}
	return "";
};

/** Permanently remove the specified row by row id or DataView's row index. If you want to temporarily remove the row, use {@link DataView.hideRows} instead
* @public
* @param {number|string} rowRef
* @fires DataView#dataChanged
*/
DataView.prototype.removeRow = function(rowRef) {
	if(this._dt) {
		this._dt.removeRow(this._toRowId(rowRef)); // Trigger dataChanged
	}
};
/** Permanently remove the specified rows by row id or DataView's row index. If you want to temporarily remove the rows, use {@link DataView.hideRows} instead
* @public
* @param {Array.&lt;number|string&gt;} refs
*/
DataView.prototype.removeRows = function(refs) {
	if(!this._dt) { return; }
	for(var i = refs.length; --i &gt;= 0;) {
		var rowRef = refs[i];
		if(typeof rowRef === "number") {
			refs[i] = this.getRowId(rowRef);
		}
	}
	this._dt.removeRows(refs); // Trigger dataChanged
};
/** Move a single row or multiple rows to the position BEFORE the specified index (toIndex).
* @public
* @param {Array.&lt;number&gt;|number} fromIndex fromIndex could be a rowIndex or array of rowIndex.
* @param {number} toIndex
* @return {Array.&lt;string&gt;|string} rid rowId or array of the rowId of the moved row(s)
* @example
* ary = [0, 1, 2];
* move(ary, 0, 1); // [0, 1, 2] Move index 0 to the position before index 1 (nothing is changed)
* move(ary, 1, 0); // [1, 0, 2] Move index 1 to the position before index 0
*/
DataView.prototype.moveRow = function(fromIndex, toIndex) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();

	var toRid = (toIndex &gt;= 0 &amp;&amp; toIndex &lt; rids.length) ? rids[toIndex] : "";

	var fromIndices = /** @type{Array.&lt;number&gt;} */(Array.isArray(fromIndex) ? fromIndex : [fromIndex]);
	var len = fromIndices.length;
	var fromRids = new Array(len);
	for(var i = 0; i &lt; len; ++i) {
		fromRids[i] = rids[fromIndices[i]];
	}

	return this._dt._moveRow(fromRids, toRid);
};

/** Deprecated
* @public
* @function
* @param {number} fromIndex
* @param {number} toIndex INCLUSIVE
*/
DataView.prototype.swapRow = Util._deprecatedFunction;

/** Returns the root data source (DataTable) of all data views
* @public
* @return {DataTable}
* @see {@link DataView#getDataSource}
*/
DataView.prototype.getDataTable = function() {
	return this._dt;
};
/** Return source for this data view which could be another data view or a data table.
* @public
* @return {DataTable|DataView}
* @see {@link DataView#getDataTable}
*/
DataView.prototype.getDataSource = function() {
	return this._parent;
};
/** @public
* @param {DataTable|DataView=} source
* @fires DataView#dataChanged
*/
DataView.prototype.setDataSource = function(source) {
	if(source) {
		if(this._groupLevel &gt; 0) {
			return; // Sub group cannot be changed data source
		}
		this._setParent(source);

		this._onDataChanged(DataTable._globalChangeArg); // Update current view
		this._parent.listen("dataChanged", this._onDataChanged);
	} else {
		if(this._parent) {
			this._parent.unlisten("dataChanged", this._onDataChanged);
			this._resetAllViews();
			this._groupViewDirty = false;
		}
		this._parent = this._dt = null;
		this._shared = {}; // The options are no longer shared
	}
};

/** @public
* @param {number} milliSecond
*/
DataView.prototype.setConflationRate = function (milliSecond) {
	this._conflator.disable(!milliSecond);
	this._conflator.setConflatingTime(milliSecond);
};

/** @public
* @return {number}
*/
DataView.prototype.getConflationRate = function () {
	return this._conflator.getConflatingTime();
};

/** @private
*/
DataView.prototype._resetAllViews = function() {
	this._rids.length = 0;
	if(this._groupView &amp;&amp; this._groupView.length) { this._groupView.length = 0; }
	if(this._pageView &amp;&amp; this._pageView.length) { this._pageView.length = 0; }
	if(this._expansionView &amp;&amp; this._expansionView.length) { this._expansionView.length = 0; }
};

/**
* @public
* @ignore
* @return {Object.&lt;string, DataTable.SortLogic&gt;}
*/
DataView.prototype.getSortingLogics = function() {
	return this._dt ? this._dt.getSortingLogics() : null;
};
/** @public
* @param {string|Array.&lt;string&gt;} cid
* @param {string|number|Array.&lt;string|number&gt;=} opt_sortOrder
* @param {Function|Array.&lt;Function&gt;=} sortLogics
* @fires DataView#dataChanged
*/
DataView.prototype.sort = function(cid, opt_sortOrder, sortLogics) {
	if(this._groupLevel &gt; 0) {
		window.console.log("ERROR: Sub-group cannot be sorted individually");
		return;
	}

	var compMap = this.getSortingLogics();
	var sortingDefs = this._sortingDefs;
	var curSortLen = sortingDefs.length;

	if (Array.isArray(sortLogics)) {
		for(var c = sortLogics.length; --c &gt;= 0;) {
			if (typeof sortLogics[c] !== "function") {
				var columnId = Array.isArray(cid) ? cid[c] : cid;
				sortLogics[c] = compMap[columnId] || compMap["_default"];
			}
		}
	}
	DataTable._buildSortContext(
		sortingDefs,
		cid,
		opt_sortOrder,
		sortLogics || compMap
	);
	if(sortingDefs.length === 1 &amp;&amp; sortingDefs[0][3] === 0) { // Sort order is zero which is resetting to original order
		sortingDefs.length = 0;
	}
	if(curSortLen &lt;= 0 &amp;&amp; sortingDefs.length &lt;= 0) {
		return; // Nothing is changed
	}
	if(this._shared.stalledRids) { // The stalled view cannot be changed
		return;
	}

	var change = false;
	if(this._groupMembers || sortingDefs.length &lt;= 0) {
		change = true;
		this._updateRowIds(); // WARNING: Slow!
	} else { // filtering should already be done beforehand
		change = this._sort();
	}
	if(change) {
		this._dispatchDataChange(DataTable._positionChangeArg);
	}
};
/** @public
* @param {string|Array.&lt;string&gt;} cid
* @param {string|number|Array.&lt;string|number&gt;=} opt_sortOrder
* @fires DataView#dataChanged
*/
DataView.prototype.sortOnce = function(cid, opt_sortOrder) {
	this.sort(cid, opt_sortOrder); // Global change event is dispatched
	this._sortingDefs.length = 0;
};
/** @public
* @param {DataTable.SortLogic} func
* @example
* customLogic = function(a, b, sortOrder) {
*   return (a - b) * sortOrder; // for numeric comparison
* };
* var dt = new DataTable();
* var dv = new DataView(dt);
* dv.setSortingLogic(customLogic);
* dv.sort("Column id", "ascending");
*/
DataView.prototype.setSortingLogic = function(func) {
	if(this._dt) {
		this._dt.setSortingLogic(func);
	}
};
/** Specified sorting logic for the column with the given column id. This will override logic set by {@link DataView#setSortingLogic}, when the column is sorted
* @public
* @param {string} cid
* @param {DataTable.SortLogic} func Use null to remove current sorting logic
*/
DataView.prototype.setColumnSortingLogic = function(cid, func) {
	if(this._dt) {
		this._dt.setColumnSortingLogic(cid, func);
	}
};
/** Check if this view is in sorting mode
* @public
* @return {boolean}
*/
DataView.prototype.isSorting = function() {
	return this._sortingDefs.length &gt; 0;
};

/** Hide rows in the data view
 * @param {string|number} rId Row id to hide. If the rId is a number, it will be treated as a row index
 * @param {boolean=} opt_show show if false
 * @public
 */
DataView.prototype.hideRow = function(rId, opt_show) {
	this.showRows([rId], opt_show === false);
};
/** Hide rows in the data view
 * @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or indices to hide
 * @param {boolean=} opt_show show if false
 * @public
 */
DataView.prototype.hideRows = function(rowRefs, opt_show) {
	this.showRows(rowRefs, opt_show === false);
};
/**
 * Show/hide rows in the data view
 * @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or indices to hide
 * @param {boolean=} opt_show hide instead show if false
 * @public
 */
DataView.prototype.showRows = function(rowRefs, opt_show) {
	var hidden = opt_show === false;
	if(hidden){
		if(!this._hiddenRids) {
			this._hiddenRids = {};
		}
	} else if(!this._hiddenRids) {
		return; // All rows are visible
	}

	var rids = this._toRowIds(rowRefs);
	for(var i = rids.length; --i &gt;= 0;) {
		var rid = rids[i];
		if(rid) { // undefined, null, and an empty string value are not a valid row id
			this._hiddenRids[rid] = hidden;
		}
	}

	this._refreshAndNotify(); // Very slow
};
/** Unhide all rows
* @public
*/
DataView.prototype.unhideAllRows = function(){
	if(this._hiddenRids) {
		this._hiddenRids = null;
		this._refreshAndNotify();
	}
};
/** Check if there is any hidden row
* @public
* @return {boolean}
*/
DataView.prototype.hasHiddenRow = function(){
	return !!this._hiddenRids;
};

/** @public
* @param {string|function(string, Object.&lt;string, *&gt;):boolean} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @param {boolean=} opt_filteringOut
* @return {boolean} Return true if there is any change. Otherwise, return false.
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
* @example
* dv.filterIn("FIELD", "Some value");
* dv.filterIn(function(rowId, rowData)) { // This is equivalent with the above statement
*     return rowData["FIELD"] === "Some value";
* });
*/
DataView.prototype.filterIn = function(cid, value, opt_filteringOut) {
	var newLogic = this._getFilterLogic(cid, value);
	var filteringOut = (opt_filteringOut === true);
	if(this._userFilter === newLogic &amp;&amp; typeof cid !== "function") {
		if(!newLogic || filteringOut === this._filteringOut) {
			return false; // Nothing to update
		}
	}
	this._shared.filterLogic = newLogic;
	this._userFilter = newLogic;
	this._filteringOut = filteringOut;
	this._refreshAndNotify();
	return true;
};
/** @public
* @param {string|function(string, Object.&lt;string, *&gt;):boolean} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @return {boolean} Return true if there is any change. Otherwise, return false.
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
* @example
* dv.filterIn("FIELD", "Some value");
* dv.filterOut(function(rowId, rowData)) { // This is equivalent with the above statement
*     return rowData["FIELD"] !== "Some value";
* });
*/
DataView.prototype.filterOut = function(cid, value) {
	return this.filterIn(cid, value, true);
};
/** @public
* @param {string|Function} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @param {boolean=} opt_filteringOut
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.filterInOnce = function(cid, value, opt_filteringOut) {
	var checker = this._getFilterLogic(cid, value);
	if(!checker) { return; }

	var filteringOut = (opt_filteringOut === true);
	var rids = this._rids;
	var dt = this._dt;
	var removalMap = {};
	var totalRem = 0;
	var len = rids.length;
	for(var i = len; --i &gt;= 0;) {
		var rid = rids[i];
		var values = dt.getRowData(rid);
		if (!values || checker(rid, values) === filteringOut) {
			removalMap[rid] = true;
			++totalRem;
		}
	}
	if(totalRem &lt;= 0) { return; }

	var firstChange = this._removeRowIds(removalMap);

	var pageIndexChanged = this._updatePageCount();
	if(pageIndexChanged || this._transformView(firstChange)) {
		this._dispatchGlobalChange();
	} else {
		this._dispatchMultiRowRemoved(Object.keys(removalMap));
	}
};
/** @public
* @suppress {checkTypes}
* @param {string|function(string, Object.&lt;string, *&gt;):boolean} cid Use string to identify column name. Use function for custom filter logic. Function will take rowId and column values as parameters, and return boolean value
* @param {*=} value
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.filterOutOnce = function(cid, value) {
	this.filterInOnce(cid, value, true);
};
/** @private
* @param {!Object.&lt;string, *&gt;} removalMap
* @return {number}
*/
DataView.prototype._removeRowIds = function(removalMap) {
	var firstChange = this._removeArrayItems(this._rids, removalMap);
	if(this._groupView) {
		firstChange = this._removeArrayItems(this._groupView, removalMap);
	}

	if(this._groupMembers) {
		var len = this._groupList.length;
		for(var i = 0; i &lt; len; ++i) {
			var groupId = this._groupList[i];
			this._groupMembers[groupId]._removeRowIds(removalMap);
		}
	}
	return firstChange;
};
/** @public
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.clearFilter = function() {
	if(this._userFilter) {
		this._userFilter = null;
		this._shared.filterLogic = null;
		this._refreshAndNotify();
	}
};

/** Disable the page index correction
* @public
* @param {boolean=} opt_disable
*/
DataView.prototype.disablePageCorrection = function(opt_disable) {
	this._pageCorrection = (opt_disable === false);
};
/** Goes to the specified page
* @public
* @param {number} pageIndex
* @return {boolean} True if there is any change, otherwise false
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.setPage = function (pageIndex) {
	var result = this._setPage(pageIndex);
	if(result) {
		this._dispatchGlobalChange();
	}
	return result;
};
/** {@link DataView#setPage}
* @public
* @function
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.gotoPage = DataView.prototype.setPage;
/** Goes to the next page. If current page is already the last page, nothing is performed
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.nextPage = function () {
	return this.gotoPage(this._pageIndex + 1);
};
/** Goes back to the previous page. If current page is already the first page, nothing is performed
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.previousPage = function () {
	return this.gotoPage(this._pageIndex - 1);
};
/** {@link DataView#previousPage}
* @public
* @function
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.prevPage = DataView.prototype.previousPage;
/** Goes to the last page
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.lastPage = function () {
	return this.gotoPage(this._lastPageIndex - 1);
};
/** Goes to the first page
* @public
* @return {boolean} True if there is any change, otherwise false
* @fires DataView#pageIndexChanged
*/
DataView.prototype.firstPage = function () {
	return this.gotoPage(0);
};

/**
* @public
* @return {number}
*/
DataView.prototype.getCurrentPage = function () {
	return this._pageIndex;
};
/** {@link DataView#getCurrentPage}
* @public
* @function
*/
DataView.prototype.getPageIndex = DataView.prototype.getCurrentPage;
/** Verifies that current page is the last page
* @public
* @return {boolean}
*/
DataView.prototype.isOnLastPage = function () {
	return (this._pageIndex === this._lastPageIndex);
};
/** Verifies that current page is the first page
* @public
* @return {boolean}
*/
DataView.prototype.isOnFirstPage = function () {
	return (this._pageIndex === 1);
};

/** Get total number of rows in a single page
* @public
* @return {number}
*/
DataView.prototype.getPageSize = function () {
	return this._pageSize;
};
/** Get total number of pages
* @public
* @return {number}
*/
DataView.prototype.getPageCount = function () {
	return this._lastPageIndex;
};
/** {@link DataView#getTotalPages}
* @public
* @function
*/
DataView.prototype.getTotalPages = DataView.prototype.getPageCount;
/** Shrink current view to the specified size. Set it 0 to reset to original size
* @public
* @param {number} pageSize
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
* @fires DataView#dataChanged
*/
DataView.prototype.setPageSize = function (pageSize) {
	if(!(pageSize &gt;= 0)) { pageSize = 0; }
	if(this._pageSize === pageSize) { return; }

	this._pageSize = pageSize;
	this._updatePageCount();

	if(pageSize &gt; 0) {
		if(!this._pageView) {
			this._pageView = [];
		}
	} else {
		if(this._pageView) {
			this._pageView = null;
		}
	}

	if(!this._pageView || pageSize === 0) {
		this._updateRowIds();
	} else {
		// filtering and sorting should already be done beforehand
		this._transformView();
	}
	this._dispatchGlobalChange();
};

/** string|function(Object.&lt;string, *&gt;):string|null
* @public
* @param {string|Function|Array.&lt;string|Function&gt;} cid Column id or grouper method that take one parameter for row data in JSON format, and returns groupId (string)
* @param {Array=} opt_predefinedGroups
* @fires DataView#groupAdded
* @fires DataView#groupCriteriaChanged
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
*/
DataView.prototype.groupBy = function (cid, opt_predefinedGroups) {
	// always deactivate multi-group row mode, it will automatically activate when populating group
	this._shared.multiGroupRow = false;

	if(this._groupCriteria) {
		if(this._groupList &amp;&amp; this._groupList.length &gt; 0) { // Dispose any existing member
			for(var key in this._groupMembers) {
				this._groupMembers[key].dispose(); // Clear everything in the data view
			}
			this._groupMembers = {}; // Clear all members
			this._groupList.length = 0;
		}
		this._groupCriteria = null;
	}
	if(opt_predefinedGroups != null) { // null is allowed
		this._setPredefinedGroups(opt_predefinedGroups);
	}

	var i, len;
	if(cid &amp;&amp; this._groupLevel === 0) { // Sub group cannot be re-group without its parent noticing it
		this._groupCriteria = [];
		var ary;
		if(!Array.isArray(cid)) {
			ary = [cid];
		} else {
			ary = /** @type{Array.&lt;string|Function&gt;} */(cid);
		}
		len = ary.length;
		for(i = 0; i &lt; len; ++i) {
			var criteria = ary[i];
			if(typeof criteria === "string") {
				this._groupCriteria.push(this._defaultGroupCriteria.bind(this, criteria));
			} else if(criteria) {
				this._groupCriteria.push(/** @type{Function} */(criteria));
			}
		}
	}

	if(this._groupCriteria) { // Only root view can have group criteria at this point
		if(!this._groupMembers) {
			this._groupMembers = {};
			this._groupList = [];
			this._groupRows = new DataCache();
		}
		if(!this._groupView) {
			this._groupView = [];
		}
	} else {
		this._groupMembers = null;
		this._groupList = null;
		this._groupView = null;
		if(this._groupRows) { // this._groupRows is a shared member
			if(this._groupLevel &lt;= 0) { // Only the root view can dispose _groupRows
				this._groupRows.dispose();
				this._footerRowIds = null;
			} else {
				if(this._groupRowId) {
					this._groupRows.setRowData(this._groupRowId);
				}
				if(this._footerRowIds) {
					len = this._footerRowIds.length;
					for(i = 0; i &lt; len; ++i) {
						this._groupRows.setRowData(this._footerRowIds[i]);
					}
					this._footerRowIds = null;
				}
			}
			this._groupRows = null;
		}
		this._groupValue = null;
	}
	this._groupLevel = 0; // View that is set criteria will always be in the first group level
	this._updateRowIds();

	this._dispatch("groupCriteriaChanged", {});
	this._dispatchGlobalChange();
};
/** addGroup is used to add a single predefined group or multiple predefined groups.
* @public
* @param {*|Array} value
* @fires DataView#groupAdded
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
*/
DataView.prototype.addGroup = function (value) {
	if(!this._groupMembers) {
		// window.console.log("Group criteria must be specified first before adding any group");
		return;
	}

	if(!isArray(value)) {
		this._addGroup(value);
	} else {
		var ary = /** @type{Array} */(value);
		var len = ary.length;
		for(var i = 0; i &lt; len; ++i) {
			this._addGroup(ary[i]);
		}
	}
};
/** Sort all of its descendants based on given compare function
* @public
* @param {Function=} compare Default is sorting by text. If null or false value is given, no sorting is performed
*/
DataView.prototype.sortGroups = function (compare) {
	if(!this._groupMembers) { return; }

	if(compare == null) {
		this._groupSortingLogic = DataView._defaultGroupSortingLogic; // Temporary set the variable
	} else {
		this._groupSortingLogic = compare || null;
	}
	if(!this._groupSortingLogic) {
		return; // No logic is defined
	}

	this._groupList.sort(this._internalGroupSortingLogic);
	for(var i = this._groupList.length; --i &gt;= 0;){
		var groupId = this._groupList[i];
		this._groupMembers[groupId].sortGroups(this._groupSortingLogic);
	}
	this._groupViewDirty = true;
	if(this._groupLevel &lt;= 0) {
		this._dispatchGlobalChange();
	}
};
/** Move the specified group within its group
* @public
* @param {number|string} groupRef
* @param {number} destIndex
*/
DataView.prototype.moveGroup = function (groupRef, destIndex) {
	var movedGroup = this.getGroup(groupRef);
	if(!movedGroup) {
		return; // Cannot find the given group
	}

	var parentGroup = movedGroup.getDataSource();
	var groupId = movedGroup.getGroupId();
	var curGroupIndex = parentGroup._groupList.indexOf(groupId);
	if(curGroupIndex === destIndex || curGroupIndex + 1 === destIndex) {
		return; // Nothing is needed to be moved
	}

	parentGroup._groupList.splice(curGroupIndex, 1);
	if(curGroupIndex &lt; destIndex) {
		--destIndex;
	}
	parentGroup._groupList.splice(destIndex, 0, groupId);

	this._requestRebuildingRowIds(false);
};
/** WARNING: This could be very slow to perform
* @public
* @param {Array} predefinedGroups Use two dimensional array to define groups for multi-level grouping. The first item is for the top level groups. The second item is for the second level groups, and so on. If one dimentional array is given, it is treated as the first item in the two-dimentionsal array.
* @example
* dv.setPredefinedGroups(["a", "b", "c"]); // Create empty three empty groups
* dv.setPredefinedGroups([ // Create two empty groups, and each group has 3 sub-groups
*   ["Main Group 1", "Main 2"],
*   ["Sub 1", "Sub 2", "Sub 3"]
* ]);
*/
DataView.prototype.setPredefinedGroups = function (predefinedGroups) {
	this._setPredefinedGroups(predefinedGroups);
	if(this._groupMembers) {
		this._refreshAndNotify();
	}
};
/** @private
* @param {Array} predefinedGroups
*/
DataView.prototype._setPredefinedGroups = function (predefinedGroups) {
	if(this._preDefGroups === predefinedGroups) {
		return;
	}

	if(this._preDefGroups) {
		this._preDefGroups.length = 0; // Remove all predefined groups in all members (this var is shared)
	}
	var is2D = false;
	if(predefinedGroups) {
		for(var i = predefinedGroups.length; --i &gt;= 0;) {
			if(Array.isArray(predefinedGroups[i])) {
				is2D = true;
				break;
			}
		}
	}

	if(is2D) {
		this._preDefGroups = predefinedGroups; // WARNING: Referencing user's object
	} else if(Array.isArray(predefinedGroups)) {
		this._preDefGroups = [predefinedGroups]; // Convert to 2D Array
	} else {
		this._preDefGroups = null;
	}
	this._preDefGroupsDirty = true;
};

/** Add a footer to current group
* @public
* @param {number=} opt_num Number of footer to be added. If not specified, the number is one.
*/
DataView.prototype.addFooter = function (opt_num) {
	if(this._groupLevel &lt;= 0) {
		console.log("WARNING: Only group can have a footer");
		return;
	}
	if(opt_num == null) {
		opt_num = 1;
	}
	if(opt_num &lt;= 0) { // 0 and negative number is not acceptable
		return;
	}

	if(!this._footerRowIds) {
		this._footerRowIds = [];
	}

	for(var i = 0; i &lt; opt_num; ++i) {
		var footerRowId = this._groupRowId + "_footer" + (this._footerRowIds.length || "");
		this._footerRowIds.push(footerRowId);
		this._groupRows.setData(footerRowId, "DataView", this);
	}

	if(!this._beingAdded) {
		this._requestRebuildingRowIds(this._collapsed); // Slow
	}
};
/** Remove all footers in the gurrent view
* @public
*/
DataView.prototype.removeFooter = function () {
	if(this._footerRowIds) {
		var len = this._footerRowIds.length;
		for(var i = 0; i &lt; len; ++i) {
			this._groupRows.setRowData(this._footerRowIds[i]);
		}
		this._footerRowIds = null;

		if(!this._beingAdded) {
			this._requestRebuildingRowIds(this._collapsed); // Slow
		}
	}
};

/** Enable/Disable multi-group row mode
* @public
* @ignore
* @param {boolean=} enabled
*/
DataView.prototype.enableMultiGroup = function(enabled) {
	this._shared.multiGroupRow = enabled !== false;
};
/** Get the corresponding data view from the given group reference
* @public
* @param {number|string} groupRef Either index or group id can be used to retrieve DataView
* @return {DataView}
*/
DataView.prototype.getGroup = function (groupRef) {
	if(!this._groupMembers) {
		return null;
	}
	var groupId;
	if(typeof groupRef === "number") {
		groupId = this._groupList[groupRef];
		if(groupId == null) {
			return null;
		}
	} else {
		groupId = groupRef + ""; // Convert to string
	}
	var dv = this._groupMembers[groupId];
	if(!dv) {
		dv = /** @type{DataView} */(this._groupRows.getData(groupId, "DataView"));
	}
	return dv || null;
};
/** Get all group descendants
* @public
* @param {Array=} out_ary
* @return {!Array.&lt;DataView&gt;}
*/
DataView.prototype.getAllGroups = function (out_ary) {
	if(!out_ary) { out_ary = []; }
	if(this._groupMembers) {
		var len = this._groupList.length;
		for(var i = 0; i &lt; len; ++i) {
			var groupId = this._groupList[i];
			var grp = this._groupMembers[groupId];
			out_ary.push(grp);
			grp.getAllGroups(out_ary);
		}
	}
	return out_ary;
};
/** Get immediate group members row ids in array list
* @public
* @return {Array.&lt;string&gt;}
*/
DataView.prototype.getGroupList = function () {
	return this._groupList;
};
/** Get group id (string) of this data view. Only exists if this data view is a child data view
* @public
* @return {string}
*/
DataView.prototype.getGroupId = function () {
	return this._groupId;
};
/** Get group value (any data type) of this data view. Only exists if this data view is a child data view
* @public
* @return {*}
*/
DataView.prototype.getGroupValue = function () {
	return this._groupValue;
};
/** Row id used by parent data view as a header row for referencing
* @public
* @return {string}
*/
DataView.prototype.getGroupRowId = function () {
	return this._groupRowId;
};
/**
* @public
* @ignore
* @param {number} rid
* @return {number}
*/
DataView.prototype.getFooterRowIndex = function (rid) {
	if(this._footerRowIds) {
		for(var i = this._footerRowIds.length; --i &gt;= 0;) {
			if(this._footerRowIds[i] === rid) {
				return i;
			}
		}
	}
	return -1;
};
/** A List of the footer row ids. Footer row is placed at the bottom of all other rows in this view
* @public
* @ignore
* @return {Array.&lt;string&gt;} Null if there is no footer row
*/
DataView.prototype.getFooterRowIds = function () {
	return this._footerRowIds;
};
/**
* @public
* @return {boolean}
*/
DataView.prototype.hasGroup = function () {
	return (this._groupMembers) ? true : false;
};
/** Contains header and footer row data
* @public
* @return {DataCache}
*/
DataView.prototype.getGroupRows = function () {
	return this._groupRows;
};
/** Get group level of the corresponding row. If the given index is not specified, header row (the view itself) is used instead. Group level 0 means it is the root data view.
* @public
* @param {number=} opt_rowIndex
* @return {number}
*/
DataView.prototype.getGroupLevel = function (opt_rowIndex) {
	if(opt_rowIndex != null) {
		this._rebuildRowIdsFromChildren();
		var rids = this._getRids();
		var rid = rids[opt_rowIndex];
		while(rid) {
			var dv = this._groupRows.getData(rid, "DataView");
			if(dv) {
				return dv._groupLevel;
			}
			rid = rids[--opt_rowIndex];
		}
	}
	return this._groupLevel;
};

/** Statistics (e.g. Sum, Avg, Max, and Min) of the specified column will be collected on every update. WARNING: CPU usage is intensive. Do disable, if the column is no longer used.
* @public
* @param {string} cid
* @param {boolean=} opt_enabled
* @param {string=} opt_refId
* @return {ColumnStats} ColumnStats Object
*/
DataView.prototype.enableColumnStats = function(cid, opt_enabled, opt_refId) {
	if (!cid) { return null; }
	var enabled = opt_enabled !== false;
	var cs = this._columnStats[cid];
	if(enabled) {
		if(!cs) {
			cs = new ColumnStats(this, cid);
			this._columnStats[cid] = cs;
		}
		cs.addRef(opt_refId);
	} else {
		if(cs) {
			if(!cs.deRef(opt_refId)) {
				cs.dispose();
				delete this._columnStats[cid];
			}
		}
	}
	if(this._groupMembers) {
		for(var i = this._groupList.length; --i &gt;= 0;) {
			var groupId = this._groupList[i];
			this._groupMembers[groupId].enableColumnStats(cid, opt_enabled, opt_refId);
		}
	}
	return cs || null;
};
/** @public
 * @param {string} cid
* @return {ColumnStats} ColumnStats. Return null if the column has not been enabled
*/
DataView.prototype.getColumnStats = function(cid) {
	return this._columnStats[cid] || null;
};

/** This method temporarily remove all rows from the view, which can improve performance as further updates and operations will be ignored
* @public
* @param {boolean=} opt_hidden
* @returns {boolean}
*/
DataView.prototype.hide = function(opt_hidden) {
	var val = opt_hidden !== false;
	if(this._hidden === val) {
		return false;
	}

	this._hidden = val;
	this._refreshAndNotify();
	return true;
};
/** @public
* @return {boolean}
*/
DataView.prototype.isHidden = function() {
	return this._hidden;
};
/** @private
* @return {boolean}
*/
DataView.prototype._isHeaderRowShown = function() {
	if (this._hiddenHeaderRow) {
		return false;
	}
	if (this._shared.filterLogic &amp;&amp; this._rids.length === 0) {
		// When filter is active, group without its member will be hidden
		return false;
	}

	// Group member with option autoGroupHiding enabled should always set `_collapsed` to false. Otherwise group will be collapsed and cannot be expanded by UI.
	if (this._shared.autoGroupHiding &amp;&amp; this._groupValue == null) {
		// In auto grouping mode, if group value is either undifined or null the header row will be hidden
		return false;
	}
	return true;
};
/** @private
* @param {boolean} collapsed
* @return {boolean} Return true if there is any change
*/
DataView.prototype._setCollapse = function(collapsed) {
	if (this._shared.contentAsHeader) {
		// In this mode, only groups with hidden group header can be expanded/collapsed.
		// Ignore any group with visible group header
		if (this._hiddenHeaderRow) {
			if (this._showOnlyFirstMember !== collapsed) {
				this._showOnlyFirstMember = collapsed;
				return true;
			}
		}
	} else if (this._isHeaderRowShown()) { // Only groups with visible group header can be expanded/collapsed
		if (this._collapsed !== collapsed) {
			this._collapsed = collapsed;
			return true;
		}
	}
	return false;
};
/** Collapse current view. This works only if the view is generated as a child view
* @public
* @param {boolean=} opt_collapsed
*/
DataView.prototype.collapse = function(opt_collapsed) {
	var dirty = this._setCollapse(opt_collapsed !== false);

	if(dirty) {
		if (this._shared.contentAsHeader) {
			if (this._hiddenHeaderRow) {
				this._requestRebuildingRowIds(this._showOnlyFirstMember); // Slow
			}
		} else {
			if(this._groupLevel &gt; 0) {
				this._requestRebuildingRowIds(this._collapsed);
			}
		}
	}
};
/** Collapse all children and descendants, excluding itself and its parent
* @public
* @param {boolean=} opt_collapsed
*/
DataView.prototype.collapseAllGroups = function(opt_collapsed) {
	var grpList = this.getAllGroups();
	var len = grpList.length;
	if(len) {
		var collapsed = (opt_collapsed !== false);
		for(var i = 0; i &lt; len; ++i) {
			var grpItem = grpList[i];
			grpItem._setCollapse(collapsed);
		}
		this._requestRebuildingRowIds(false);
	}
};
/** @public
*/
DataView.prototype.toggleCollapsedState = function() {
	this.collapse(!this.isCollapsed());
};
/** @public
* @return {boolean}
*/
DataView.prototype.isCollapsed = function() {
	return this._collapsed || this._showOnlyFirstMember;
};
/** Content as header mode indicates that the group headers cannot be collapsed and the first row in the group will always be shown.
* @public
* @param {boolean=} bool
*/
DataView.prototype.enableContentAsHeader = function(bool) {
	this._shared.contentAsHeader = bool !== false;
};
/** @private
* @return {?Array.&lt;string&gt;}
*/
DataView.prototype._getFirstHiddenRids = function() {
	if(this._shared.contentAsHeader) {
		if(this._showOnlyFirstMember) {
			var rids = this._rids;
			if (Array.isArray(rids) &amp;&amp; rids.length) {
				return [rids[0]]; // Get only the first member of rids
			}
		}
	}
	return null;
};
/** This method returns current visible rows (i.e. it excludes rows that are not in current page, and are in collapsed groups). Group header rows are also includes in the results.
* @public
* @param {boolean=} opt_shallowCopy Default value is false. Set to true for speed
* @return {!Array.&lt;string&gt;}
*/
DataView.prototype.getVisibleRowIds = function(opt_shallowCopy) {
	return this.getAllRowIds(opt_shallowCopy, true);
};
/** This will not include collapsed group and rows
* @public
* @return {number}
*/
DataView.prototype.getVisibleRowCount = function() {
	if(this._collapsed) {
		return 0;
	}
	this._rebuildRowIdsFromChildren();
	return this._getRids().length;
};

/** @public
* @description check weather row object is in group
* @param {Object} rowData
* @param {string=} groupID Default group id is the group id of the DataView that is being called.
* @return {boolean}
*/
DataView.prototype.isRowDataInGroup = function (rowData, groupID) {
	var criteria = this._groupCriteria;
	var level = this._groupLevel;

	// Because self is a leaf group, only check against self.
	if (!groupID || groupID === this.getGroupId()) {
		return this._isAllowedInGroup(null, rowData);
	}

	// Check against self and all sub groups within self
	for (var i = level; i &lt; criteria.length; i++) {
		if (criteria[i](rowData).indexOf(groupID) &gt;= 0) {
			return true;
		}
	}
	return false;
};

/** @public
* @description check weather row ID is in group
* @param {string} rowId
* @param {string=} groupID Default group id is the group id of the DataView that is being called.
* @return {boolean}
*/
DataView.prototype.isRowIdInGroup = function (rowId, groupID) {
	var dt = this.getDataSource();
	if (!dt) return false;
	var data = dt.getRowData(rowId);
	if (data == null) return false;

	return this.isRowDataInGroup(data, groupID);
};

/** @private
* @param {string} rid Row Id
* @param {number} _index child index
* @return {string}
*/
DataView._getDataViewExpansionId = function (rid, _index) {
	return rid + "_ex" + _index;
};

/** The row expansion will be directly below the specified row, even if this data view is sorted.
* @public
* @param {string} rid Row Id
* @param {number=} count=1
*/
DataView.prototype.addRowExpansion = function(rid, count) {
	if(this._groupLevel &gt; 0) {
		return; // Sub-group is not allowed to add a row expansion
	}

	if(!count || count &lt; 0) {
		if(count == null) {
			count = 1;
		} else {
			return;
		}
	}

	var rowIndex = this._rids.indexOf(rid);
	if(rowIndex &lt; 0) {
		// The given row id must be normal row. header and expansion row are not in the this._rids list
		return;
	}

	var expCount = 0;
	if(this._expansionMap) {
		expCount = this._expansionMap[rid] || 0;
	} else {
		this._expansionMap = {};
		this._expansionChildren = {};
	}
	var totalChild = expCount + count;
	this._expansionMap[rid] = totalChild;

	// create _expansionChildren mapping

	for (var i = expCount; i &lt; totalChild; i++) {
		this._expansionChildren[DataView._getDataViewExpansionId(rid, i)] = rid;
	}

	if(!expCount) {
		// There is no row expansion for the row before, add number of entries to the map
		this._expansionCount++;
	}

	if(this._groupViewDirty) { // If group view is already dirty, we don't need to update row expansion right away
		return;
	}

	if(this._updateExpansionView()) {
		var e = {}; // Slow
		e["rid"] = rid;
		e["type"] = "inserted";
		e["nextRid"] = this._rids[rowIndex + 1];
		e["fallback"] = rowIndex; // Fallback index in case of no nextRid is found in the receiver
		this._dispatchDataChange(e);
	}
};
/**
* @public
* @param {string} rid Row Id
*/
DataView.prototype.removeRowExpansion = function(rid) {
	if(!this._expansionMap) {
		return;
	}
	var expCount = this._expansionMap[rid];
	if(!expCount) {
		return;
	}

	var rids = new Array(expCount);
	for (var i = 0; i &lt; expCount; ++i) {
		rids[i] = DataView._getDataViewExpansionId(rid, i);
		delete this._expansionChildren[rids[i]];
	}

	delete this._expansionMap[rid];
	this._expansionCount--;

	if(!this._groupViewDirty) { // If group view is already dirty, we don't need to update row expansion right away
		if(this._updateExpansionView()) {
			if(expCount === 1) {
				this._dispatchRowRemoved(rids[0]); // TODO: Expansion rid may not need to be sent
			} else {
				this._dispatchMultiRowRemoved(rids);
			}
		}
	}
};
/**
* @public
* @param {string|number} rowRef Row Id or index
* @param {boolean=} force
* @param {number=} count=1
*/
DataView.prototype.toggleRowExpansion = function(rowRef, force, count) {
	var rid = this._toRowId(rowRef);

	if(force != null) {
		force = force === true;
	} else {
		force = !this.hasRowExpansion(rid);
	}

	if (force) {
		this.addRowExpansion(rid, count);
	} else {
		this.removeRowExpansion(rid);
	}
};
/** @public
*/
DataView.prototype.removeAllRowExpansions = function() {
	if(this._expansionMap) {
		this._expansionMap = null;
		this._expansionCount = 0;
		this._expansionView = null;
		this._expansionChildren = null;
		this._refreshAndNotify();
	}
};
/** Deprecated. Use {@link DataView#getExpansionParents} instead. Get all rows with expansion (not row expansion itself) will contains row id, otherwise undefined.
* @public
* @ignore
* @param {number=} from
* @param {number=} to EXCLUSIVE
* @return {!Array.&lt;string|undefined&gt;}
*/
DataView.prototype.getRowsWithExpansion = function(from, to) {
	if(!this._expansionMap) {
		return [];
	}
	var rids = this._expansionView;
	var len = rids.length;
	if(to == null) { to = len; }
	else if(to &gt; len) { to = len; }

	if(!(from &gt; 0)) { from = 0; } // Handle NaN, undefined, null, and other invalid value

	var entryCount = this._expansionCount;
	var out_ary = new Array(len);
	for(var i = from; i &lt; to; ++i) {
		var rid = rids[i];
		if(this._expansionMap[rid]) {
			out_ary[i] = rid;
			if(--entryCount &lt;= 0) {
				break;
			}
		}
	}
	return out_ary;
};
/** Get row expansion states from the specified range. The returned value will be row id for row expansion, otherwise empty string for other types of row (e.g. normal row, or group header row)
* @public
* @param {number=} from
* @param {number=} to EXCLUSIVE
* @return {Array.&lt;string&gt;} object mapping of rowIndex and parentRowId
*/
DataView.prototype.getExpansionParents = function (from, to) {
	var parentMapping = [];
	if (this._expansionMap) {
		var rids = this._expansionView;
		var len = rids.length;

		// Handle NaN, undefined, null, and other invalid values
		if (to == null || to &gt; len) {
			to = len;
		}
		if (!from || from &lt; 0) {
			from = 0;
		}

		for (var i = from; i &lt; to; ++i) {
			parentMapping[i] = this._expansionChildren[rids[i]] || "";
		}
	}
	return parentMapping;
};

/** Check if the specified row is itself a row expansion.
* @public
* @param {string} rid rowId
* @return {boolean}
*/
DataView.prototype.isRowExpansion = function(rid) {
	if(this._expansionChildren) {
		return this._expansionChildren[rid] ? true : false;
	}
	return false;
};
/** Check if the specified row has row expansion (not row expansion itself).
* @public
* @param {string} rid rowId
* @return {boolean}
*/
DataView.prototype.hasRowExpansion = function(rid) {
	if(this._expansionMap) {
		return this._expansionMap[rid] ? true : false;
	}
	return false;
};
/** Get row Id of the row expansion by providing the row Id of the row with row expansion (not row expansion itself). This is NOT recommended for normal usage, since the row expansion contains no data in the DataView
* @public
* @param {string} rid rowId
* @param {number=} idx=0
* @return {string} Empty string is returned if the provided row does not contains a row expansion.
*/
DataView.prototype.getRowExpansionId = function(rid, idx) {
	if(this._expansionMap) {
		var expCount = this._expansionMap[rid] || 0;
		if(!idx) {
			idx = 0;
		}
		if (idx &lt; expCount) {
			return DataView._getDataViewExpansionId(rid, idx); // WARNING: Internal logic is exposed
		}
	}
	return "";
};

/** Get index from the row expansion id. Any row other than row expansion will yield negative value (-1)
* @public
* @param {string} rid Row expansion id
* @return {number}
*/
DataView.prototype.getRowExpansionIndex = function(rid) {
	if(rid) {
		var matches = rid.match(/_ex(\d+)$/);
		if(matches) {
			return +matches[1]; // TODO: Check for NaN value
		}
	}
	return -1;
};
/** @private
* @return {boolean}
*/
DataView.prototype._updateExpansionView = function() {
	var expMap = this._expansionMap;
	if(expMap) {
		if(!this._expansionCount || this._expansionCount &lt; 0) {
			this._expansionCount = 0;
			this._expansionMap = null;
			this._expansionView = null;
			this._expansionChildren = null;
			return true;
		}

		var rids = this._pageView || this._groupView || this._rids;
		var rowLen = rids.length;
		var origLen = this._expansionView ? this._expansionView.length : 0;
		if(!this._expansionView) {
			this._expansionView = new Array(rowLen);
		} else {
			this._expansionView.length = rowLen;
		}
		var entryCount = this._expansionCount;
		for(var i = 0, j = 0; i &lt; rowLen; ++i) {
			var rid = rids[i];
			this._expansionView[j++] = rid;
			if(entryCount) {
				var expCount = expMap[rid] || 0;
				if(expCount) {
					for(var k = 0; k &lt; expCount; ++k) {
						this._expansionView[j++] = DataView._getDataViewExpansionId(rid, k);
					}
					--entryCount;
				}
			}
		}
		return origLen !== this._expansionView.length; // TODO: This does not completely check the change of all cases
	} else {
		return false;
	}
};
/** Guarantee that expansion is added after the pagination view
* @private
* @param {number=} firstChange
* @return {boolean}
*/
DataView.prototype._transformView = function(firstChange) {
	var dirty = this._updatePaginationView(firstChange);
	dirty |= this._updateExpansionView();
	return dirty ? true : false;
};

/**
* @public
* @param {function(Object):boolean} searchLogic Function that takes row data object and return boolean value
* @param {Array.&lt;string&gt;=} opt_out Array for containing row ids
* @return {!Array.&lt;string&gt;} List of row ids
*/
DataView.prototype.searchAll = function(searchLogic, opt_out) {
	if(!opt_out) { opt_out = []; }

	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	var len = rids.length;

	for(var i = 0; i &lt; len; ++i) {
		var rid = rids[i];
		var row = this._dt.getRowData(rid);
		if(row) {
			if(searchLogic(row)) {
				opt_out.push(rid);
			}
		}
	}
	return opt_out;
};
/**
* @public
* @param {number|string} rowRef
* @param {function(Object):boolean} searchLogic Function that takes row data object and return boolean value
* @return {number} Row index
*/
DataView.prototype.searchPrev = function(rowRef, searchLogic) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	var rowIndex = -1;
	if(typeof rowRef === "number") {
		if(this._dt.getRowData(rids[rowRef])) {
			rowIndex = rowRef;
		}
	} else {
		rowIndex = rids.indexOf(rowRef);
	}

	var foundAt = -1;
	var len = rids.length;
	if(rowIndex &gt; 0) {
		foundAt = this._searchRow(rids, searchLogic, rowIndex - 1, -1, -1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	if(rowIndex &gt;= 0) { // loop the search by starting from the end
		foundAt = this._searchRow(rids, searchLogic, len - 1, rowIndex, -1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	return -1;
};
/**
* @public
* @param {number|string} rowRef
* @param {function(Object):boolean} searchLogic Function that takes row data object and return boolean value
* @return {number} Row index
*/
DataView.prototype.searchNext = function(rowRef, searchLogic) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();
	var rowIndex = -1;
	if(typeof rowRef === "number") {
		if(this._dt.getRowData(rids[rowRef])) {
			rowIndex = rowRef;
		}
	} else {
		rowIndex = rids.indexOf(rowRef);
	}
	if(rowIndex &lt; 0) { // Cannot find the specified row
		return -1;
	}

	var foundAt = -1;
	var len = rids.length;
	if(rowIndex &lt; len - 1) {
		foundAt = this._searchRow(rids, searchLogic, rowIndex + 1, len, 1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	if(rowIndex &gt; 0) { // loop the search by starting from the start
		foundAt = this._searchRow(rids, searchLogic, 0, rowIndex, 1);
		if(foundAt &gt;= 0) {
			return foundAt;
		}
	}
	return -1;
};
/**
* @private
* @param {!Array.&lt;string&gt;} rids
* @param {function(Object):boolean} searchLogic
* @param {number} start
* @param {number} end
* @param {number} inc
* @return {number}
*/
DataView.prototype._searchRow = function(rids, searchLogic, start, end, inc) {
	while(start !== end) {
		var rid = rids[start];
		var row = this._dt.getRowData(rid);
		if(row) {
			if(searchLogic(row)) {
				return start;
			}
		}
		start += inc;
	}
	return -1;
};

/** Blocks all row insertion and removal, but keep updating the data
* @public
* @param {boolean=} opt_bool
* @return {boolean} True if there is any change
*/
DataView.prototype.stall = function(opt_bool) {
	var newBool = opt_bool !== false;
	var curBool = this._shared.stalledRids ? true : false;
	if(curBool === newBool) { return false; }
	if(newBool) {
		var srs = {};
		this._shared.stalledRids = srs;
		var rids = this._getRids();

		for(var i = rids.length; --i &gt;= 0;) {
			srs[rids[i]] = 1;
		}
	} else {
		this._shared.stalledRids = null;
		this._refreshAndNotify();
	}
	return true;
};
/** Automatically and asyncronuosly remove group that has no member or no content. Predefined groups will not be removed in this way.
* @public
* @param {boolean=} opt_bool
* @return {boolean} True if there is any change
*/
DataView.prototype.enableAutoGroupRemoval = function(opt_bool) {
	opt_bool = opt_bool !== false;
	var autoGroupRemoval = this._shared.autoGroupRemoval ? true : false;
	if(autoGroupRemoval !== opt_bool) {
		this._shared.autoGroupRemoval = opt_bool;
		this._triggerGroupRefreshing();
		return true;
	}
	return false;
};
/** Automatically hide null or undefined group header, while keeping the group's items intact.
* @public
* @param {boolean=} opt_bool
* @return {boolean} True if there is any change
*/
DataView.prototype.enableAutoGroupHiding = function(opt_bool) {
	opt_bool = opt_bool !== false;
	var autoGroupHiding = this._shared.autoGroupHiding ? true : false;
	if(autoGroupHiding !== opt_bool) {
		this._shared.autoGroupHiding = opt_bool;
		this._triggerGroupRefreshing();
		return true;
	}
	return false;
};

/** Copy row order in data view to its data table
* @public
*/
DataView.prototype.synchronizeRowOrder = function() {
	if(this.isSorting()) {
		this._dt._sort(this._sortingDefs);
	}
};
/** Set visible row as segment separator (hidden or filtered rows cannot be a segment separator)
* @public
* @param {string|number} rowRef Row id or row index
* @param {boolean=} enabled
* @return {boolean} Return true if there is any change
*/
DataView.prototype.setSegmentSeparator = function(rowRef, enabled) {
	var rowId = "";
	if(typeof rowRef === "number") {
		rowId = this.getRowId(rowRef);
	} else if(typeof rowRef === "string") {
		var rowIndex = this._getRowIndex(this._getRids(), rowRef);
		if(rowIndex &gt;= 0) { // Only visible row can be set as segment separator
			rowId = rowRef;
		}
	}

	if(rowId) {
		enabled = enabled !== false;
		if(enabled) {
			this.synchronizeRowOrder();
		}
		// TODO: Force expanding of segment before unsetting segment separator
		return this._dt.setSegmentSeparator(rowId, enabled);
	}
	return false;
};
/**
* @public
* @return {boolean} Return true if there is any change
*/
DataView.prototype.unsetAllSegmentSeparators = function() {
	return this._dt.unsetAllSegmentSeparators();
};
/**
* @public
* @return {boolean}
*/
DataView.prototype.hasSegmentation = function() {
	return this._dt.hasSegmentation();
};
/**
* @public
* @param {string} rid
* @return {boolean}
*/
DataView.prototype.isSegmentSeparator = function(rid) {
	return this._dt.isSegmentSeparator(rid);
};

/** @public
* @param {string|number} rowRef Row id or row index
* @param {boolean=} collapsed
* @return {boolean} Return true if there is any change
*/
DataView.prototype.collapseSegment = function(rowRef, collapsed) {
	collapsed = collapsed !== false;
	var segments = this._dt._getSegmentSeparators();
	if(segments) {
		var segmentRid = this._toRowId(rowRef);

		if(segments.collapseSegment(segmentRid, collapsed)) {
			this._refreshAndNotify(); // dispatch global change event

			return true;
		}
	}

	return false;
};
/** @public
* @param {string|number} rowRef Row id or row index
* @param {boolean=} expanded
* @return {boolean} Return true if there is any change
*/
DataView.prototype.expandSegment = function(rowRef, expanded) {
	return this.collapseSegment(rowRef, expanded === false);
};
/** @public
* @return {boolean} Return true if there is any change
*/
DataView.prototype.expandAllSegments = function() {
	var segments = this._dt._getSegmentSeparators();
	if(segments) {
		if(segments.expandAllSegments()) {
			this._refreshAndNotify();
			return true;
		}
	}
	return false;
};
/** Deprecated.
* @public
* @ignore
*/
DataView.prototype.setSegmentCollapsingLogic = function() {};
/** @public
* @param {string|number} rowRef Row id or row index
* @return {boolean} Return true if only the given row is a collapsed segment separator
*/
DataView.prototype.isSegmentCollapsed = function(rowRef) {
	var segments = this._dt._getSegmentSeparators();
	if(segments) {
		return segments.isCollapsedSegment(this._toRowId(rowRef));
	}
	return false;
};
/** Remove existing segment children and fill the segments with all contnet rows before the next segment separator
* @public
* @param {string|number} segmentRef Row id or row index
*/
DataView.prototype.fillSegment = function(segmentRef) {
	this._dt.fillSegment(this._toRowId(segmentRef));
};
/** Remove all existing segment children in each segment and fill the segments with all contnet rows before the next segment separator
* @public
*/
DataView.prototype.fillSegments = function() {
	this._dt.fillSegments();
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {string|number} rowRef Row id, row index
* @return {boolean} Return true if there is any change
*/
DataView.prototype.addSegmentChild = function(segmentRef, rowRef) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowId = this._toRowId(rowRef);
		return this._dt.addSegmentChild(segmentId, rowId);
	}
	return false;
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or row indices
* @return {boolean} Return true if there is any change
*/
DataView.prototype.addSegmentChildren = function(segmentRef, rowRefs) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowIds = this._toRowIds(rowRefs);
		return this._dt.addSegmentChildren(segmentId, rowIds);
	}
	return false;
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {string|number} rowRef Row id, row index
* @return {boolean} Return true if there is any change
*/
DataView.prototype.removeSegmentChild = function(segmentRef, rowRef) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowId = this._toRowId(rowRef);
		return this._dt.removeSegmentChild(segmentId, rowId); // TODO: Handle the case where a child is remove from its collapsed parent. Child should be made visible
	}
	return false;
};
/** @public
* @param {string|number} segmentRef Row id or row index
* @param {Array.&lt;string|number&gt;} rowRefs Array of row ids or row indices. If null is given, no child will be removed.
* @return {boolean} Return true if there is any change
*/
DataView.prototype.removeSegmentChildren = function(segmentRef, rowRefs) {
	if(this._dt._getSegmentSeparators()) {
		var segmentId = this._toRowId(segmentRef);
		var rowIds = this._toRowIds(rowRefs);
		return this._dt.removeSegmentChildren(segmentId, rowIds); // TODO: Handle the case where a child is remove from its collapsed parent. Child should be made visible
	}
	return false;
};
/** @public
* @return {boolean} Return true if there is any change
*/
DataView.prototype.removeAllSegmentChildren = function() {
	return this._dt.removeAllSegmentChildren();
};
/** Get row ids of all segment separator
* @public
* @return {Array.&lt;string&gt;} Return null if there is no segment separator
*/
DataView.prototype.getSegmentIds = function() {
	return this._dt.getSegmentIds();
};
/** Get row ids of all children from the specified segment
* @public
* @param {string|number} segmentRef Row id or row index
* @return {Array.&lt;string&gt;} Returns array of row ids. Returns null if there is no child or no segment separator found
*/
DataView.prototype.getSegmentChildIds = function(segmentRef) {
	return this._dt.getSegmentChildIds(this._toRowId(segmentRef));
};
/** Sort all of existing segments by given compare function
* @public
* @param {Function} compare
*/
DataView.prototype.sortSegments = function (compare) {
	this._dt.sortSegments(compare);
};

/** Construct a JSON object that is compatible with console.table()
* @public
* @param {Object=} opt_options {@link DataCache#dump}
* @return {!Array.&lt;Object&gt;} Return a JSON object that is compatible with console.table()
* @see {@link DataCache#dump}
*/
DataView.prototype.dump = function(opt_options) {
	this._rebuildRowIdsFromChildren();
	var rids = this._getRids();

	return DataCache.constructTable(this.getMultipleRowData(rids), opt_options, rids);
};
/** Print current data and structure to console panel
* @public
* @param {Object=} opt_options
* @example
// Options have the following format:
// {
//  "colNames": Array.&lt;string&gt;,
//  "rowCount": number,
//  "startIndex": number,
//  "getter": function(Object, string):*,
//  "withRowIds": boolean
//}
dv.log({"rowCount": 10}); // Showing 10 records
dv.log({"getter": function(rowData, colName){
	var complexData = rowData[colName];
	return complextData.someProperty;
}});
*/
DataView.prototype.log = function(opt_options) {
	console.table(this.dump(opt_options));
};


/** @private
* @return {!Array.&lt;string&gt;}
*/
DataView.prototype._getRids = function() {
	return this._expansionView || this._pageView || this._groupView || this._rids;
};

/** @private
* @param {Array.&lt;string&gt;=} opt_rowIds Provide this parameter to avoid unnecessary group filtering
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
*/
DataView.prototype._updateRowIds = function(opt_rowIds) {
	this._groupViewDirty = false;
	if(!this._parent || this._hidden) {
		this._resetAllViews();
		return;
	}
	if(this._shared.stalledRids) { // The stalled view cannot be changed
		return;
	}

	// Perform the following sequences: parent view cloning &gt;&gt; row hiding &gt;&gt; row filtering &gt;&gt; row grouping &gt;&gt; sorting &gt;&gt; paging
	this._rids = opt_rowIds || this._parent.getAllRowIds(); // Get all data ids

	if(this._hiddenRids) {
		this._removeArrayItems(this._rids, this._hiddenRids);
	}
	var segments = this._dt._getSegmentSeparators();
	this._collapsedRids = null;
	var filterExceptions = null;
	if(segments) {
		filterExceptions = segments.getSegments(); // Segment separators should not be filtered out (hidden)
		var collapsedRows = this._collapsedRids = segments.getCollapsedRows(); // Children of collapsed segments must be filtered out (hidden)
		if(collapsedRows) {
			this._removeArrayItems(this._rids, collapsedRows);
		}
	}

	this._dispatch("beforeFiltering", {});
	this._quickFilter(this._userFilter, this._filteringOut, filterExceptions);

	if(this._groupLevel &gt; 0 &amp;&amp; !opt_rowIds) {
		this._quickFilter(this._groupFilterLogic, false); // Filter In
	}

	if(this._groupMembers) { // Has grouping
		this._populateGroups(); // View will be properly re-populate inside _populateGroups()
	} else { // No grouping
		var pageIndexChanged = this._updatePageCount();
		var sorted = this._sort();
		if(!sorted &amp;&amp; !pageIndexChanged) {
			this._transformView();
		}
	}
};
/** @private
* @param {Object} e
*/
DataView.prototype._onDataChanged = function (e) {
	if (this._conflator.conflate(e)) return;

	var events = this._conflator.popAllData() || [e];

	// process all events
	var eventsCount = events.length;
	if (eventsCount === 1) {
		var event = events[0];
		if (event["globalChange"]) {
			this._updateRowIds(); // Reset all row ids and perform sorting
			this._dispatchDataChange(e);
			return;
		}

		var type = event["type"];
		if (type === "inserted") {
			this._onRowInserted(event);
		} else if (type === "removed") {
			this._onRowRemoved(event);
		} else {
			this._onRowUpdated(event);
		}
	} else {
		// multi event should occur globalchange
		this._updateRowIds();  // Reset all row ids and perform sorting
		var positionChangeOnly = true;
		for (var i = 0; i &lt; eventsCount; i++) {
			if (!events[i].positionChangeOnly) {
				positionChangeOnly = false;
				break;
			}
		}
		this._dispatchDataChange({
			"globalChange": true,
			"positionChangeOnly": positionChangeOnly,
			"events": events
		});
	}
};
/** @private
* @param {!Object} e
* @return {number} 1 if there is any change, zero otherwise.
*/
DataView.prototype._onRowInserted = function(e) { // onInsert
	if(this._shared.stalledRids) {
		return 0;
	}

	if(this.isRowFiltered(e["rid"], e["rowData"])) {
		return 0;
	}

	var ret = 0;
	if(this._groupMembers) {
		var gids = this._resolveGroupId(e["rowData"]);
		var groupLen = gids.length;
		if(groupLen &gt; 1) {
			// activate multi-group row mode
			this._shared.multiGroupRow = true;
		}
		var gid;
		for(var i = 0; i &lt; groupLen; i++) {
			gid = gids[i];
			if(this._groupMembers[gid]) { // Insert to existing member
				ret = this._groupMembers[gid]._onRowInserted(e);
			} else {
				var member = this._addGroup(gid);
				if(member) {
					e["globalChange"] = true;
					member._onRowInserted(e);
					ret = 1;
				}
			}
		}
		if(e["globalChange"]) {
			this._groupViewDirty = true;
		}
	}

	if(this._hidden) {
		return ret; // the view is hidden and there is no need to be updated
	}

	var rid = e["rid"];
	var rowData = e["rowData"];

	if(!this._isAllowedInGroup(rid, rowData)) {
		return ret;
	}

	var nextRid = /** @type{string} */(e["nextRid"]);
	var rowIndex;
	if(this.isSorting() &amp;&amp; !e["segmentChanged"]) {
		rowIndex = this._addDataRow(rid);
	} else {
		rowIndex = this._addDataRow(rid, nextRid, e["fallback"]);
	}

	var pageIndexChanged = this._updatePageCount();
	var sorted = this._sort();
	if(sorted) {
		e["globalChange"] = true; // Notify parent
	}
	if(e["globalChange"]) {
		if(!sorted &amp;&amp; !pageIndexChanged) {
			this._transformView();
		}
	} else {
		e = { // Slow
			"rid": rid,
			"rowData": rowData,
			"type": "inserted"
		};
		if(nextRid != null) {
			e["nextRid"] = nextRid;
			e["fallback"] = rowIndex;
		}
		if(this._transformView(rowIndex)) {
			e["globalChange"] = true;
		}
	}
	this._dispatchDataChange(e);

	return 1;
};
/** @private
* @param {!Object} e
* @return {number}
*/
DataView.prototype._onRowRemoved = function(e) { // onRemove
	if(this._shared.stalledRids) {
		return 0;
	}

	if(e["segmentChanged"] &amp;&amp; this.isSorting()) {
		this._refreshAndNotify();
		return 1; // may not be a correct number
	}

	var removeCount = 0;
	var rids = e["rids"];
	var i;
	if(this._groupMembers) {
		var rowData = e["rowData"];
		var groupIds, groupId;
		if(!rids &amp;&amp; rowData) {
			groupIds = this._resolveGroupId(rowData);
			for(i = 0; i &lt; groupIds.length; i++) {
				groupId = groupIds[i];
				if(this._groupMembers[groupId]) { // remove existing member
					removeCount += this._groupMembers[groupId]._onRowRemoved(e);
				}
			}

			// should allow rebuilding because rows which the same rid were removed from many groups
			// sectionSetting will not know the proper changed row index
			if(removeCount &gt; 1) {
				this._groupViewDirty = true;
			}
		} else {
			var len = this._groupList.length;
			for(i = 0; i &lt; len; ++i) {
				groupId = this._groupList[i];
				removeCount += this._groupMembers[groupId]._onRowRemoved(e);
			}
		}
	}

	var firstModifiedIndex = NaN;
	var removedRids = null;
	var rid, at;

	// TODO: Change removal mechanism to object map based logic to speed up the process
	removeCount = 0;
	if(rids) {
		removedRids = [];
		for(i = rids.length; --i &gt;= 0;) {
			rid = rids[i];
			at = this._removeDataRow(rid);
			if(at &gt;= 0) {
				removedRids.push(rid);
				if(!(at &gt;= firstModifiedIndex)) {
					firstModifiedIndex = at;
				}
			}
		}
		removeCount = removedRids.length;
	} else {
		rid = e["rid"];
		at = this._removeDataRow(rid);
		if(at &gt;= 0) {
			removedRids = [rid];
			firstModifiedIndex = at;
			removeCount = 1;
		}
	}
	if(removeCount &gt; 0) {
		// No sorting is required, since no order should be changed during the removal
		var pageIndexChanged = this._updatePageCount();
		if(pageIndexChanged || this._transformView(firstModifiedIndex)) {
			this._dispatchGlobalChange();
		} else {
			this._dispatchMultiRowRemoved(removedRids);
		}
		if(this._shared.autoGroupRemoval &amp;&amp;
			this._groupRows &amp;&amp;
			this._rids.length &lt;= 0) {
			this._triggerGroupRefreshing(); // Set a timer to refresh group view
		}
		if (this._hiddenHeaderRow) { // If the first row is removed while th group is collapsing, the next row should take place.
			this._requestRebuildingRowIds(true); // TODO: Optimize
		}
	}
	return removeCount;
};
/** @private
* @param {!Object} e
* @return {number}
*/
DataView.prototype._onRowUpdated = function(e) { // onUpdate
	var rid = e["rid"];
	var rowData = e["rowData"];
	var i, gid;
	if(this.isRowFiltered(rid, rowData)) { // The row is qualified but it is filtered out
		if(this._onRowRemoved(e)) {
			return 1;
		}
		return 0; // The row does not belong to this view
	}

	if(this._groupMembers) {
		var flags = [];
		var len = this._groupList.length;
		for(i = 0; i &lt; len; ++i) {
			gid = this._groupList[i];
			flags[this._groupMembers[gid]._onRowUpdated(e)] = true;
		}

		if(e["globalChange"]) { // If current dataView is sorting, globalChange will always be true
			this._groupViewDirty = true;
		}

		// conclude flag
		var processingFlag = 0;
		if(flags[2]) {
			processingFlag = 2;
		} else if(flags[1]) {
			if(!this._isAllowedInGroup(rid, rowData)) {
				processingFlag = 1;
			}
		} else if(flags[4]) {
			processingFlag = 4;
		}

		if(this._groupLevel &gt; 0) {
			if(processingFlag === 1) { // The row is moved to the other group
				if(this._removeArrayItem(this._rids, rid) &gt;= 0) {
					if(this._groupView) {
						this._removeArrayItem(this._groupView, rid);
					}
				}
				if(this._shared.multiGroupRow) {
					this._groupViewDirty = true;
				}
			} else if(processingFlag === 2) { // The row is added to its sub-group
				if(!this._hidden) {
					if(this._rids.indexOf(rid) &lt; 0) {
						this._rids.push(rid);
					}

					this._groupViewDirty = true; // Adding row to sub-group both single and multiple-group require parent group to rebuild rows

					var groupLen = this._resolveGroupId(rowData).length;
					if(groupLen &gt; 1) {
						// activate multi-group row mode
						this._shared.multiGroupRow = true;
					}
				}
			}
		} else { // This is the root node
			var noNewGroup = (flags[1] &amp;&amp; flags[2]) || flags[4];
			if(this._shared.multiGroupRow || !noNewGroup) {
				// 0 - updated data from non-existing group to new group
				// 1 - updated data from existing group to new group
				// 2 - updated data from a non-existing group to existing group
				// 3 - updated data from a existing group to another existing group
				// 4 - updated data with in a single group and no group member changed
				var gids = this._resolveGroupId(rowData);
				for(i = 0; i &lt; gids.length; i++) {
					gid = gids[i];
					var member = this._addGroup(gid); // Add header row
					if(member) {
						member._onRowInserted(e);
						processingFlag = 1;
					}
				}
			}

			if(!noNewGroup &amp;&amp; !this._hidden &amp;&amp; this._rids.indexOf(rid) &lt; 0) {
				this._addDataRow(rid);
			}

			if(processingFlag === 4) {
				if(this._shared.multiGroupRow) {
					this._dispatchGlobalChange();
				} else {
					this._dispatchDataChange(e);
				}
			} else {
				this._groupViewDirty = true;
				this._dispatchGlobalChange();
			}
		}
		return processingFlag;
	}

	// recursive task for leaf group
	if(this._isAllowedInGroup(rid, rowData)) {
		var newRowIndex = this._rids.indexOf(rid);
		if(newRowIndex &lt; 0) { // The row is qualified to be in the group, but not in the current view, so insert the row
			this._onRowInserted(e);
			return 2;
		}

		// Perform normal data updating
		if (!this._shared.stalledRids) { // Stalled view cannot be sorted
			if(this._sort()) {
				e["globalChange"] = true;
			}
		}

		this._dispatchDataChange(e);
		return 4; // Update is within the group
	} else {
		if(this._onRowRemoved(e)) {
			return 1;
		}
		return 0; // The row does not belong to this view
	}
};
/** @private
* @param {!Object} e
*/
DataView.prototype._onGroupAdded = function(e) {
	if(!this._hidden) {
		var newGroup = /** @type{DataView} */(e["newGroup"]);
		var rid = newGroup.getGroupRowId();
		this._groupView.push(rid); // Add header row
		this._groupViewDirty = true;
		this._dispatch("groupAdded", e);

		DataView._pushItems(this._groupView, newGroup.getFooterRowIds());
	}
};
/** @private
* @param {!Object} e
*/
DataView.prototype._onBeforeGroupAdded = function(e) {
	this._dispatch("beforeGroupAdded", e);
};
/** NOTE: This is not handle well in case of calling this function infinitely
 * @private
* @param {boolean} bottomUp
*/
DataView.prototype._requestRebuildingRowIds = function(bottomUp) {
	if(this._groupMembers) {
		this._groupViewDirty = true;
	}
	if(this._groupLevel &gt; 0) {
		this._parent._requestRebuildingRowIds(bottomUp);
	} else {
		if(bottomUp) { // Regenerate row Ids from children. Use when something is changed and can be resolved from the requester.
			this._rebuildRowIdsFromChildren();
		} else { // Use when something is changed in the hierarchy tree but cannot be resolved by any of the children. Root view then repopulates the entire tree (slow).
			this._updateRowIds();
		}
		this._dispatchGlobalChange();
	}
};
/** There should be no other operation after calling this method
* @private
*/
DataView.prototype._refreshAndNotify = function() {
	this._updateRowIds();
	this._dispatchGlobalChange();
};
/** @private
*/
DataView.prototype._onRefreshTimeout = function() {
	this._refreshTimerId = 0;
	this._refreshAndNotify();
};

/** @private
* @param {string} rid
* @param {string=} opt_nextRid
* @param {number=} opt_fallback
* @return {number}
*/
DataView.prototype._addDataRow = function(rid, opt_nextRid, opt_fallback) {
	var rowIndex = this._getRowIndex(this._rids, opt_nextRid, opt_fallback);
	this._insertItems(this._rids, rowIndex, rid);
	if(this._groupView) {
		if(this._groupMembers) {
			this._groupViewDirty = true;
			return this._insertItems(this._groupView, -1, rid);
		} else if(rowIndex &lt; 0) { // No nextRid, No fallback
			return this._insertItems(this._groupView, -1, rid);
		}

		rowIndex = this._getRowIndex(this._groupView, opt_nextRid, opt_fallback);
		return this._insertItems(this._groupView, rowIndex, rid);
	}

	return (rowIndex &gt;= 0) ? rowIndex : this._rids.length - 1;
};
/** @private
* @param {Array.&lt;string&gt;} ary
* @param {number} idx
* @param {string} item1
* @return {number} Return the first position of the inserted item
*/
DataView.prototype._insertItems = function(ary, idx, item1) {
	if(idx &lt; 0){
		idx = ary.length;
		ary.push(item1);
	} else {
		ary.splice(idx, 0, item1);
	}
	return idx;
};
/** @private
* @param {Array.&lt;string&gt;} rids
* @param {string=} opt_nextRid
* @param {number=} opt_fallback Fallback index in case of no nextRid found
* @return {number} Return negative number if not found
*/
DataView.prototype._getRowIndex = function(rids, opt_nextRid, opt_fallback) {
	if(opt_nextRid == null) {
		return -1;
	}

	var rowIndex = this._rids.indexOf(opt_nextRid);
	if(rowIndex &gt;= 0) {
		return rowIndex;
	}

	if(opt_fallback == null || opt_fallback &gt;= rids.length) {
		return -1;
	}
	return /** @type{number} */(opt_fallback);
};
/**
* @private
* @param {string} rid
* @returns {number}
*/
DataView.prototype._removeDataRow = function(rid) {
	var at = this._removeArrayItem(this._rids, rid);
	if(this._groupView &amp;&amp; at &gt;= 0) {
		at = this._removeArrayItem(this._groupView, rid);
	}
	return at;
};
/** @private
* @param {Array} ary
* @param {*} item
* @return {number} Index of the removed item
*/
DataView.prototype._removeArrayItem = function(ary, item) {
	var len = ary.length;
	for(var i = 0; i &lt; len; ++i) {
		if(ary[i] === item) {
			ary.splice(i, 1);
			return i;
		}
	}
	return -1;
};
/** Remove multiple array items
* @private
* @param {Array.&lt;string&gt;} ary
* @param {Object.&lt;string, *&gt;} items
* @return {number} First item index that is being removed. NaN if no item is removed
*/
DataView.prototype._removeArrayItems = function(ary, items) {
	var f = NaN;
	var c = 0;
	for(var i = ary.length; --i &gt;= 0;) {
		if (items[ary[i]]) {
			++c;
		} else if(c) {
			f = i + 1;
			ary.splice(f, c);
			c = 0;
		}
	}
	if(c) {
		ary.splice(0, c);
		f = 0;
	}
	return f;
};
/** @private
* @param {string|null} rid
* @param {Object} rowData
* @return {boolean}
*/
DataView.prototype._isAllowedInGroup = function(rid, rowData) {
	// Check if it the row is belong to this group branch
	if(this._groupLevel &gt; 0) {
		var dv = this;
		for(var i = this._groupLevel; --i &gt;= 0;) {
			if(!dv._groupFilterLogic(rid, rowData)) {
				return false;
			}
			dv = dv.getDataSource();
		}
	}

	return true; // The row is in this group
};
/** Check if the row should be filtered out
* @public
* @param {string} rid
* @param {Object} rowData
* @return {boolean}
*/
DataView.prototype.isRowFiltered = function(rid, rowData) {
	if(this._shared.stalledRids) {
		return !this._shared.stalledRids[rid]; // Snapshot override everything else
	}
	if(this._hiddenRids) {
		if(this._hiddenRids[rid]) {
			return true;
		}
	}
	if(this.isSegmentSeparator(rid)) {
		return false; // Segment separator cannot be filtered
	}
	if(this._collapsedRids) {
		if(this._collapsedRids[rid]) {
			return true;
		}
	}

	if(this._userFilter) {
		if(this._userFilter(rid, rowData) === this._filteringOut) {
			return true;
		}
	}
	return false; // The row is not filtered out
};

/** Performance is extremely vital in this method.&lt;br&gt;
* _sort() will be executed by: _onRowUpdated(), _onRowInserted(), _updateRowIds(), and sort()
* @private
* @return {boolean} True if there is any change, otherwise false
*/
DataView.prototype._sort = function() {
	if(this._groupMembers) {
		return false; // DataView with children should not be sorted as sort operation will be done on each child
	}

	if(this._dt._getSegmentSeparators() || this.isSorting()) {
		var rids = this._rids;
		var dataRows = this._dt.getMultipleRowData(rids);
		var segmentValues = this._dt.getSegmentValues(rids);
		var change = DataTable._performMultiLevelSorting(dataRows, this._sortingDefs, segmentValues);

		if(change) {
			this._rids = DataTable._reorderItems(rids, change); // Group view should be changed after this
			this._transformView();
			return true;
		}
	}

	return false;
};

/** @private
* @param {Function} checker
* @param {boolean} filteringOut
* @param {Object=} exceptions
*/
DataView.prototype._quickFilter = function(checker, filteringOut, exceptions) {
	if(!checker) {
		return;
	}

	var rids = this._rids; // Make local variable to speed up the process
	var len = rids.length;
	var dt = this._dt;
	var spliceCount = 0;
	for(var i = len; --i &gt;= 0;) {
		var rid = rids[i];
		var removed = false;
		if(!exceptions || !exceptions[rid]) {
			var values = dt.getRowData(rid);
			if (values) {
				removed = checker(rid, values) === filteringOut;
			} else {
				removed = true;
			}
		}
		if(removed) {
			++spliceCount;
		} else if(spliceCount &gt; 0) {
			rids.splice(i + 1, spliceCount);
			spliceCount = 0;
		}
	}
	if(spliceCount &gt; 0) {
		rids.splice(0, spliceCount);
	}
};
/** @private
* @param {string|Function|undefined} cid
* @param {*} value
* @return {Function} A new function object is created, if cid is a string
*/
DataView.prototype._getFilterLogic = function(cid, value) {
	if(cid != null) {
		if(typeof cid == "function") {
			return cid;
		} else if(typeof cid == "string") {
			return DataView._defaultFilterLogic.bind(null, cid, value);
		} else {
			return DataView._defaultFilterLogic.bind(null, cid + "", value);
		}
	}
	return null;
};

/**
* @private
* @param {number} pageIndex
* @return {boolean} True if there is any change, otherwise false
* @fires DataView#pageIndexChanged
*/
DataView.prototype._setPage = function (pageIndex) {
	if (pageIndex &gt; this._lastPageIndex &amp;&amp; this._pageCorrection) {
		pageIndex = this._lastPageIndex;
	}
	if (pageIndex &lt; 1) {
		pageIndex = 1;
	}

	if (pageIndex == this._pageIndex) {
		return false;
	}

	this._pageIndex = pageIndex;
	this._transformView();
	this._dispatch("pageIndexChanged", {"pageIndex": this._pageIndex});
	return true;
};
/** @private
* @param {number=} firstChange Negative value is equivalent to 0
* @return {boolean} Return true if there is any change, otherwise false
*/
DataView.prototype._updatePaginationView = function(firstChange) {
	var dirty = false;
	if(this._pageView) {
		if(!firstChange) { firstChange = 0; }

		var pageStart = this._pageSize * (this._pageIndex - 1);

		var pageEnd = this._pageSize + pageStart;
		if(firstChange &lt; pageEnd) { // The change happens before current page
			var rids = this._groupView || this._rids;
			if (pageEnd &gt; rids.length) { // Shrink view if the last page is not a full page
				pageEnd = rids.length;
			}

			// Populate the page
			var ridsLen = pageEnd - pageStart;
			this._pageView.length = (ridsLen &gt;= 0) ? ridsLen : 0;
			for(var i = pageStart; i &lt; pageEnd; ++i) {
				this._pageView[i - pageStart] = rids[i];
			}
			dirty = true;
		}
	}
	return dirty;
};

/** WARNING: _transformView() may be called due to page index changed
* @private
* @return {boolean} Return true if page index is changed
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
*/
DataView.prototype._updatePageCount = function () {
	var lastPageIndex = 1;
	if (this._pageSize &gt; 0) {
		var rows = this._groupView || this._rids;
		var rowCount = (rows.length &gt; 0) ? rows.length : 0;
		lastPageIndex = Math.ceil(rowCount / this._pageSize);
	}
	if(this._lastPageIndex !== lastPageIndex) {
		this._lastPageIndex = lastPageIndex;
		this._dispatch("pageCountChanged", {"pageCount": this._lastPageIndex});

		if(this._lastPageIndex &lt; this._pageIndex &amp;&amp; this._pageCorrection) {
			return this._setPage(this._lastPageIndex);
		}
	}
	return false;
};

/** @private
* @param {string} rid
*/
DataView.prototype._dispatchRowRemoved = function(rid) {
	if(rid) {
		this._dispatchDataChange({"type": "removed", "rid": rid});
	}
};
/** @private
* @param {Array.&lt;string&gt;} rids
*/
DataView.prototype._dispatchMultiRowRemoved = function(rids) {
	if(rids) {
		var count = rids.length;
		if(count === 1) {
			this._dispatchRowRemoved(rids[0]);
		} else if(count &gt; 1) {
			this._dispatchDataChange({"type": "removed", "rids": rids});
		}
	}
};
/** @private
*/
DataView.prototype._dispatchGlobalChange = function() {
	this._dispatchDataChange(DataTable._globalChangeArg);
};
/** @private
* @param {!Object} evtArgument
*/
DataView.prototype._dispatchDataChange = function(evtArgument) {
	this._dispatch("dataChanged", evtArgument);
};

/** @private
* @param {DataTable|DataView} source
*/
DataView.prototype._setParent = function (source) {
	this._parent = source;
	this._dt = /** @type{DataTable} */(source);
	do {
		source = source.getDataSource();
		if(source) {
			this._dt = /** @type{DataTable} */(source);
		}
	} while(source);

	if(this._parent &amp;&amp; this._dt !== this._parent) { // Copy shared member from parent data view
		this._shared = this._parent._shared;

		var cids = this._parent._columnStats;
		if(cids) {
			for(var cid in cids) {
				var cs = this.enableColumnStats(cid);
				var pcs = this._parent.getColumnStats(cid);
				if(cs &amp;&amp; pcs) {
					cs.setColumnDataGetter(pcs.getColumnDataGetter());
				}
			}
		}
	}
};

/** @private
*/
DataView.prototype._populateGroups = function () {
	var initialRids = this._rids;
	var i, len, member;
	this._rids = [];

	// Collect members of each group from the available data
	var groupId, groupIds, groupLen;
	var ridMap = {};
	var groupList = [];
	len = initialRids.length;
	for(i = 0; i &lt; len; ++i) {
		var rid = initialRids[i];
		var rowData = this._dt.getRowData(rid);
		if(rowData) {
			groupIds = this._resolveGroupId(rowData);
			groupLen = groupIds.length;
			if(groupLen &gt; 1) {
				// activate multi-group row mode
				this._shared.multiGroupRow = true;
			}
			for(var j = 0; j &lt; groupLen; j++) {
				groupId = groupIds[j];
				var groupedRids = ridMap[groupId];
				if(groupedRids) {
					groupedRids.push(rid);
				} else {
					groupedRids = [rid];
					ridMap[groupId] = groupedRids;
					groupList.push(groupId);
				}
			}
		}
	}

	// Remove groups that have no member
	if(this._shared.autoGroupRemoval) {
		len = this._groupList.length;
		for(i = len; --i &gt;= 0;) {
			groupId = this._groupList[i];
			if(!ridMap[groupId]) { // No member exists
				member = this._groupMembers[groupId];
				if(member &amp;&amp; !member._predefinedGroup) { // Predefined group should not be removed automatically
					this._removeGroupMember(i, groupId);
				}
			}
		}
	}
	// Remove any non existing predefined groups
	var preDefGroups = null;
	if(this._preDefGroups &amp;&amp; this._groupLevel &lt; this._preDefGroups.length) {
		preDefGroups = this._preDefGroups[this._groupLevel];
	}

	len = this._groupList.length;
	if(this._preDefGroupsDirty) {
		this._preDefGroupsDirty = false;
		for(i = len; --i &gt;= 0;) {
			groupId = this._groupList[i];
			member = this._groupMembers[groupId];
			if(member &amp;&amp; member._predefinedGroup) {
				// TODO: Handle the case where predefined groups exist in normal groupList
				if(preDefGroups) {
					if(preDefGroups.indexOf(member._groupId) &lt; 0) {
						this._removeGroupMember(i, groupId);
					}
				} else {
					this._removeGroupMember(i, groupId);
				}
			}
		}
	}


	// Add predefined groups first, allowing user to initially order the groups
	if(preDefGroups) {
		len = preDefGroups.length;
		for(i = 0; i &lt; len; ++i) {
			var pdg = this._addGroup(preDefGroups[i]);
			if(pdg) {
				pdg._predefinedGroup = true;
			}
		}
	}
	// Add normal group
	len = groupList.length;
	for(i = 0; i &lt; len; ++i) {
		this._addGroup(groupList[i]);
	}

	// Add row Id
	len = this._groupList.length;
	for(i = 0; i &lt; len; ++i) { // Re-distribute this object content to all of its group members
		groupId = this._groupList[i];
		member = this._groupMembers[groupId];
		member._updateRowIds(ridMap[groupId]); // member will be sorted individually
		member._markColumnStatsDirty(); // Since there is no event fired for child members
	}

	this._groupViewDirty = true;
	this._rebuildRowIdsFromChildren();
};
/** @private
* @param {number} groupIndex
* @param {string} groupId
*/
DataView.prototype._removeGroupMember = function (groupIndex, groupId) {
	var member = this._groupMembers[groupId];
	if(member) {
		this._groupList.splice(groupIndex, 1);
		delete this._groupMembers[groupId];

		member.dispose(); // Clear everything. Note that this will call groupBy(null);
	}
};
/** @private
* @param {string} cid
* @param {Object.&lt;string, *&gt;} values
* @return {Array.&lt;string&gt;}
*/
DataView.prototype._defaultGroupCriteria = function(cid, values) {
	var val = values[cid];
	if(Array.isArray(val)) {
		return val.map(function(data) {
			return data + "";
		});
	} else {
		return [val + ""];
	}
};
/** @private
* @param {string|null} rid
* @param {Object.&lt;string, *&gt;} values
* @return {boolean}
*/
DataView.prototype._groupFilterLogic = function(rid, values) {
	var gids = this._groupCriteria[this._groupLevel - 1](values);
	return gids.indexOf(this._groupId) &gt;= 0;
};

/** @private
* @param {string} strA
* @param {string} strB
* @return {number}
*/
DataView.prototype._internalGroupSortingLogic = function(strA, strB) {
	var dvA = this._groupMembers[strA];
	var dvB = this._groupMembers[strB];

	return this._groupSortingLogic(strA, strB, dvA, dvB);
};

/** @private
* @param {*} value
* @return {DataView} Newly added group member. If it already exists, this method returns null.
*/
DataView.prototype._addGroup = function (value) {
	var groupId = value + "";
	if(!groupId) {
		// window.console.log("WARNING: Group Id cannot be an empty string");
		return null;
	}
	var member = this._groupMembers[groupId];
	if(member) {
		return null;
	}
	var parentGrpRowId = this._groupRowId || "_grp";
	var newGrpRowId = parentGrpRowId + "_" + groupId;
	var arg;
	if(this._hasListener("beforeGroupAdded")) {
		arg = {
			"dataView": this, // parent
			"newGroupId": groupId,
			"newGroupValue": value,
			"newGroupRowId": newGrpRowId,
			"newGroupLevel": this._groupLevel + 1
		};
		this._dispatch("beforeGroupAdded", arg);
		if(arg["cancel"]) {
			return null;
		}
	}
	member = new DataView();
	member._groupId = groupId;
	if(typeof value == "string") { // TODO: Raw value should not always be a string
		if(value == "null") {
			member._groupValue = null;
		} else if(value != "undefined") {
			member._groupValue = value;
		} // else { value is undefined string
	} else {
		member._groupValue = value;
	}

	if (arg &amp;&amp; arg["hideHeaderRow"] === true) {
		member._hiddenHeaderRow = true;
	}

	member._groupRowId = newGrpRowId;
	member._groupLevel = this._groupLevel + 1;
	member._groupCriteria = this._groupCriteria; // Shared Member
	member._preDefGroups = this._preDefGroups;
	if(member._groupLevel &lt; member._groupCriteria.length) {
		member._groupMembers = {};
		member._groupList = [];
		member._groupView = [];
	}
	member._groupRows = this._groupRows; // Shared Member
	member._setParent(this);
	member._sortingDefs = this._sortingDefs; // Shared Member

	this._groupMembers[groupId] = member;
	this._groupList.push(groupId);
	this._groupRows.setData(member._groupRowId, "DataView", member);

	if(!this._hidden) {
		if (member._isHeaderRowShown()) {
			this._groupView.push(member._groupRowId); // Add header row
		}

		this._groupViewDirty = true;
		member._beingAdded = true;
		this._dispatch("groupAdded", {
			"dataView": this,
			"newGroup": member
		});
		member._beingAdded = false;
	}

	member.listen("groupAdded", this._onGroupAdded);
	if(this._hasListener("beforeGroupAdded")) {
		member.listen("beforeGroupAdded", this._onBeforeGroupAdded);
	}
	return member;
};
/** @private
*/
DataView.prototype._triggerGroupRefreshing = function () {
	if(this._groupLevel &gt; 0) {
		if(this._parent) {
			this._parent._triggerGroupRefreshing();
		}
	} else if(this._groupRows &amp;&amp; !this._refreshTimerId) {
		this._refreshTimerId = setTimeout(this._onRefreshTimeout, 100);
	}
};
/** @private
* @fires DataView#pageCountChanged
* @fires DataView#pageIndexChanged
*/
DataView.prototype._rebuildRowIdsFromChildren = function () {
	if(!this._groupViewDirty) {
		return;
	}

	this._rids.length = 0;
	if(this._groupView) { this._groupView.length = 0; }
	if(!this._hidden) {
		var grpLen = this._groupList.length;
		for(var i = 0; i &lt; grpLen; ++i) { // Re-distribute this object content to all of its group members
			var gid = this._groupList[i];
			var member = this._groupMembers[gid];
			member._rebuildRowIdsFromChildren();

			DataView._pushItems(this._rids, member._rids);

			if(!this._collapsed &amp;&amp; this._groupView) {
				if (member._isHeaderRowShown()) {
					this._groupView.push(member._groupRowId); // Add header row
				}
				if(!member._collapsed) { // WARNING: This gives different value from isCollapsed() method
					var rids = member._getFirstHiddenRids() || member._groupView || member._rids;
					DataView._pushItems(this._groupView, rids);
					DataView._pushItems(this._groupView, member._footerRowIds);
				}
			}
		}
	}
	this._groupViewDirty = false;

	// View has been re-created. So we need to add row expansion
	if(!this._updatePageCount()) {
		this._transformView();
	}
};
/** @private
* @param {Object} rowData
* @return {Array.&lt;string&gt;}
*/
DataView.prototype._resolveGroupId = function (rowData) {
	return /** @type{Array.&lt;string&gt;} */(this._groupCriteria[this._groupLevel](rowData));
};

/** @private
*/
DataView.prototype._markColumnStatsDirty = function() {
	for(var cid in this._columnStats) {
		this._columnStats[cid].markDirty();
	}
};

/** @private
* @param {Array} ary
* @param {Array} items
* @return {Array}
*/
DataView._pushItems = function(ary, items) {
	var len = items ? items.length : 0;
	if(len &gt; 0) {
		if(len &lt; 1e5) { // Maximum number of arguments that the spread operator can take is exactly 125052
			if(len &gt; 1) {
				Array.prototype.push.apply(ary, items);
			} else {
				ary.push(items[0]);
			}
		} else {
			var start = 0;
			var end = 0;
			while(start &lt; len) {
				end += 1e5;
				Array.prototype.push.apply(ary, items.slice(start, end));
				start = end;
			}
		}
	}
	return ary;
};

/** @private
* @function
* @param {string} cid
* @param {*} value
* @param {string} rid
* @param {Object.&lt;string, *&gt;} values
* @return {boolean}
*/
DataView._defaultFilterLogic = function(cid, value, rid, values) {
	return (values[cid] === value);
};
/** @private
* @function
* @param {string} strA
* @param {string} strB
* @return {number}
*/
DataView._defaultGroupSortingLogic = function(strA, strB) {
	if(strA == strB) {
		return 0;
	}
	return (strA &lt; strB) ? -1 : 1;
};

DataView._proto = DataView.prototype;

export default DataView;
export { DataView };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="ElementFrameWork.html">ElementFrameWork</a></li><li><a href="Util.html">Util</a></li></ul><h3>Classes</h3><ul><li><a href="Cell.html">Cell</a></li><li><a href="CellFloatingPanel.html">CellFloatingPanel</a></li><li><a href="CellSpan.html">CellSpan</a></li><li><a href="CellSpans.html">CellSpans</a></li><li><a href="ColumnStats.html">ColumnStats</a></li><li><a href="Conflator.html">Conflator</a></li><li><a href="DataCache.html">DataCache</a></li><li><a href="DataTable.html">DataTable</a></li><li><a href="DataView.html">DataView</a></li><li><a href="DragAndDropTitlePlugin.html">DragAndDropTitlePlugin</a></li><li><a href="ElementWrapper.html">ElementWrapper</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="EventListeners.html">EventListeners</a></li><li><a href="Grid.html">Grid</a></li><li><a href="HScrollbar.html">HScrollbar</a></li><li><a href="HttpRequest.html">HttpRequest</a></li><li><a href="LayoutGrid.html">LayoutGrid</a></li><li><a href="PercentBar.html">PercentBar</a></li><li><a href="PercentBarRenderer.html">PercentBarRenderer</a></li><li><a href="Plugin.html">Plugin</a></li><li><a href="RangeBar.html">RangeBar</a></li><li><a href="Reverter.html">Reverter</a></li><li><a href="Scrollbar.html">Scrollbar</a></li><li><a href="SectionSettings.html">SectionSettings</a></li><li><a href="Segment.html">Segment</a></li><li><a href="SegmentCollection.html">SegmentCollection</a></li><li><a href="SortableTitlePlugin.html">SortableTitlePlugin</a></li><li><a href="Virtualizer.html">Virtualizer</a></li><li><a href="VScrollbar.html">VScrollbar</a></li></ul><h3>Interfaces</h3><ul><li><a href="ILayoutGrid.html">ILayoutGrid</a></li></ul><h3>Events</h3><ul><li><a href="DataCache.html#event:dataChanged">dataChanged</a></li><li><a href="DataCache.html#event:dataComposed">dataComposed</a></li><li><a href="DataTable.html#event:dataChanged">dataChanged</a></li><li><a href="DataTable.html#event:dataComposed">dataComposed</a></li><li><a href="DataView.html#event:beforeFiltering">beforeFiltering</a></li><li><a href="DataView.html#event:beforeGroupAdded">beforeGroupAdded</a></li><li><a href="DataView.html#event:dataChanged">dataChanged</a></li><li><a href="DataView.html#event:groupAdded">groupAdded</a></li><li><a href="DataView.html#event:groupCriteriaChanged">groupCriteriaChanged</a></li><li><a href="DataView.html#event:pageCountChanged">pageCountChanged</a></li><li><a href="DataView.html#event:pageIndexChanged">pageIndexChanged</a></li><li><a href="DataView.html#event:preDisposed">preDisposed</a></li><li><a href="DragAndDropTitlePlugin.html#event:columnMoved">columnMoved</a></li><li><a href="DragAndDropTitlePlugin.html#event:dragged">dragged</a></li><li><a href="Grid.html#event:columnAdded">columnAdded</a></li><li><a href="Grid.html#event:columnRemoved">columnRemoved</a></li><li><a href="Grid.html#event:columnVisibilityChanged">columnVisibilityChanged</a></li><li><a href="Grid.html#event:dataSourceChanged">dataSourceChanged</a></li><li><a href="Grid.html#event:postSectionDataBinding">postSectionDataBinding</a></li><li><a href="Grid.html#event:rowExpansionBinding">rowExpansionBinding</a></li><li><a href="Grid.html#event:rowHighlighted">rowHighlighted</a></li><li><a href="Grid.html#event:sectionAdded">sectionAdded</a></li><li><a href="Grid.html#event:widthChanged">widthChanged</a></li><li><a href="HttpRequest.html#event:abort">abort</a></li><li><a href="HttpRequest.html#event:error">error</a></li><li><a href="HttpRequest.html#event:load">load</a></li><li><a href="HttpRequest.html#event:loadend">loadend</a></li><li><a href="HttpRequest.html#event:loadstart">loadstart</a></li><li><a href="HttpRequest.html#event:timeout">timeout</a></li><li><a href="LayoutGrid.html#event:rowCountChanged">rowCountChanged</a></li><li><a href="LayoutGrid.html#event:rowHeightChanged">rowHeightChanged</a></li><li><a href="LayoutGrid.html#event:rowHighlighted">rowHighlighted</a></li><li><a href="SortableTitlePlugin.html#event:clicked">clicked</a></li><li><a href="SortableTitlePlugin.html#event:columnSorted">columnSorted</a></li><li><a href="SortableTitlePlugin.html#event:preClicked">preClicked</a></li><li><a href="SortableTitlePlugin.html#event:preDataSorting">preDataSorting</a></li></ul><h3>Global</h3><ul><li><a href="global.html#get">get</a></li><li><a href="global.html#sortingDef%255B1%255D">sortingDef[1]</a></li></ul>
</nav>


<script src="scripts/linenumber.js"> </script>
<script src="scripts/prettify.js"> </script>
<script> prettyPrint(); </script>
</body>
</html>
