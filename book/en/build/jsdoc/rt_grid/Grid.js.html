<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Grid.js</title>

    <script src="scripts/prettify.js"> </script>
    <script src="scripts/lang-css.js"> </script>
    <!--[if lt IE 9]&gt;
      &lt;script src="//html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
    &lt;![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/default.css">
    <link type="text/css" rel="stylesheet" href="styles/elf-template.css">
</head>

<body>

<div id="main-template" class="elf-template">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable */
import { Dom } from "../../node_modules/tr-grid-util/es6/Dom.js";
import { Conflator } from "../../node_modules/tr-grid-util/es6/Conflator.js";
import { Ext } from "../../node_modules/tr-grid-util/es6/Ext.js";
import { EventDispatcher } from "../../node_modules/tr-grid-util/es6/EventDispatcher.js";
import { Engine } from "../../node_modules/tr-grid-util/es6/formula/Engine.js";
import { cloneObject, extendObject, arrayToObject, isEmptyObject, deepEqual } from "../../node_modules/tr-grid-util/es6/Util.js";
import { DateTime } from "../../node_modules/tr-grid-util/es6/DateTime.js";

import { RowDefinition, ROW_DEF } from "./RowDefinition.js";
import { ColumnDefinition, COL_DEF } from "./ColumnDefinition.js";
import SnapshotFiller from "./SnapshotFiller.js";
import StyleLoader from "./StyleLoader.js";
import FieldDefinition from "./FieldDefinition.js";
import DataConnector from "./DataConnector.js";
import RowDefSorter from "./RowDefSorter.js";

import { Core } from "../../node_modules/@grid/core/es6/grid/Core.js";
import { SortableTitlePlugin } from "../../node_modules/@grid/core/es6/grid/plugins/SortableTitlePlugin.js";
import { DataCache } from "../../node_modules/@grid/core/es6/data/DataCache.js";
import { DataTable } from "../../node_modules/@grid/core/es6/data/DataTable.js";
import { DataView } from "../../node_modules/@grid/core/es6/data/DataView.js";
import { ElementWrapper } from "../../node_modules/@grid/core/es6/grid/components/ElementWrapper.js";
/* eslint-enable */

/** @typedef {Object} Grid~SynapseConfig
* @description Configuration object that can be provided directly at the initialization phase
* @property {string} apiKey Synapse api key
* @property {string} contextApp Synapse context app name
* @property {string=} auth Synapse authen token
* @property {boolean=} debug=false If true, Synapse response will be mock
*/

/** @typedef {Object} Grid~ADCOptions
* @description ADC requesting level config from adc team
* @property {string=} productId=001 required parameter, it specifies the product for which you request data. Contact the adc staff to create one.
*/

/** @typedef {Object} Grid~GridOptions
* @description Configuration object that can be provided directly at the initialization phase
* @property {Array.&lt;ColumnDefinition~Options|string&gt;=} columns Collection of the column definitions
* @property {ColumnDefinition~Options=} defaultColumnOptions All Columns will inherit from this default object
* @property {Array.&lt;RowDefinition~Options&gt;=} rows Collection of the row definitions
* @property {Array.&lt;string&gt;=} fields Shorthand for setting fields
* @property {Array.&lt;string&gt;=} rics Shorthand for creating row definition
* @property {Array=} plugins Additional plugins for core grid (from getBlotter()/getCoreGrid())
* @property {Array=} extensions Alias to `plugins`
* @property {boolean=} scrollbar=true Enable both vertical and horizontal scrollbar in grid
* @property {boolean=} linearWheelScrolling=false If enabled, wheel scrolling will move the content linearly regardless of how long the content is (i.e. no skipping).
* @property {boolean=} stepScroll=false If enabled, a full row will be scrolled at a time instead of actual scroll value.
* @property {boolean=} autoHideScrollbar=true Fading in/out Scrollbar on hover.
* @property {string=} pageSize=0 Make grid show specified number of row
* @property {number=} rowHeight=32 Set default row height for body (content) section
* @property {number=} headerRowHeight=32 Set default row height for header section
* @property {boolean=} noColumnDragging=false All columns can be moved by dragging. If this option is true, the feature is disabled
* @property {boolean=} columnReorder=true Alias with noColumnDragging but in opposite value. This property deprecated in favor of noColumnDragging.
* @property {boolean=} rowHighlighting=true Highlight a row when hovering mouse over grid
* @property {(boolean|number)=} autoLayoutUpdate=false Grid will check for layout change periodically.
* @property {number=} columnFreezing Deprecated in favor of column's leftPinned property. Enable horizontal scrollbar after `columnFreezing` index
* @property {number=} freezeColumn Deprecated in favor of column's leftPinned property. An alias to columnFreezing
* @property {number=} pinnedRightColumns=0 Deprecated in favor of column's rightPinned property. Number of columns to be frozen/pinned on the right side.
* @property {Array=} staticDataRows Shorthand for calling {@link Grid#addStaticDataRows}
* @property {Array.&lt;string&gt;=} dataFields Shorthand for calling {@link Grid#addDataFields}
* @property {boolean=} rowVirtualization=true If disabled, all data rows will be rendered. This will greatly impact grid's performance if the data set is huge.
* @property {boolean=} columnVirtualization=false If enabled, all columns will be rendered. This will greatly impact grid's performance if the column set is huge.
* @property {(number|null|boolean)=} topFreezingCount=null If number &gt;= 0 will fix number of frozen title section, If false = disabled scrollbar, if null then title section will freeze auto when new section added, this option will not work with scrollbar option.
* @property {(number|null)=} bottomFreezingCount=null If number &gt;= 0 will fix nuber of frozen footer section, if null then footer section will freeze auto when new section added, this option will not work with scrollbar option.
* @property {boolean=} borders=true Lines around grid element
* @property {boolean=} gridlines=true Horizontal and Vertical lines for ONLY content sections
* @property {boolean=} verticalLines=true Vertical lines for all sections
* @property {boolean=} contentVerticalLines=true Vertical lines for all content section
* @property {boolean=} horizontalLines=true Horizontal lines for all sections
* @property {*=} RTK=null rtk toolkit instance
* @property {Grid~ADCOptions=} ADC=null ADC requesting level config object from adc team
* @property {Grid~SynapseConfig=} synapse=null synapse config object
* @property {number=} contentRightPadding=0 Padding that is added next to the right most column. The padding is still a part of scrollable content.
* @property {number=} contentBottomPadding=0 Padding that is added below the last section. The padding is still a part of scrollable content.
* @property {number=} dataConflationRate=0 set delay for data to avoid to much sorting operation when data changed
* @property {Function=} dataComposed Handler for dataComposed event
* @property {boolean=} autoDateConversion=false If enabled, date-time field with numeric value will be automatically converted to native date object.
* @property {boolean=} textSelect=false If enabled, user can select content text by using mouse drag.
* @property {string=} lang laguage for config localization date time, if null the default language is "en"
* @property {Element=} scrollbarParent=null Element to be attached by grid's scrollbars, allowing them to move outside and avoid overlapping with the content.
* @property {boolean=} formulaEngine=false If enabled, field with leading equal sign will be treated as a formula and rows will be filled with the calculated values.
* @property {number=} adcPollingInterval=0 Length of polling interval for refreshing ADC data in milliseconds. The default value (0) means no polling.
* @property {boolean=} fieldCaching=false If enabled, field definition will be caching internal mechanism
* @property {boolean=} timeSeriesExpansion=true If disabled, the time series field will be treated as a normal field and not expanded.
* @property {string=} childDataField=CHILD_VALUES The given field will be used to store children's static data, such as row color assignment.
* @property {boolean=} topSection=true If disabled, title section will not be rendered
*/

/** @typedef {number|string|RowDefinition} Grid~RowReference
* @description A row in Grid can be referred by the following values: &lt;br&gt;
* &lt;b&gt;number&lt;/b&gt; : Row index of a visible rows, excluding invisible (hidden) rows&lt;br&gt;
* &lt;b&gt;RowDefinition&lt;/b&gt; : Row definition object&lt;br&gt;
* &lt;b&gt;string&lt;/b&gt; : Unique row Id existing in current data table, including invisible rows&lt;br&gt;
*/

/** @typedef {number|string|ColumnDefinition} Grid~ColumnReference
* @description A column in Grid can be referred by the following values:&lt;br&gt;
* &lt;b&gt;number&lt;/b&gt; : Column index including all invisible (hidden) columns&lt;br&gt;
* &lt;b&gt;string&lt;/b&gt; : Field name or column id of the column&lt;br&gt;
* &lt;b&gt;ColumnDefinition&lt;/b&gt; : Column definition object&lt;br&gt;
*/

/** @event Grid#fieldAdded
* @description Fired after the field has been added to the data table.
* @property {string} type "fieldAdded"
* @property {Array.&lt;string&gt;} addedFields An array of newly added fields
* @property {Array.&lt;string&gt;} fields All fields
* @property {Array.&lt;string&gt;} rics All rics
* @property {Array.&lt;RowDefinition&gt;} rowDefs All row definitions
*/
/** @event Grid#fieldRemoved
* @description Fired after the field has been removed from the data table.
* @property {string} type "fieldRemoved"
* @property {Array.&lt;string&gt;} removedFields An array of recently removed fields
* @property {Array.&lt;string&gt;} fields All fields
* @property {Array.&lt;string&gt;} rics All rics
* @property {Array.&lt;RowDefinition&gt;} rowDefs All row definitions
*/
/** @event Grid#ricAdded
* @description Fired after the ric has been added to the data table.
* @property {string} type "ricAdded"
* @property {Array.&lt;string&gt;} addedRics An array of newly added rics
* @property {Array.&lt;string&gt;} fields All fields
* @property {Array.&lt;string&gt;} rics All rics
* @property {Array.&lt;RowDefinition&gt;} rowDefs All row definitions
*/
/** @event Grid#ricRemoved
* @description Fired after the ric has been removed from the data table.
* @property {string} type "ricRemoved"
* @property {Array.&lt;string&gt;} removedRics An array of recently removed rics
* @property {Array.&lt;string&gt;} fields All fields
* @property {Array.&lt;string&gt;} rics All rics
* @property {Array.&lt;RowDefinition&gt;} rowDefs All row definitions
*/

/** @event Grid#adcDataReceived
* @description Fired after ADC data or response received from the server
* @property {Array.&lt;Array&gt;} data Data part of the server response
*/

/** @event Grid#pageIndexChanged
* @description Fired after page index in the data view is changed during the active pagination mode
*/

/** @event Grid#pageCountChanged
* @description Fired after page count in the data view is changed during the active pagination mode
*/

/** @event Grid#dataComposed
* @description Trigger before dataChanged. Perform any data update during the event will NOT cause more dataChanged events
* @property {Grid} grid
* @property {RowDefinition} rowDef
*/

/** @event Grid#beforeRowRemoved
* @description Fired only when a row will be removed through Grid's API and before occurring of the actual removal
*/

/** @type {string}
* @private
* @const
*/
var SUB_ID = "SUB_ID";

/** @private
* @param {RowDefinition} rowDef
* @return {Object}
*/
var toRowData = function(rowDef) {
	return rowDef ? rowDef.getRowData() : null;
};

/** @private
* @const
* @type {Object.&lt;string, number&gt;}
*/
var _unclonableFields = {
	"ROW_DEF": 1,
	"SUB_ID": 1
};
/** @private
* @param {RowDefinition} fromRowDef
* @param {RowDefinition} toRowDef
*/
var cloneRowData = function(fromRowDef, toRowDef) {
	var from = toRowData(fromRowDef);
	var to = toRowData(toRowDef);
	for(var key in from) {
		if(!_unclonableFields[key]) {
			to[key] = from[key];
		}
	}
};

/** @private
* @param {string} sortField
* @param {Object} elemData
* @param {number} index
*/
var mapRowOrder = function (sortField, elemData, index) { // edit name
	elemData[sortField] = index; // Make column for sort with user data array
};

/** @private
* @param {RowDefinition} rowDef
* @return {boolean}
*/
var excludeAutoGenerated = function (rowDef) {
	return !rowDef.isAutoGenerated();
};

/** @private
* @param {Object} colConfig column config
* @return {boolean}
*/
var _byNonAutoGeneratedColumn = function (colConfig) {
	return !colConfig.autoGenerated;
};
/** @private
* @param {string} rowDefA
* @param {string} rowDefB
* @param {string} sortOrder
* @param {string} fieldName
* @return {number} The outcome of the value comparison
*/
var compareNumber = function(rowDefA, rowDefB, sortOrder, fieldName) { // edit name
	return (rowDefA.getData(fieldName) - rowDefB.getData(fieldName)) * sortOrder; // for numeric comparison
};

/** @private
* @param {ColumnDefinition} colDef
* @return {string}
*/
var _getName = function(colDef) {
	if(colDef) {
		return colDef.getName();
	}
	return "";
};
/** @private
* @param {ColumnDefinition} colDef
* @param {string} str
* @return {boolean}
*/
var _hasFieldOrId = function(colDef, str) {
	return (colDef.getField() === str) || (colDef.getId() === str);
};

/** @constructor
* @extends {EventDispatcher}
* @param {(Element|null)=} placeholder
* @param {Grid~GridOptions=} config
*/
var Grid = function(placeholder, config) {
	var t = this; // This is to primarily reduce file size

	t._onDataChanged = t._onDataChanged.bind(t);
	t._onDataComposed = t._onDataComposed.bind(t);
	t._onSubSegmentChanged = t._onSubSegmentChanged.bind(t);
	t._recalculateFormulas = t._recalculateFormulas.bind(t);
	t._updateStreamingData = t._updateStreamingData.bind(t);
	t.updateColumnTitle = t.updateColumnTitle.bind(t);
	t._populateTimeSeriesChildren = t._populateTimeSeriesChildren.bind(t);

	t._onPostSectionDataBinding = t._onPostSectionDataBinding.bind(t);
	t._asyncClearDataUpdates = t._asyncClearDataUpdates.bind(t);
	t._clearDataUpdates = t._clearDataUpdates.bind(t);
	t._onPreDataSorting = t._onPreDataSorting.bind(t);
	t._mainSorter = t._mainSorter.bind(t);
	t._updateRowData = t._updateRowData.bind(t);
	t._onFormulaDataChanged = t._onFormulaDataChanged.bind(t);
	t._onFormulaDataRequired = t._onFormulaDataRequired.bind(t);
	t._addMemberOfChain = t._addMemberOfChain.bind(t);
	t._onColumnAdded = t._onColumnAdded.bind(t);
	t._onRowExpansionBinding = t._onRowExpansionBinding.bind(t);
	t._onColumnHeaderBinding = t._onColumnHeaderBinding.bind(t);
	t._getRowId = t._getRowId.bind(t);
	t._onFieldLoadedError = t._onFieldLoadedError.bind(t);

	t._snapshotFillerDataChanged = t._snapshotFillerDataChanged.bind(t);
	t._onPollingInterval = t._onPollingInterval.bind(t);

	t._streamingConflator = new Conflator(50, t._updateStreamingData);
	t._formulaConflator = new Conflator(300, t._onFormulaDataChanged);
	t._chainConflator = new Conflator(100, t._addMemberOfChain);
	t._columnTitleConflator = new Conflator(0, t.updateColumnTitle);
	t._timeSeriesChildConflator = new Conflator(0, t._populateTimeSeriesChildren);


	t._defaultColumnOptions = {};

	t._topNode = placeholder || Dom.div();
	t._topNode.classList.add("rt-grid");
	t._grid = new Core();
	t._grid._wrapper = this; // For back referencing

	t._sorter = new RowDefSorter();
	t._sorter.setContext("grid", this);
	t._sorter.setContext("core", t._grid); // TODO: Handle multiple core grids

	t._dateTimeUtil = DateTime;

	t._grid.listen("columnAdded", t._onColumnAdded); // Columns could be added by some plugins

	if(config) {
		if(config["dataView"]) {
			t._sharedDataSource = true;
			t._dv = config["dataView"];
			t._dt = t._dv.getDataTable();
			t._mainGrid = config["grid"];

			var core = t._mainGrid.getCoreGrid();
			t._stp = core.getPlugin("SortableTitlePlugin");
		}
		if(config["SortableTitle"]) { // Exception for built-in plugin
			t._stp = config["SortableTitle"];
		}
		if(config["topSection"] === false) {
			t._topSection = false;
		}
	}
	if(!t._sharedDataSource) {
		t._dc = new DataCache();
		t._dc.listen("dataChanged", t._onDataChanged);
		t._dc.listen("dataComposed", t._onDataComposed);
		t._dc.addStaticFields([ROW_DEF, SUB_ID]); // Static fields are deprecated, set fields to be ignore during clone in DataCache

		t._dt = new DataTable();
		t._dt.setSortingLogic(/** @type{Function} */(t._mainSorter));
		t._dt.setClassificationSource(t._dc);
		t._dt.listen("subSegmentChanged", t._onSubSegmentChanged);
		t._dv = new DataView(t._dt);
		t._dv.listen("pageIndexChanged", t._dispatch.bind(t, "pageIndexChanged"));
		t._dv.listen("pageCountChanged", t._dispatch.bind(t, "pageCountChanged")); // TODO: When implementing filtered row, it may need to implement the conflator
	}
	t._grid.setDataSource(t._dv); // Avoid triggering sorting

	if(t._stp) {
		t._sharedSorter = true;
		t._stp.listen("preDataSorting", t._onPreDataSorting);
		t._grid.loadPlugin(t._stp); // The plugin instance is shared and don't need to be reconfigured.
	} else { // Create built-in plugin
		t._stp = new SortableTitlePlugin({
			"userManagedLogic": true,
			"sortableColumns": true,
			"disableDoubleClickToSort": true,
			"ROW_DEF": true // Enable Row Definition Mode
		});
		t._stp.listen("preDataSorting", t._onPreDataSorting);

		// TODO: Built-in plugins don't have normal workflow unlike other extensions. Make them have the same workflow like the others
		// defaultColumnOptions property does not work with them.
		// beforeInit is not called.
		t._grid.loadPlugin(t._stp, config);
	}

	t._grid.listen("preSectionRender", t._onColumnHeaderBinding);
	t._grid.listen("postSectionDataBinding", t._onPostSectionDataBinding);

	t._grid.enableRowHighlighting(true);

	t._addGridSections();
	t._grid.setParent(t._topNode);

	t._snapshot = new SnapshotFiller();
	t._snapshot.addEventListener("adcDataReceived", t._dispatch.bind(t, "adcDataReceived"));
	t._snapshot.addEventListener("dataChanged", this._snapshotFillerDataChanged);

	t._connector = new DataConnector();
	t._connector.addEventListener("ricAdded", t._onRicAdded.bind(t));
	t._connector.addEventListener("ricRemoved", t._onRicRemoved.bind(t));
	t._connector.addEventListener("fieldAdded", t._onFieldAdded.bind(t));
	t._connector.addEventListener("fieldRemoved", t._onFieldRemoved.bind(t));

	t.initialize(config);
	t.initSubscription();

	StyleLoader.applyStyle(t._grid);
};
Ext.inherits(Grid, EventDispatcher);

/** @private
 * @type {Element}
 */
Grid.prototype._topNode = null;
/** @private
 * @type {Grid}
 */
Grid.prototype._mainGrid = null;
/** @private
 * @type {Core}
 */
Grid.prototype._grid = null;
/** Store all actual data including streaming data, ADC data, snapshot data, user input data.
 * @type {DataCache}
 * @private
 */
Grid.prototype._dc = null;
/** Used for hiding and filtering out rows. Always have greater or equal number of rows than that in grid
 * @type {DataTable}
 * @private
 */
Grid.prototype._dt = null;
/** Used for sorting. Number of rows is always the same as that in grid
 * @type {DataView}
 * @private
 */
Grid.prototype._dv = null;
/** @type {boolean}
 * @private
 */
Grid.prototype._sharedDataSource = false;
/** @type {boolean}
 * @private
 */
Grid.prototype._sharedSorter = false;

/** JET.Quotes2 Subscription
 * @type {Object}
 * @private
 */
Grid.prototype._subs = null;

/** @type {SortableTitlePlugin}
 * @private
 */
Grid.prototype._stp = null;
/** @type {Function}
 * @private
 */
Grid.prototype._columnSorter = null;

/** @private
* @type {Conflator}
*/
Grid.prototype._streamingConflator = null;
/** @private
* @type {SnapshotFiller}
*/
Grid.prototype._snapshot = null;
/** @private
* @type {DataConnector}
*/
Grid.prototype._connector = null;
/** @private
* @type {RowDefSorter}
*/
Grid.prototype._sorter = null;

/** @private
* @type {Engine}
*/
Grid.prototype._fnEngine = null;
/** @private
* @type {Conflator}
*/
Grid.prototype._formulaConflator = null;

/** @private
* @type {Object.&lt;string, Object&gt;}
*/
Grid.prototype._chainMembers = null;
/** @private
* @type {Conflator}
*/
Grid.prototype._chainConflator = null;
/** @private
* @type {number}
*/
Grid.prototype._clientWidth = NaN;
/** @private
* @type {number}
*/
Grid.prototype._autoLayoutTimer = 0;
/** @private
 * @type {ColumnDefinition~Options}
 */
Grid.prototype._defaultColumnOptions = null;
/** @private
* @type {*}
*/
Grid.prototype._RTK = null;
/** @private
* @type {Grid~ADCOptions}
*/
Grid.prototype._ADCOptions = null;
/** use for synapse service
* @private
* @type {string}
*/
Grid.prototype._synapse = null;
/** @private
* @type {boolean}
*/
Grid.prototype._autoDateConversion = false;
/** @private
* @type {boolean}
*/
Grid.prototype._textSelect = false;
/** @type {string}
* @private
*/
Grid.prototype._lang = null;
/** @type {Object}
* @private
*/
Grid.prototype._dateTimeUtil = null;
/** @type {boolean}
* @private
*/
Grid.prototype._initializing = false;
/** @type {number}
* @private
*/
Grid.prototype._pollingInterval = 0;
/** @type {number}
* @private
*/
Grid.prototype._pollingTimerId = 0;
/** @type {number}
* @private
*/
Grid.prototype._lastPollingRequest = 0;
/** @type {boolean}
* @private
*/
Grid.prototype._pollingEnabled = true;
/** @type {boolean}
* @private
*/
Grid.prototype._fieldCaching = false;
/** @type {boolean}
* @private
*/
Grid.prototype._timeSeriesExpansion = true;

/** @type {string}
* @private
*/
Grid.prototype._childDataField = "";
/** @type {boolean}
* @private
*/
Grid.prototype._topSection = true;

/** @public
*/
Grid.prototype.dispose = function() {
	this.removeAllEventListeners();
	if(this._autoLayoutTimer) {
		clearInterval(this._autoLayoutTimer);
		this._autoLayoutTimer = 0;
	}
	if(this._pollingTimerId) {
		clearTimeout(this._pollingTimerId);
		this._pollingTimerId = 0;
	}
	this.removeAllColumns(); // Some conflators are reset
	this.removeAllRows(); // Some conflators are reset
	this._sorter.dispose();
	this._grid.dispose();
	this._connector.reset();

	this._mainGrid = this._dt = this._dv = null;

	if(this._subs) {
		this._subs["dispose"]();
		this._subs = null;
	}
};
/** @public
* @return {Element}
*/
Grid.prototype.getElement = function() {
	return this._topNode;
};
/** Alias to {@link EventDispatcher#removeAllEventListeners}
* @public
* @function
*/
Grid.prototype.removeEventListeners = Grid.prototype.removeAllEventListeners;
/** Alias to {@link EventDispatcher#addEventListener}
* @public
* @function
* @param {string} type Event name
* @param {Function} handler Event handler
*/
Grid.prototype.listen = Grid.prototype.addEventListener;
/** @public
*/
Grid.prototype.initSubscription = function() {
	if(!this._dc || this._dc.getSubscriptions()) { // Subscription is already initialized
		return;
	}

	var jet, q, s;
	jet = window["JET"]; // Assume that JET is already exist.
	if (this._RTK) {
		q = this._RTK.Quotes;
	} else if(jet) {
		q = jet["Quotes2"];
	}
	if(q) {
		s = q["create"]();
	}
	if(!s) {
		return;
	}
	if(s["filter"]) {
		s["filter"](-2, -1); // Enable skip header for chains
	}

	this._subs = s;
	this._subs["start"]();
	this._dc.setSubscriptions(s);

	// TODO: Subscriptions should be registered per row.
	// However, chain subscription cannot be integrated with DataConnector in this current implementation.
	var rowDefs = this._getAllRowDefinitions();
	var len = rowDefs.length;
	for(var i = 0; i &lt; len; ++i) {
		var rowDef = rowDefs[i];
		if(rowDef) {
			rowDef.subscribeForUpdates();
		}
	}
};

/** @public
*/
Grid.prototype.updateLayout = function() {
	this._grid.updateLayout();
	this._stp.updateSortSymbols(); // HACK: There is a chance that grid may not yet be in the document
};
/** Force rerender of grid rows. TODO: Check this could be deprecated in favor of Core's requestRowRefresh method
* @private
* @param {number=} rowIndex
*/
Grid.prototype._updateRowData = function(rowIndex) {
	if(rowIndex &gt;= 0) {
		var rowId = this._dv.getRowId(rowIndex);
		if(rowId) {
			this._dt.setRowData(rowId, {});
		}
	} else {
		this._dt.dispatchGlobalChange(); // Trigger sorting too
	}
};
/** @public
* @function
* @param {number=} opt_rowIndex
*/
Grid.prototype.updateRowData = Grid.prototype._updateRowData;

/** @private
 */
Grid.prototype._addGridSections = function () {
	var title = this._grid.addSection("title");
	if(this._topSection == false){
		title.setRowCount(0);
	} else {
		title.setRowCount(1);
	}
	this._grid.addSection("content");

	var titleSettings = this._grid.getSectionSettings("title");
	titleSettings.disableDataBinding();

	var contentSettings = this._grid.getSectionSettings("content");
	contentSettings.setAutoSyncRowCount(true);
	contentSettings.setParent(titleSettings);
};
/** @public
* @param {string=} sectionName
* @return {*} Return Section instance
 */
Grid.prototype.addHeaderSection = function (sectionName) {
	var titleSects = this._grid.getAllSections("title");

	var headerSect = this._grid.addSectionAt(titleSects.length, "title", sectionName);
	if(headerSect) {
		headerSect.setRowCount(1);

		var headerSettings = this._grid.getSectionSettings(headerSect);
		headerSettings.disableDataBinding();
	}

	return headerSect;
};
/** @public
* @param {string=} sectionName
* @return {*} Return Section instance
*/
Grid.prototype.addFooterSection = function (sectionName) {
	var footerSect = this._grid.addSection("footer", sectionName);
	if(footerSect) {
		footerSect.setRowCount(1);

		var footerSettings = this._grid.getSectionSettings(footerSect);
		footerSettings.disableDataBinding();
	}

	return footerSect;
};

/** @public
* @param {Element} elem Parent element
*/
Grid.prototype.setParent = function (elem) {
	Dom.appendChild(elem, this._topNode);
	this.updateLayout();
};
/** @public
* @param {Element} elem Sibling element
*/
Grid.prototype.insertBefore = function (elem) {
	if(elem) {
		var pn = elem.parentNode;
		if(pn) {
			pn.insertBefore(this._topNode, elem);
			this.updateLayout();
		}
	}
};
/** The returned object contains &lt;br&gt;
* `boolean` hit : Indicates whether the given position is on the grid &lt;br&gt;
* `number` x : Horizontal coordinate that is relative to the top-left of the grid (Zero means left-most) &lt;br&gt;
* `number` y : Vertical coordinate that is relative to the top-left of the grid (Zero means top-most) &lt;br&gt;
* `number` colIndex &lt;br&gt;
* `number` sectionIndex &lt;br&gt;
* `number` rowIndex &lt;br&gt;
* and other related property to the given position.
* @public
* @param {!ElementWrapper|Element|Event|MouseEvent} obj Element, Browser's Event object, Browser's Mouse Event object are all valid
* @return {!Object}
*/
Grid.prototype.getRelativePosition = function (obj) {
	return this._grid.getRelativePosition(obj);
};
/** The returned core grid
* @public
* @return {Core}
*/
Grid.prototype.getCoreGrid = function () {
	return this._grid;
};

/** @public
* @param {Grid~GridOptions=} gridOption
*/
Grid.prototype.initialize = function(gridOption) {
	if (!gridOption) { return; }
	// TODO: clear all data before re-initialization
	var t = this; // For minimizing file size
	t._initializing = true;
	var grid = t._grid; // core grid
	gridOption = grid.normalizeConfig(gridOption);

	var exts = gridOption["plugins"] || gridOption["extensions"];

	var cols = /** @type{Array} */(gridOption["fields"] || gridOption["columns"]);
	if (gridOption["defaultColumnOptions"]) {
		t._defaultColumnOptions = gridOption["defaultColumnOptions"];
		t._defaultColumnSetup(t._defaultColumnOptions, cols);
	}

	// Tell all plugins that the initialization phase has started
	t._processExtension(exts, "beforeInit", [grid.getElement(), gridOption]);

	// option flag text-select
	// allow user to select text for copy or so something
	if (gridOption['textSelect']) {
		t._textSelect = true;
		grid.addClass('tr-text-select');
	}

	if (gridOption["RTK"]) {
		t._RTK = gridOption["RTK"];
		t._snapshot.setRTK(t._RTK);
	}

	if (gridOption["ADC"]) {
		t._ADCOptions = gridOption["ADC"];
		t._snapshot.setADCOptions(t._ADCOptions);
	}

	if (gridOption["synapse"]) {
		t._synapse = gridOption["synapse"];
		FieldDefinition.setSynapseConfig(t._synapse);
	}

	if (gridOption["fieldCaching"]) {
		t._fieldCaching = gridOption["fieldCaching"];
		FieldDefinition.setFieldCaching(t._fieldCaching);
	}

	if(gridOption["timeSeriesExpansion"] != null) {
		t._timeSeriesExpansion = gridOption["timeSeriesExpansion"];
		FieldDefinition.disableTimeSeriesExpansion(!t._timeSeriesExpansion);
	}

	if (gridOption["icons"] &amp;&amp; gridOption["icons"]["rowGrouping"] &amp;&amp; gridOption["icons"]["rowGrouping"]["expander"]) {
		StyleLoader.chainIcon = gridOption["icons"]["rowGrouping"]["expander"];
	}

	if(gridOption["formulaEngine"]) {
		t._fnEngine = new Engine();
		t._fnEngine.addEventListener("dataChanged", t._onFormulaDataChanged);
		t._fnEngine.addEventListener("dataRequired", t._onFormulaDataRequired);
	}

	var borders = gridOption["borders"];
	if (borders != null) {
		grid.toggleBorders(borders);
	}
	var gridlines = gridOption["gridlines"];
	if (gridlines != null) {
		grid.toggleGridlines(gridlines);
	}
	var vLines = gridOption["verticalLines"];
	if (vLines != null) {
		grid.toggleVerticalLines(vLines);
	}
	var cvLines = gridOption["contentVerticalLines"];
	if (cvLines != null) {
		grid.toggleContentVerticalLines(cvLines);
	}
	var hLines = gridOption["horizontalLines"];
	if (hLines != null) {
		grid.toggleHorizontalLines(hLines);
	}

	if(gridOption["pageSize"]) {
		t._dv.setPageSize(+gridOption["pageSize"]);
	}

	var rowHeight = +gridOption["rowHeight"];
	if(rowHeight) { // Non empty or zero
		grid.setDefaultRowHeight(rowHeight);
	}
	var hRowHeight = +gridOption["headerRowHeight"];
	if(hRowHeight) { // Non empty or zero
		grid.getSection("title").setDefaultRowHeight(hRowHeight);
	}

	var val = gridOption["autoLayoutUpdate"];
	if(!t._autoLayoutTimer &amp;&amp; val) {
		if(val !== "0" &amp;&amp; val !== "false") { // HACK: Temporarily support incorrect data type
			t._autoLayoutTimer = setInterval(t._onAutoLayoutUpdate.bind(t), 2000);
		}
	}

	var bool = gridOption["rowHighlighting"];
	if(bool != null) {
		grid.enableRowHighlighting(!!bool);
	}

	var rowExpansionBinding = gridOption["rowExpansionBinding"];
	if(typeof rowExpansionBinding === "function") {
		grid.listen("rowExpansionBinding", t._onRowExpansionBinding); // TODO: Support multi-table feature
		t.listen("rowExpansionBinding", rowExpansionBinding);
	}

	var dataComposedHandler = gridOption["dataComposed"];
	if(typeof dataComposedHandler === "function") {
		t.listen("dataComposed", dataComposedHandler);
	}

	if(gridOption["autoDateConversion"]) {
		t._autoDateConversion = true;
	}

	if(gridOption["stepScroll"]) {
		grid.setRowScrollingStep(1);
	}
	if(gridOption["linearWheelScrolling"]) {
		grid.getVScrollbar().setMouseWheelSpeed("linear");
	}
	if(gridOption["autoHideScrollbar"] != null) {
		grid.autoHideScrollbars(gridOption["autoHideScrollbar"] ? true : false);
	}
	if(gridOption["scrollbarParent"] != null) {
		t._setScrollbarParent(gridOption["scrollbarParent"]);
	}
	var pollingInterval = gridOption["adcPollingInterval"];
	if(pollingInterval != null) {
		t._pollingInterval = pollingInterval ? +pollingInterval : 0;
	}

	// Column operations
	t.setColumns(cols);

	var rowVir = true;
	if (gridOption["rowVirtualRendering"] != null) {
		rowVir = gridOption["rowVirtualRendering"];
	}
	if (gridOption["rowVirtualization"] != null) {
		rowVir = gridOption["rowVirtualization"];
	}
	grid.enableRowVirtualization(!!rowVir);

	var colVir = false;
	if (gridOption["columnVirtualRendering"] != null) {
		colVir = gridOption["columnVirtualRendering"];
	}
	if (gridOption["columnVirtualization"] != null) {
		colVir = gridOption["columnVirtualization"];
	}
	grid.enableColumnVirtualization(!!colVir);

	var scrollbar = gridOption["scrollbar"] != null ? gridOption["scrollbar"] : true;
	if (scrollbar) {
		t._topNode.style.overflow = "hidden"; // TODO: Move this to CSS Class
	} else {
		grid.freezeSection(null); // Disable vertical scrollbar
		t._topNode.style.overflow = "";
	}

	var topFreezingCount = gridOption["topFreezingCount"];
	if (typeof topFreezingCount === "number") {
		topFreezingCount = (topFreezingCount &gt; 0) ? topFreezingCount : 0;
		var sectionIndex = topFreezingCount - 1;
		grid.freezeSection(sectionIndex);
	} else if (topFreezingCount === false) {
		grid.freezeSection(null);
	}

	var bottomFreezingCount = gridOption["bottomFreezingCount"];
	if (typeof bottomFreezingCount === "number") {
		bottomFreezingCount = (bottomFreezingCount &gt; 0) ? bottomFreezingCount : 0;
		grid.freezeFooter(bottomFreezingCount);
	}

	t.addDataFields(gridOption["dataFields"]);

	// Plugins
	gridOption[ROW_DEF] = true; // Enable ROW_DEF mode
	if (Array.isArray(exts)) {
		for (var i = 0; i &lt; exts.length; ++i) {
			var ext = exts[i];
			var extInstance = null;
			if (ext) {
				var extName = ext["name"];
				if(extName) {
					extInstance = grid.loadPlugin(extName, ext); // pass plugin object as an argument for initialization
				} else {
					extInstance = grid.loadPlugin(ext, gridOption);
				}
			}
			if (extInstance &amp;&amp; extInstance["setGridWrapper"]) {
				var hasApi = (typeof extInstance["getGridApi"] === "function") ? extInstance["getGridApi"]() : false;
				if(!hasApi) {
					extInstance["setGridWrapper"]("realTimeGrid", t);
				}
			}
		}
		t._initializing = false;
	}

	var lang = gridOption["lang"];
	if(lang != null) {
		t._lang = lang;
		t._dateTimeUtil.setLocale(lang);
	}

	// Row operations
	if(gridOption["childDataField"] != null) {
		this._childDataField = RowDefinition._childDataField = gridOption["childDataField"];
	}
	var rows = gridOption["rows"];
	if(!rows) {
		rows = gridOption["rics"] || null; // Make "rics" an alias to "rows"
	}
	var bodies = /** @type{Array} */(gridOption["bodies"]);
	if(!bodies) {
		bodies = [];
		if(gridOption["body"]) {
			bodies.push(gridOption["body"]);
		}
		if(rows) {
			for(var m = 0; m &lt; rows.length; m++) {
				if(typeof rows[m] === "string") {
					rows[m] = { "ric": rows[m] };
				}
			}
			bodies.push({ "rows": rows });
		}
	}

	// Merge rows with static data rows
	var staticRows = gridOption["staticDataRows"] || gridOption["dataModel"];
	if(rows &amp;&amp; staticRows) {
		var ary = staticRows["data"] ? staticRows["data"] : staticRows;
		var fields = staticRows["fields"] || t.getColumnFields();
		var values, data;
		var len = rows.length;
		for(var n = 0; n &lt; len; n++) {
			if(rows[n]["values"]) { // merge row's values, values can be object or array
				values = arrayToObject(rows[n]["values"], fields);
				data = arrayToObject(ary[n], fields);
				rows[n]["values"] = extendObject(values, data);
			} else {
				rows[n]["values"] = ary[n];
			}
		}
		ary = ary.slice(len, ary.length);
		if(staticRows["data"]) {
			staticRows["data"] = ary;
		} else {
			staticRows = ary;
		}
	}

	for(var j = 0; j &lt; bodies.length; ++j) {
		t.insertRows(bodies[j]["rows"]);
		// break; // TODO: The first version supports only 1 grid
	}

	t.addStaticDataRows(staticRows);

	if(gridOption.contentBottomPadding) {
		grid.setBottomPaddingSection(gridOption.contentBottomPadding);
	}

	var contentRightPadding = gridOption.contentRightPadding;
	if(contentRightPadding) {
		if (typeof contentRightPadding !== "number") {
			contentRightPadding = 6;
		}

		grid.reserveRightSpace(contentRightPadding);
	}

	// Let everything init first
	// then set conflationRate to grid for better perfomance on rapidly updating
	var dataConflationRate = gridOption['dataConflationRate'];
	if (dataConflationRate != null) {
		grid.setDataConflationRate(dataConflationRate);
	}

	// Tell all plugins that the initialization phase has ended
	var extObjects = grid.getPluginList().map(grid.getPlugin.bind(grid));
	t._processExtension(extObjects, "afterInit");
};

/** @public
* @param {Object=} gridOptions
* @return {!Object}
*/
Grid.prototype.getConfigObject = function (gridOptions) {
	var obj = gridOptions || {};

	var columns = obj.columns;
	if(!columns) {
		columns = obj.columns = [];
	}

	var grid = this._grid;
	if(grid.getConfigObject) {
		grid.getConfigObject(obj);
	}

	// Difference from composite grid in default config
	if(obj["columnVirtualization"] === false) {
		delete obj["columnVirtualization"];
	}

	if(obj["rowVirtualization"] === true) {
		delete obj["rowVirtualization"];
	}

	if(obj["rowHighlighting"] === true) {
		delete obj["rowHighlighting"];
	}

	if(obj["contentVerticalLines"] === false) { // the default value change in wrapper (efx-grid)
		delete obj["contentVerticalLines"];
	}

	if(obj["borders"] === false) { // the default value change in wrapper (efx-grid)
		delete obj["borders"];
	}


	var i, len;
	len = this.getColumnCount();
	for (i = 0; i &lt; len; ++i) {
		var column = columns[i];
		if(!column) {
			column = columns[i] = {};
		}
		var colDef = this.getColumnDefinition(i);
		// TODO: Update width and scalability changed by the extensions
		colDef.getConfigObject(column);
	}

	obj.columns = columns = columns.filter(_byNonAutoGeneratedColumn);

	if(this._topNode.style.overflow === "") {
		obj["scrollbar"] = false;
	}

	var val = this._dv.getPageSize();
	if(val &gt; 0) {
		obj["pageSize"] = val;
	}

	val = grid.getDefaultRowHeight();
	if(val !== 28) { // the default value change in wrapper (efx-grid)
		obj["rowHeight"] = val;
	}

	val = grid.getSection("title").getDefaultRowHeight();
	if(val !== 28) { // the default value change in wrapper (efx-grid)
		obj["headerRowHeight"] = val;
	}

	if(this._autoLayoutTimer) {
		obj["autoLayoutUpdate"] = true;
	}

	val = isEmptyObject(this._defaultColumnOptions);
	if (!val) { // Currently, this variable is the object, we need to check empty array for default value
		obj["defaultColumnOptions"] = this._defaultColumnOptions;
	}

	if(this._autoDateConversion) {
		obj["autoDateConversion"] = true;
	}

	if(this._textSelect) {
		obj["textSelect"] = true;
	}

	if(this._lang) {
		obj["lang"] = this._lang;
	}
	if(this._fnEngine) {
		obj["formulaEngine"] = true;
	}
	if(this._pollingInterval) {
		obj["adcPollingInterval"] = this._pollingInterval;
	}
	if(this._fieldCaching) {
		obj["fieldCaching"] = this._fieldCaching;
	}
	if(this._timeSeriesExpansion != true) {
		obj["timeSeriesExpansion"] = this._timeSeriesExpansion;
	}

	if(this._childDataField) {
		obj["childDataField"] = this._childDataField;
	}

	// get all rows config
	var rowDefs = this.getAllRowDefinitions();
	var rows = obj["rows"] = [];
	var rowDef, rowConfig;
	len = rowDefs.length;
	for (i = 0; i &lt; len; i++) {
		rowDef = rowDefs[i];
		rowConfig = rowDef.getConfigObject();
		rows.push(rowConfig);
	}

	// get row config from extensions
	var extensions = grid.getPlugins();
	var pluginInstance, row;
	for(var key in extensions) {
		pluginInstance = extensions[key];
		if(typeof pluginInstance["getRowConfigObject"] === "function") {
			len = rows.length;
			for (i = 0; i &lt; len; i++) {
				rowDef = rowDefs[i];
				row = rows[i];
				pluginInstance["getRowConfigObject"](row, rowDef.getRowId());
			}
		}
	}

	// TODO: The following states need to be retrieved
	// topFreezingCount, bottomFreezingCount
	// scrollbarParent
	// linearWheelScrolling
	// stepScroll
	// noColumnDragging
	// columnReorder
	// topSection

	// NOTE: no need to export synapseApiKey, ADC and RTK

	return obj;
};

/** @public
* @ignore
* @param {Object} dateTimeUtil
*/
Grid.prototype.setDateTimeUtil = function(dateTimeUtil) {
	if(this._dateTimeUtil !== dateTimeUtil) {
		this._dateTimeUtil = dateTimeUtil;
		this._dateTimeUtil.setLocale(this._lang);
	}
};
/** @public
* @param {string} lang
*/
Grid.prototype.setLocale = function(lang) {
	if(lang &amp;&amp; this._lang !== lang) {
		this._lang = lang;
		this._dateTimeUtil.setLocale(lang);
		this._grid.requestRowRefresh();
	}
};

/** @private
* @param {Object} defaultCol
* @param {Array.&lt;Object&gt;} userColumns
*/
Grid.prototype._defaultColumnSetup = function (defaultCol, userColumns) {
	var c = userColumns.length;
	for (var i = 0; i &lt; c; i++) {
		var column = userColumns[i];
		if (typeof column === 'object') {
			for (var key in defaultCol) {
				if (column[key] == null) {
					column[key] = defaultCol[key];
				}
			}
		}
		// TODO: Handle columnOption type string
		// else if (typeof column === 'string') { }
	}
};

/** @private
* @param {Array.&lt;Object&gt;} exts List of plugin instance
* @param {string} field A function name of plugin instance
* @param {Array.&lt;*&gt;} params Inputs that will pass to a function call
*/
Grid.prototype._processExtension = function (exts, field, params) {
	if(Array.isArray(exts)) {
		for (var i = 0; i &lt; exts.length; i++) {
			if (exts[i][field]) {
				exts[i][field].apply(exts[i], params);
			}
		}
	}
};

/** @private
* @param {Object} e
*/
Grid.prototype._onRicAdded = function(e) {
	var addedRics = e.addedRics;
	this._snapshot.addFields(e.fields);
	var len = addedRics.length;
	for (var i = 0; i &lt; len; ++i) {
		var ric = addedRics[i];
		var rowDefs = this._connector.getRowDefByRic(ric);
		var jLen = rowDefs ? rowDefs.length : 0;
		for (var j = 0; j &lt; jLen; ++j) {
			var rowDef = rowDefs[j];
			if (rowDef.getSymbol() === ric) {
				this._snapshot.addRic(ric); // ADC
			}
		}
	}

	this._dispatch(e.type, e);
};

/** @private
* @param {Object} e
*/
Grid.prototype._onRicRemoved = function(e) {
	this._dispatch(e.type, e);
};

/** @private
* @param {Object} e
*/
Grid.prototype._onFieldAdded = function(e) {
	var rowDefs = e.rowDefs;
	var addedFields = e.addedFields;

	// ADC
	for (var i in rowDefs) {
		this._snapshot.addRic(rowDefs[i].getSymbol());
	}
	this._snapshot.addFields(addedFields);

	// JET
	if (this._subs) {
		var realtimeFields = addedFields.filter(FieldDefinition.isRealTimeField);
		if(realtimeFields.length &gt; 0) {
			this._subs["addFields"](realtimeFields);
		}
	}

	this._dispatch(e.type, e);
};
/** @private
* @param {Object} e
*/
Grid.prototype._onFieldRemoved = function(e) {
	var removedFields = e.removedFields;

	// TODO: ADC fields have an interval load. Currently, we only keep the field but do not delete it.
	// JET
	if(this._subs) {
		this._subs["removeFields"](removedFields);
	}

	this._dispatch(e.type, e);
};

/** @public
* @param {ColumnDefinition~Options|string} columnOption String will be treated as field, while object is treated as the column options
* @param {number=} idx
*/
Grid.prototype.insertColumn = function (columnOption, idx) {
	var colCount = this.getColumnCount();
	if(idx == null || idx &gt; colCount) {
		idx = colCount;
	}

	// no need to merge defaultColumn during initialize process
	// because columnOption already mutate by initialize function
	var configObj = (this._initializing) ? {} : cloneObject(this._defaultColumnOptions);

	if (typeof columnOption === "string") {
		configObj["field"] = columnOption;
	} else { // columnOption is assumed to be an object
		for (var key in columnOption) {
			configObj[key] = columnOption[key];
		}
	}

	if(this._fnEngine) {
		configObj["formulaEngine"] = this._fnEngine; // Adding extra option
	}

	var colDef = new ColumnDefinition(configObj, this);
	configObj[COL_DEF] = colDef;

	// WARNING: width is processed twice by tr-grid and rt-grid
	// Inserting column also initializes prefined formatter
	this._grid.insertColumn(idx, configObj); // columnAdded is fired
};

/** @private
* @param {Object} e snapshort change event object
*/
Grid.prototype._updateTimeSeriesFields = function (e) {
	var snapShortData = e.data;
	var childFields;
	for (var ric in snapShortData) {
		childFields = snapShortData[ric];
		this.setRicData(ric, snapShortData[ric]);
	}
	var parentField, field, colIndex, parentColDef, childColIndex;

	var firstField;
	for (field in childFields) {
		firstField = field;
		break;
	}

	parentField = e.childrenFieldToParent[firstField];
	colIndex = this.getColumnIndex(parentField);
	this._grid.setColumnVisibility(colIndex);
	parentColDef = this._getColumnDefinition(colIndex);


	var children = parentColDef.getChildren();
	var i, len, childDef, childField;
	len = children.length;
	if(len &gt; 0){
		for (i = 0; i &lt; len; i++) {
			childDef = children[i];
			childField = childDef.getField();
			if(!childFields[childField]) {
				this.removeColumn(childField);
			}
		}
	}

	for (childField in childFields) {
		parentField = e.childrenFieldToParent[childField];
		colIndex = this.getColumnIndex(parentField);
		parentColDef = this._getColumnDefinition(colIndex);
		childColIndex = this.getColumnIndex(childField);
		if(childColIndex &lt; 0) { // not found column index in view tried to clone from parent
			this._cloneTimeSeriesColumn(parentColDef, childField, colIndex);
			FieldDefinition.addTimeSeriesChild(parentField, childField);
		}
	}

};


/** @private
* @param {ColumnDefinition} colDef
*/
Grid.prototype._populateTimeSeriesChildren = function (colDef) {
	if(this._timeSeriesChildConflator.conflate(colDef) ) {
		return;
	}

	var colDefs  = this._timeSeriesChildConflator.popAllData();
	var i, j, len, childField, idx;

	for (i = 0; i &lt; colDefs.length; i++) {
		colDef = colDefs[i];
		idx = this.getColumnIndex(colDef);
		this._grid.setColumnVisibility(idx); // hide parent field

		if(!colDef) {
			continue;
		}
		var childFields = FieldDefinition.getTimeSeriesChildren(colDef.getField());
		if(!childFields) { // not found time series field
			return;
		}

		len = childFields.length;
		if(len &lt; 1) {
			return; // normal field
		}

		for (j = 0; j &lt; len; j++) {
			idx = this.getColumnIndex(colDef);
			childField = childFields[j];
			this._cloneTimeSeriesColumn(colDef, childField, idx);
		}
	}

};

/** @private
* @param {ColumnDefinition} parentColDef Parent definition
* @param {string} childField field
* @param {number} idx index of insertion column
*/
Grid.prototype._cloneTimeSeriesColumn = function (parentColDef, childField, idx) {
	var parentConfig, columnOption, obj, key;
	parentConfig = parentColDef.getConfigObject();
	obj = {};
	for (key in parentConfig) {
		if(key !== "hidden") {
			obj[key] = parentConfig[key];
		}
	}
	columnOption = cloneObject(obj);
	columnOption["field"] = childField.replace("TR.", ""); // We need to remove the 'TR' prefix from the field to avoid confusion with time series fields.
	columnOption["name"] = childField.split("_")[1].split("T")[0]; // Currently, response server format utc date ex "2022-11-23T00:00:00"
	columnOption["parent"] = parentColDef;
	this.insertColumn(columnOption, idx++);

};

/** @public
* @param {ColumnDefinition~Options|string} columnOption String will be treated as field, while object is treated as the column options
* @param {Grid~ColumnReference} colRef
*/
Grid.prototype.replaceColumn = function (columnOption, colRef) {
	var colIndex = this.getColumnIndex(colRef);
	if(colIndex &lt; 0) {
		return;
	}
	var colConfig = {};
	var core = this._grid;
	var columnDef = core._getColumnDef(colIndex);

	var value = core.getColumnScalability(colIndex);
	colConfig["scalable"] = value;

	value = core.getColumnCustomLaneSize(colIndex);
	colConfig["width"] = value;

	value = core.getMinimumColumnWidth(colIndex);
	if(value &gt; 0) {
		colConfig["minWidth"] = value;
	}

	value = core.isColumnVisible(colIndex);
	if(!value) {
		colConfig["hidden"] = true;
	}

	value = columnDef["stationary"];
	if (value) {
		colConfig["stationary"] = value;
	}

	value = columnDef["leftPinned"];
	if (value) {
		colConfig["leftPinned"] = value;
	}

	value = columnDef["rightPinned"];
	if (value) {
		colConfig["rightPinned"] = value;
	}

	if(typeof columnOption === "string") {
		colConfig["field"] = columnOption;
	} else { // type object from user
		for (var key in columnOption) {
			colConfig[key] = columnOption[key];
		}
	}

	if(columnOption["width"] &amp;&amp; !columnOption["scalable"]) {
		colConfig["scalable"] = false;
	}

	if(columnOption["scalable"] &amp;&amp; !columnOption["width"]) {
		colConfig["width"] = 1;
	}

	var colDef = this.getColumnDefinition(colIndex);
	if(colDef.getChildren()) { // Parent time series field doesn't provide hidden property
		colConfig["hidden"] = false;
	}

	if(colConfig.id == null) {
		colConfig.id =  colDef.getId(); // retain ID
	}
	this._grid.startBatch("reset");
	this.insertColumn(colConfig, colIndex);
	this.removeColumn(colIndex + 1); // remove existing column after insert
	this._grid.stopBatch("reset");
};

/** to update column name when field info is loaded
 * @private
 * @param {string} field
 * @param {ColumnDefinition} colDef
 * @param {Object} response
 */
Grid.prototype._onFieldLoadedSuccess = function (field, colDef, response) {
	if (response &amp;&amp; response.fieldDefinition) {
		var fieldDef = response.fieldDefinition;
		if (colDef &amp;&amp; colDef.getField() === field) {
			if (colDef.isDefaultName() &amp;&amp; fieldDef.name) {
				colDef.setName(fieldDef.name);
				this.updateColumnTitle(); // has conflator -&gt; async operation
			}
		}
	}
};

/**
 * @private
 * @param {Object} err
 */
Grid.prototype._onFieldLoadedError = function (err) {
	// TODO: May implement retry mechanism here, if need
};

/**
 * @private
 * @param {string} field
 * @param {string} referrer
 */
Grid.prototype._onFieldLoaded = function (field, referrer) {
	// For time series, we need to wait until the field is loadedm, then we can insert a child from the field data.
	if(FieldDefinition.isTimeSeries(field)) {
		var colDef = this.getColumnDefinitionById(referrer); // The 'referrer' is a column ID that was just added
		this._populateTimeSeriesChildren(colDef);
	}
	this._connector.addFields(field, referrer);
};

/**
 * @private
 * @param {Element} host
 */
Grid.prototype._setScrollbarParent = function (host) {
	host.style.boxSizing = "border-box";
	host.style.overflow = "hidden";
	host.style.position = "relative";

	this._topNode.style.height = "100%";

	this._grid.autoHideScrollbars(false);
	this._grid.getVScrollbar().attachToExternalElement(host);
	this._grid.getHScrollbar().attachToExternalElement(host);
};

/**
* @private
* @param {string} field
* @returns {boolean}
*/
Grid.prototype._shouldLoadFieldInfo = function (field) {

	var val = this._RTK || window["JET"]; // Fastest checking can be performed by checking the first condition.
	if(!val) {
		return false;
	}

	// WARNING: If field caching is disabled, it shouldn't load field info
	if(!this._fieldCaching) {
		return false;
	}

	val = FieldDefinition.hasFieldInfo(field);
	if(val) {
		return false;
	}

	val = FieldDefinition.isAdc(field) || FieldDefinition.isRealTimeField(field);
	if(!val) {
		return false;
	}

	return true;
};
/** Remove all existing columns and add new columns based on the given objects
* @public
* @param {Array.&lt;Object&gt;} columns Array of column options
*/
Grid.prototype.setColumns = function(columns) {
	var grid = this._grid;
	var colCount = (columns) ? columns.length : 0;

	grid.startBatch("reset");
	this.removeAllColumns();
	if(colCount &gt; 0) {
		var prevState = false;
		if(colCount &gt; 1) {
			prevState = grid.freezeLayout(true); // Insert multiple columns can be a huge time consuming
		}
		for(var i = 0; i &lt; colCount; ++i) {
			this.insertColumn(columns[i], i);
		}
		if(colCount &gt; 1) {
			grid.freezeLayout(prevState);
		}
	}
	grid.stopBatch("reset");
};


/** Remove, add and keep column based on the given column data
* @public
* @param {Array.&lt;Object&gt;} columns Array of column options
*/
Grid.prototype.restoreColumns = function(columns) {
	var grid = this._grid;
	grid.startBatch("reset");
	var configObj = this.getConfigObject();
	var previousColumns = configObj.columns;

	var preColLen = previousColumns.length;
	var newColLen = columns.length;

	var removingFields = [];
	var keepingColumns = [];
	var columnOrdering = [];

	var i, j, found;
	// Slow, time complexity BigO(n ^ 2)
	for (i = 0; i &lt; preColLen; i++) {
		found = false;
		for (j = 0; j &lt; newColLen; j++) {
			if (deepEqual(previousColumns[i], columns[j])) {
				keepingColumns.push(previousColumns[i]);
				found = true;
				break;
			}
		}
		if (!found) {
			removingFields.push(previousColumns[i].field);
		}
	}

	this.removeColumns(removingFields);

	var keepingLen = keepingColumns.length;
	var prevState = false;
	if(newColLen &gt; 1) {
		prevState = this._grid.freezeLayout(true); // Insert multiple columns can be a huge time consuming
	}
	for (i = 0; i &lt; newColLen; i++) {
		found = false;
		for (j = 0; j &lt; keepingLen; j++) { // loop only keeping column
			if (deepEqual(columns[i], keepingColumns[j])) {
				found = true;
				var colIndex = this.getColumnIndex(columns[i].field); // We cannot use 'i' (colIndex) in this case, as it will sort the columns. Instead, we need to obtain a new column index from the field.
				columnOrdering.push(this.getColumnId(colIndex));
				break;
			}
		}
		if (!found) {
			this.insertColumn(columns[i], i);
			columnOrdering.push(this.getColumnId(i)); // Use new insertion column index
		}
	}

	if(newColLen &gt; 1) {
		this._grid.freezeLayout(prevState);
	}

	grid.reorderColumns(columnOrdering);
	grid.stopBatch("reset");
};

/** Remove all existing columns and add new columns based on the given texts/fields
* @public
* @function
* @param {Array.&lt;string&gt;} ary Array of fields (string)
* @see {@link Grid#setColumns}
*/
Grid.prototype.setFields = Grid.prototype.setColumns;

/** @private
* @param {Object} e
*/
Grid.prototype._onColumnAdded = function(e) {
	var colDef = /** @type{ColumnDefinition} */(e.context[COL_DEF]);
	delete e.context[COL_DEF];
	var idx = e.colIndex;

	var coreColDef = this._grid._getColumnDef(idx);
	colDef._setCoreColumnDef(coreColDef); // For column id and field

	var colData = this._grid.getColumnData(idx);
	if(!colData) { // Save column inside grid
		colData = this._grid.setColumnData(idx, {});
	}
	colData[COL_DEF] = colDef;
	var userModel = colDef.getUserModel();
	// binding
	this._grid.setColumnDataBindingHandler(idx, colDef.getRenderer());
	// width and scalable
	var value = userModel["width"];
	// eslint-disable-next-line no-undefined
	if(value !== undefined) {
		value = +value;
		var scalable;
		if(userModel["scalable"] != null) {
			scalable = userModel["scalable"] ? true : false;
		} else {
			scalable = value !== value; // NaN means scalable
		}
		this._grid.setColumnWidth(idx, value, scalable);
	} else {
		this._grid.setColumnWidth(idx, 1, true);
	}
	// minWidth
	value = userModel["minWidth"];
	if(value &gt;= 0) {
		this._grid.setMinimumColumnWidth(idx, value);
	}
	// hidden
	value = userModel["hidden"];
	if(value) {
		this._grid.hideColumn(idx, true);
	}
	// textAlign
	value = userModel["textAlign"] || userModel["alignment"];
	if(typeof value === "string") {
		this._grid.setColumnAlignment(idx, value);
	}
	if(!userModel["keepModel"]) {
		colDef.clearUserModel();
	}

	// text select flag per column
	// with this flag enabled user can select text in cell of this column
	if (colDef.isTextSelect()) {
		this._grid.enableColumnClass(idx, 'tr-text-select', true, "content");
	}

	// className
	var i, classes = colDef.getClasses();
	for(i = 0; i &lt; classes.length; i++) {
		this._grid.enableColumnClass(idx, classes[i]);
	}
	var colField = colDef.getField();
	this._grid.setDataColumnName(idx, ROW_DEF); // This make ColumnDefinition renderer work
	var fields = colDef.getAllFields();
	var referrer = colDef.getId();
	var len = fields.length;
	var field, dataType, prom, onLoaded;
	for(i = 0; i &lt; len; i++) {
		field = fields[i];
		if(this._shouldLoadFieldInfo(field)) {
			if(field === colField) {
				dataType = colDef.getDataType(); // Data-type from user's column options
			} else { // Other required fields
				dataType = ColumnDefinition.getDataType(field); // Data-type evaluated from FieldDefinition
			}
			prom = FieldDefinition.loadFieldInfo(field)
				.then(this._onFieldLoadedSuccess.bind(this, field, colDef))
				.catch(this._onFieldLoadedError);

			if(!dataType) {
				// wait field-info to be loaded before adding field
				onLoaded = this._onFieldLoaded.bind(this, field, referrer);
				prom = prom.then(onLoaded).catch(onLoaded);
			} else {
				if(colDef.isTimeSeries()) {
					this._populateTimeSeriesChildren(colDef);
				}
				this._connector.addFields(field, referrer);
			}
		} else {
			if(colDef.isTimeSeries()) {
				this._populateTimeSeriesChildren(colDef);
			}
			this._connector.addFields(field, referrer);
		}
	}
};

/** @public
* @param {Grid~ColumnReference} colRef
* @see {@link Grid#removeColumns}
* @see {@link Grid#removeAllColumns}
*/
Grid.prototype.removeColumn = function(colRef) {
	var colIndex = this.getColumnIndex(colRef);
	if(colIndex &lt; 0) {
		return;
	}

	var colDef = this.getColumnDefinition(colIndex);
	var children = colDef.getChildren();
	if(children) {
		var len = children.length;
		if(len &gt; 0) { // remove time series child
			var i, childDef;
			for (i = 0; i &lt; len; i++) {
				childDef = children[i];
				this.removeColumn(childDef);
			}
			colIndex = this.getColumnIndex(colRef); // children in parent will be remove the parent should be get new index
		}
	}

	if(!colDef.isRealTimeField()) {
		if(this._dc) {
			this._dc.removeStaticFields([colDef.getField()]);
		}
	}

	this._grid.removeColumnAt(colIndex);
	this._connector.removeFields(colDef);

	colDef.dispose(); // Dispose at the last line to avoid making properties inaccessible
	// TODO: Remove fields that are related to the column (e.g. fields for coloring)
};
/** Remove multiple columns through array. To remove all columns, use removeAllColumns() instead of this method
* @public
* @param {Array.&lt;Grid~ColumnReference&gt;} colRefs
* @see {@link Grid#removeColumn}
* @see {@link Grid#removeAllColumns}
*/
Grid.prototype.removeColumns = function(colRefs) {
	var indices = this.getColumnIndices(colRefs);
	var len = indices.length;
	if(len &lt;= 1) {
		if(len === 1) {
			this.removeColumn(indices[0]);
		}
		return;
	}
	indices.sort(Grid._descendingOrder); // Removal must be done from the back

	var staticFields = []; // For clearing any data stored in our cache
	var prevState = this._grid.freezeLayout(); // To prevent multiple UI updates

	for(var i = 0; i &lt; len; ++i) {
		var colIndex = indices[i];
		var colDef = this.getColumnDefinition(colIndex);
		if(!colDef.isRealTimeField()) {
			staticFields.push(colDef.getField());
		}
		colDef.dispose();
		this._grid.removeColumnAt(colIndex);
		this._connector.removeFields(colDef);
	}

	if(staticFields.length) {
		if(this._dc) {
			this._dc.removeStaticFields(staticFields);
		}
	}
	this._grid.freezeLayout(prevState);
};
/** Sorting is also cleared.
* @public
* @see {@link Grid#removeColumn}
* @see {@link Grid#removeColumns}
*/
Grid.prototype.removeAllColumns = function() {
	var colCount = this.getColumnCount();
	if(colCount &lt;= 0) {
		return;
	}

	if(!this._sharedSorter) {
		this.clearSort();
	}
	for(var i = colCount; --i &gt;= 0;) {
		// WARNING: This may affect plugins event listeners
		this._grid.setColumnDataBindingHandler(i, null);
		var colDef = this.getColumnDefinition(i);
		colDef.dispose();
	}
	// TODO: Remove fields that are related to the column (e.g. fields for coloring)

	this._columnTitleConflator.reset();
	this._timeSeriesChildConflator.reset();

	this._connector.removeAllFields();
	this._grid.setColumnCount(0);
	if(this._dc) {
		this._dc.resetStaticFields();
	}
};

/** Move the column at the specified index to the target index. When moving multiple columns, the original order of the source columns will be sorted by their index and the position of the columns will not be guaranteed to be exactly at the destination index.
* @public
* @param {number|Array.&lt;number&gt;} fromColIndex index or array of indices of the column(s) to be moved.
* @param {number} toColIndex target column index
* @return {boolean} Return true if there is any change, and false otherwise
* @see {@link Grid#moveColumnById}
*/
Grid.prototype.moveColumn = function (fromColIndex, toColIndex) {
	return this._grid.moveColumn(fromColIndex, toColIndex);
};
/** If source column is not found, no operation is performed. If destination column is not found, the source column will be moved to the last position.&lt;br&gt;
* Note: this method behaves slightly different from moveColumn method in that it always put source column at the position before the specified destination column, while moveColumn method will put column at exactly at the destination index.
* @public
* @param {number|string} srcCol Column Id or index
* @param {(number|string)=} destCol Column Id or index of the destination
* @return {boolean} Return true if there is any change, and false otherwise
* @see {@link Grid#moveColumn}
* @example
* grid.moveColumnById(3, 1); // Move column 3 to position before column 1
* grid.moveColumnById(0, 2); // Move column 0 to position before column 2 (column index 1)
* grid.moveColumnById(0, 1); // Nothing is moved
* grid.moveColumnById("sourceColumnId", "anotherId");
* grid.moveColumnById("sourceColumnId", ""); // move to the last position
*/
Grid.prototype.moveColumnById = function (srcCol, destCol) {
	return this._grid.moveColumnById(srcCol, destCol);
};

/** @public
* @param {number|string|Array.&lt;number|string&gt;} colRefs List of column index or column id to be moved
* @param {(number|string)=} destCol Destination position where the moved columns will be placed BEFORE the specified position. This can be column id or index
* @return {boolean} Return true if there is any change, and false otherwise
*/
Grid.prototype.reorderColumns = function (colRefs, destCol) {
	return this._grid.reorderColumns(colRefs, destCol);
};

/** The hidden column still occupies the same index.
* @public
* @param {Grid~ColumnReference} colRef
* @param {boolean=} hidden
* @see {@link Grid#hideColumns}
* @see {@link Grid#showAllColumns}
*/
Grid.prototype.hideColumn = function(colRef, hidden) {
	var colIndex = this.getColumnIndex(colRef);
	if(colIndex &lt; 0) { // not found
		return;
	}
	var colDef = this.getColumnDefinition(colIndex);
	var children = colDef.getChildren();
	var len = children.length;
	if(len &gt; 0) { // remove time series child, and parent shouldn't unHide
		var i, childDef;
		for (i = 0; i &lt; len; i++) {
			childDef = children[i];
			this.hideColumn(childDef, hidden);
		}
	} else {
		this._grid.hideColumn(colIndex, hidden);
	}

};
/** Hide multiple columns at once. The hidden columns still occupy the same index.
* @public
* @param {Array.&lt;Grid~ColumnReference&gt;} colRefs
* @param {boolean=} hidden
* @see {@link Grid#hideColumn}
* @see {@link Grid#showAllColumns}
*/
Grid.prototype.hideColumns = function(colRefs, hidden) {
	this._grid.hideColumns(this.getColumnIndices(colRefs), hidden);
};
/** @public
* @see {@link Grid#hideColumn}
* @see {@link Grid#hideColumns}
*/
Grid.prototype.showAllColumns = function() {
	this._grid.showAllColumns();
};
/** @private
* @function
* @param {number} a
* @param {number} b
* @return {number}
*/
Grid._descendingOrder = function(a, b) {
	return b - a;
};

/** Add fields for real-time data without adding column nor UIs. No duplication is allowed
* @public
* @param {string|Array.&lt;string&gt;} fieldRef
* @param {string=} referrer
* @return {boolean}
*/
Grid.prototype.addDataFields = function(fieldRef, referrer) {
	if(!fieldRef) {
		return false;
	}

	var fields = Array.isArray(fieldRef) ? fieldRef : [fieldRef];
	var len = fields.length;
	var i, field, dataType, prom, onLoaded;
	for(i = 0; i &lt; len; i++) {
		field = fields[i];
		if(this._shouldLoadFieldInfo(field)) {
			dataType = ColumnDefinition.getDataType(field);
			prom = FieldDefinition.loadFieldInfo(field)
				.catch(this._onFieldLoadedError);

			if(!dataType) {
				// wait field-info to be loaded before adding field
				onLoaded = this._onFieldLoaded.bind(this, field, referrer);
				prom = prom.then(onLoaded).catch(onLoaded);
			} else {
				this._connector.addFields(field, referrer || "grid");
			}
		} else {
			this._connector.addFields(field, referrer || "grid");
		}
	}

	return true;
};
/** Add fields for real-time data without adding column nor UIs. No duplication is allowed
* @public
* @param {string|Array.&lt;string&gt;} fieldRef
* @param {string=} referrer
* @return {boolean}
*/
Grid.prototype.removeDataFields = function(fieldRef, referrer) {
	if(!fieldRef) {
		return false;
	}

	this._connector.removeFields(fieldRef, referrer || "grid");
	return true;
};
/** @public
* @param {string} referrer
*/
Grid.prototype.removeFieldReferrer = function(referrer) {
	if(!referrer) {
		return;
	}

	this._connector.removeFieldReferrer(referrer);
};

/** @public
* @param {Grid~ColumnReference} colRef
* @param {string=} opt_order This can be "ascending", "descending", "none", "noOrder", or "originalOrder"
*/
Grid.prototype.sortColumn = function(colRef, opt_order) {
	if(typeof colRef === "string") {
		this._stp.sortColumn(colRef, opt_order); // Allow sorting by field
		return;
	}

	var colIndex = this.getColumnIndex(colRef);
	if(colIndex &lt; 0) {
		this._stp.sortColumn(this.getSortedColumnIndex(), "n"); // reset current sorting
	} else {
		this._stp.sortColumn(colIndex, opt_order);
	}
};
/** @public
* @param {number} colIndex
* @param {string} str
*/
Grid.prototype.setColumnName = function(colIndex, str) {
	var colDef = this.getColumnDefinition(colIndex);
	if(colDef) {
		colDef.setName(str);
		this.updateColumnTitle();
	}
};
/** @public
* @param {Grid~ColumnReference} colRef
* @param {Function=} func
*/
Grid.prototype.setColumnRenderer = function(colRef, func) {
	var colIndex = this.getColumnIndex(colRef);
	this.setColumnFormatter(colIndex, func);
};

/** @public
* @param {Grid~ColumnReference} colRef Column index or id
* @param {string=} id ID for renderer mapping. If not specified the default renderer will be picked up
* @param {Function=} func If not specified the renderer which corresponded id from mapping will be picked up
*/
Grid.prototype.activateColumnRenderer = function(colRef, id, func) {
	var colIndex = this.getColumnIndex(colRef);
	if (colIndex == null) { return; }

	var colDef = this.getColumnDefinition(colIndex);
	if(!colDef) { return; }

	colDef.activateRenderer(id, func);

	this._grid.setColumnDataBindingHandler(colIndex, colDef.getRenderer());
	this._grid.requestRowRefresh();
};

/**
 * @public
 * @param {number} colIndex Column index of the position of the column to be updated
 * @param {Object|Function=} formatter Formatter object or bind function
 */
Grid.prototype.setColumnFormatter = function (colIndex, formatter) {
	if (colIndex == null) { return; }

	var colDef = this.getColumnDefinition(colIndex);
	if(!colDef) {
		return;
	}

	var func = null;
	if (formatter) {
		if(typeof formatter === "object") {
			if(typeof formatter.init === "function") { // Initialize predefined formatter
				// WARNING: Column definition has not been updated
				formatter.init(colDef.getConfigObject(), this._grid);
			}
			func = formatter.binding;
		} else {
			func = formatter;
		}
		if(typeof func !== "function") {
			func = null;
		}
	}

	if(func !== colDef.getRenderer()) {
		var section = this._grid.getSection("content");
		var col = /** @type {Column} */section.getColumn(colIndex);
		if (col) {
			col.clearContent();
		}

		this._grid.setColumnDataBindingHandler(colIndex, null);

		colDef.setRenderer(func);

		this._grid.setColumnDataBindingHandler(colIndex, colDef.getRenderer());
		this._grid.requestRowRefresh();
	}
};

/** @public
* @param {Grid~ColumnReference} colRef
* @param {ColumnDefinition~SortLogic=} func
*/
Grid.prototype.setColumnSorter = function(colRef, func) {
	var colIndex = this.getColumnIndex(colRef);
	var colDef = this.getColumnDefinition(colIndex);
	if(colDef) {
		colDef.setSorter(func);

		var sortedColumn = this.getSortedColumnIndex(); // TODO: Support multi-column sorting
		if(sortedColumn === colIndex) {
			this._stp.refresh();
		}
	}
};


/** Initialize data for the given rowDef from another rowDef with the same RIC
* @public
* @param {RowDefinition} rowDef
*/
Grid.prototype._initDuplicateRicData = function(rowDef) {
	var ric = rowDef.getSymbol();
	var rowDefs = this._connector.getRowDefByRic(ric);
	if(rowDefs &amp;&amp; rowDefs.length) {
		cloneRowData(rowDefs[0], rowDef);
	}
};
/** @public
* @param {Object=} rowOption
* @param {Grid~RowReference=} rowRef Reference (i.e. row index, row id, or row definition) of the insert position
* @returns {Object}
* @example
* var grid = new rt.Grid(grid_div, options);
* grid.insertRow({"ric": "RIC"}, 0); // A new row is added at the top
*/
Grid.prototype.insertRow = function(rowOption, rowRef) {
	if(this._mainGrid) {
		return this._mainGrid.insertRow(rowOption, this._getRowId(rowRef));
	}

	if(rowOption) {
		if(typeof rowOption === "string") {
			rowOption = { "ric": rowOption };
		} else if(Array.isArray(rowOption["values"])) {
			if(!rowOption["fields"]) { // Static values are defined but no fields
				rowOption["fields"] = this.getColumnFields(); // For initializing static value
			}
		}
	}
	var rowDef = new RowDefinition(rowOption);
	rowDef.setDataSource(this._dc); // This could also subscribe chain index/ric to JET/RTK
	this._initDuplicateRicData(rowDef);

	rowDef.registerToView(this._dv, this._getRowId(rowRef));
	if(rowOption &amp;&amp; rowOption["hidden"]) {
		this._dv.hideRow(rowDef.getRowId()); // Try to obtain rowId in rowDef since rowId is not assigned when new rows are created.
	}
	this._connector.addRic(rowDef);
	return rowDef;
};
/** @public
* @param {Array.&lt;Object&gt;} rowOptions Array of row option object
* @param {Grid~RowReference=} rowRef Reference (i.e. row index, row id, or row definition) of the insert position
* @param {Array.&lt;string&gt;=} opt_fields
* @example
* var grid = new rt.Grid(grid_div, options);
* grid.insertRows([
*  {ric: "RIC"},
*  {values: {"field1": 0, "field2": 1}},
*  {ric: "RIC2", values: [1, 2, 3, 4]},
*  null
* ]); // 4 rows are appended
*/
Grid.prototype.insertRows = function(rowOptions, rowRef, opt_fields) {
	if(this._mainGrid) {
		this._mainGrid.insertRows(rowOptions, this._getRowId(rowRef));
		return;
	}
	if(!Array.isArray(rowOptions)) {
		return;
	}

	var prevState = this._dt.freeze(); // Avoid sorting for each inserted row
	var fields = opt_fields || this.getColumnFields();
	var rowId = this._getRowId(rowRef);
	var len = rowOptions.length;
	for(var r = 0; r &lt; len; ++r) {
		var rowOption = rowOptions[r];
		if(rowOption) {
			if(typeof rowOption === "string") {
				rowOption = { "ric": rowOption };
			}
			rowOption["fields"] = fields; // For initializing static value
		}
		this.insertRow(rowOption, rowId); // Note that data view is being frozen, so only using row id will work properly
	}
	this._dt.freeze(prevState);
};
/** Add multiple rows without `ric` property in {@link RowDefinition}
* @public
* @param {Array} dataRows 2D Array of data or Array of Field/Value pair object
* @param {Array.&lt;string&gt;=} fields If no field is given, field defined in column definition will be used instead
* @see {@link Grid#logDV}
* @see {@link Grid#logDT}
* @example
* var grid = new rt.Grid(grid_div, options);
* grid.addStaticDataRows([
*  [10, "a", true],
*  [20, "b", false],
*  [30, "c", true]
* ], ["field1", "field2", "field3"]); // 3 rows are appended
*
* grid.addStaticDataRows([ // Object format can also be used
*  {"field1": 40, "field2": "a",  "field3": true},
*  {"field1": 50, "field2": "b"}, // each row doesn't have to be the same
*  {"field1": 60, "field4": "some thing"}
* ]); // 3 more rows are appended
* grid.logDV({"colNames": ["field1", "field2", "field3", "field4"]}); // See results in console
*/
Grid.prototype.addStaticDataRows = function(dataRows, fields) {
	if(this._mainGrid) {
		this._mainGrid.addStaticDataRows(dataRows, fields);
		return;
	}

	if(!Array.isArray(dataRows)) {
		var userObj = dataRows;
		dataRows = null;
		if(userObj) {
			if(userObj.fields &amp;&amp; !fields) {
				fields = userObj.fields;
			}
			if(Array.isArray(userObj.data)) { // dataRows must has an array type
				dataRows = userObj.data;
			}
		}
	}
	if(dataRows) {
		this.insertRows(dataRows.map(Grid._dataToRowOptions), null, fields);
	}
};
/** Insert, update, remove and reorder data based on the given array of records
* @public
* @param {Array.&lt;Object&gt;} records Array of records for insert, remove, update, reorder in one operation
* @param {string} rowIdentifier Check difference data with the row identifier map property for operate record.
* @example
* // Grid data set will be updated to 3 records. All rows in the grid will be cleared and new rows will be inserted
* grid.updateDataSet([
* 	{ id: "A", field2: 1, field3: 2, field4: "Something A" },
*	{ id: "B", field2: 1, field3: 2, field4: "Something B" },
* 	{ id: "C", field2: 1, field3: 2, field4: "Something C" },
* ], "id");
* // Update record id "B" in "field2", "field3" value 100, 200
* grid.updateDataSet([
* 	{ id: "A", field2: 1, field3: 2, field4: "Something A" },
* 	{ id: "B", field2: 100, field3: 200, field4: "Something B" },
* 	{ id: "C", field2: 1, field3: 2, field4: "Something C" },
* ], "id");
* // Delete record id "B"
* grid.updateDataSet([
* 	{ id: "A", field2: 1, field3: 2, field4: "Something A" },
* 	{ id: "C", field2: 1, field3: 2, field4: "Something C" },
* ], "id");
* // Insert record id "D"
* grid.updateDataSet([
* 	{ id: "A", field2: 1, field3: 2, field4: "Something A" },
* 	{ id: "C", field2: 1, field3: 2, field4: "Something C" },
* 	{ id: "D", field2: 1, field3: 2, field4: "Something D" },
* ], "id");
* // Reorder to "D", "C", "A"
* grid.updateDataSet([
* 	{ id: "D", field2: 1, field3: 2, field4: "Something D" },
* 	{ id: "C", field2: 1, field3: 2, field4: "Something C" },
* 	{ id: "A", field2: 1, field3: 2, field4: "Something A" },
* ], "id");
* // Insert, Update, Delete And Reorder
* grid.updateDataSet([
* 	{ id: "F", field2: 1, field3: 2, field4: "Something F" },
* 	{ id: "D", field2: 1, field3: 2, field4: "Something D" },
* 	{ id: "C", field2: 1, field3: 2, field4: "Something C" },
* 	{ id: "E", field2: 1, field3: 2, field4: "Something E" },
* ], "id");
*/
Grid.prototype.updateDataSet = function(records, rowIdentifier) {
	if(!Array.isArray(records) || records.length === 0 ) {
		this.removeAllRows();
		return;
	}

	// Map new data index
	var newDataMap = {};
	var recordCount = records.length;
	var record, i;
	for (i = 0; i &lt; recordCount; i++) {
		record = records[i];
		newDataMap[record[rowIdentifier]] = record; // Assign a new data map to compare to the previous data
	}

	var fieldSorting = "ROW_ORDER"; // TODO: Should be config by options
	records.forEach(mapRowOrder.bind(null, fieldSorting));

	var oldDataMap = {};
	var rowDef, id;
	var rowDefs = this.getRowDefinitions(); // WARNING: Filtered and hidden rows are not included
	var rowDefCount = rowDefs.length;
	for (i = 0; i &lt; rowDefCount; i++) {
		rowDef = rowDefs[i];
		if(rowDef) {
			id = rowDef.getRowData()[rowIdentifier];
			if(id || id === 0) {
				oldDataMap[id] = rowDef;
			} else { // Any existing rowDef without row identifier should be removed
				this.removeRow(rowDef); // Slow
			}
		}
	}

	// Check Remove previous data
	for (var rowIdentifierName in oldDataMap) {
		if (oldDataMap[rowIdentifierName] &amp;&amp; !newDataMap[rowIdentifierName]) {
			this.removeRow(oldDataMap[rowIdentifierName]); // Slow
		}
	}

	// Check Update and Insert
	for (i = 0; i &lt; recordCount; i++) {
		record = records[i];
		id = record[rowIdentifier];
		rowDef = oldDataMap[id];
		if (!rowDef) {
			this.insertRow({ values: newDataMap[id]}); // Insert last position
		} else {
			rowDef.setRowData(record);
		}
	}
	// Sorting
	this._dt.sortOnce("ROW_DEF", "a", compareNumber, fieldSorting);
};
/** @private
* @param {Array|Object} item
* @return {!Object}
*/
Grid._dataToRowOptions = function(item) {
	return {values: item};
};
/** @public
* @param {Grid~RowReference} rowRef
* @return {RowDefinition}
* @see {@link Grid#removeRows}
* @see {@link Grid#removeAllRows}
*/
Grid.prototype.removeRow = function(rowRef) {
	if(this._mainGrid) {
		return this._mainGrid.removeRow(this._getRowId(rowRef));
	}
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		if(!rowDef.isAutoGenerated()) { // Users cannot remove auto-generated row by themselves
			this._removeRow(rowDef);
		}
	}
	return rowDef;
};
/** Remove multiple rows at once. This prevents duplicate operation and improve performance. To remove all rows, use removeAllRows() method instead of this method.
* @public
* @param {Array.&lt;Grid~RowReference&gt;} rowRefs
* @return {Array.&lt;RowDefinition&gt;} Array of removed row definitions
* @see {@link Grid#removeRow}
* @see {@link Grid#removeAllRows}
*/
Grid.prototype.removeRows = function(rowRefs) {
	var rowDef;
	if(!Array.isArray(rowRefs)) {
		rowDef = this.removeRow(rowRefs);
		return rowDef ? [rowDef] : [];
	}
	if(this._mainGrid) {
		return this._mainGrid.removeRows(rowRefs.map(this._getRowId));
	}

	var i;
	var rowDefs = [];
	var len = rowRefs.length;

	// Verify user input
	for(i = 0; i &lt; len; ++i) {
		rowDef = this._getRowDefinitionByRef(rowRefs[i]);
		if(rowDef) {
			if(!rowDef.isAutoGenerated()) {
				rowDefs.push(rowDef);
			}
		}
	}
	len = rowDefs.length;

	var prevState = false;
	if(len &gt; 1) {
		prevState = this._dt.freeze(); // Prevent multiple changes that trigger sorting and filtering
	}

	for(i = 0; i &lt; len; ++i) {
		this._removeRow(rowDefs[i]);
	}

	if(len &gt; 1) {
		this._dt.freeze(prevState);
	}
	return rowDefs;
};
/** @public
* @see {@link Grid#removeRow}
* @see {@link Grid#removeRows}
*/
Grid.prototype.removeAllRows = function() {
	if(this._sharedDataSource) {
		return;
	}
	if(!this._dt.getRowCount()) {
		return;
	}
	var rowDefs = this._getAllRowDefinitions();

	if(!this._sharedDataSource) {
		this._dc.clearAllData();
		this._dt.clearAllData();
		this._clearDataUpdates();
	}

	rowDefs.forEach(RowDefinition.dispose);

	this._streamingConflator.reset();
	this._formulaConflator.reset();
	this._chainConflator.reset();
	this._connector.removeAllRics();

	// TODO: This logic should also be in the core grid
	this._grid.getVScrollbar().setScrollTop(0);
	this._grid.getHScrollbar().setScrollLeft(0);
};
/** WARNING: This does not remove data stored in the data cache
* @private
* @param {!RowDefinition} rowDef
*/
Grid.prototype._removeRow = function(rowDef) {
	if(this._sharedDataSource) {
		return;
	}
	this._dispatch("beforeRowRemoved", {});

	var connector = this._connector;
	var dt = this._dt;
	var childRowDefs = rowDef.getDescendants(); // TODO: Support nested child
	if(childRowDefs) { // Remove all children first
		for(var i = 0; i &lt; childRowDefs.length; i++) {
			connector.removeRic(childRowDefs[i]);
		}
		var rowIds = childRowDefs.map(RowDefinition.toRowId);
		dt.removeRows(rowIds);
	}
	connector.removeRic(rowDef);
	dt.removeRow(rowDef.getRowId()); // TODO: Merge this with the above removeRows() method
	rowDef.dispose(); // WARNING: This does not remove child reference from its parent
};

/** @public
* @param {Grid~RowReference} rowRef
* @param {boolean=} hidden if false, show instead of hide
*/
Grid.prototype.hideRow = function(rowRef, hidden) {
	var rid = this._getRowId(rowRef);
	var grid = this._mainGrid || this._grid;
	grid.hideRow(rid, hidden);
};

/** Hide row(s) in the Grid by specifying the rIds
* @param {Grid~RowReference | Array.&lt;Grid~RowReference&gt;} rowRefs
* @param {boolean=} hidden if false, show instead of hide
* @public
*/
Grid.prototype.hideRows = function (rowRefs, hidden) {
	if (!Array.isArray(rowRefs)) {
		rowRefs = [rowRefs];
	}
	var rids = rowRefs.map(this._getRowId);
	var grid = this._mainGrid || this._grid;
	grid.hideRows(rids, hidden);
};
/**
* Show row(s) in the Grid by specifying the rIds
* @param {Grid~RowReference | Array.&lt;Grid~RowReference&gt;} rowRefs
* @param {boolean=} shown if false, hide instead of show
* @public
*/
Grid.prototype.showRows = function (rowRefs, shown) {
	this.hideRows(rowRefs, shown === false);
};
/**
 * Unhide all hidden rows in the Grid
 * @public
 */
Grid.prototype.unhideAllRows = function () {
	this._grid.unhideAllRows();
};
/**
* @public
* @returns {boolean}
*/
Grid.prototype.hasHiddenRow = function(){
	return this._grid.hasHiddenRow();
};

/** Set RIC to the specified row
* @public
* @param {Grid~RowReference} rowRef
* @param {string} str RIC to be set to a row
* @param {RowDefinition~Options=} options
*/
Grid.prototype.setRic = function(rowRef, str, options) {
	if(this._mainGrid) {
		this._mainGrid.setRic(this._toRowId(rowRef), str, options);
		return;
	}
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		options = options || {};
		options["ric"] = str;
		var extractedOptions = RowDefinition.extractRowOptions(options);
		var oldRic = rowDef.getSymbol();
		var permId = options["permId"];
		var expanded = null;
		var collapsed = options["collapsed"];
		if(collapsed != null){
			expanded = !extractedOptions["collapsed"];
		}
		if(rowDef.setContent(str, permId, extractedOptions["asChain"], expanded)) { // The given string may not be a RIC
			this._connector.removeRic(rowDef, oldRic);
			this._initDuplicateRicData(rowDef);
			this._connector.addRic(rowDef);
		}

		var values = options["values"];
		if(values != null) {
			rowDef.setStaticRowData(values, options["fields"]);
		}
	}
};
/** Unlink the chain and its constituents. When the chain is expanded,
 * the chain row and its members are converted from autogenerated to
 * regular real-time rows. Only the chain row will be transformed to
 * a conventional real-time row if the chain is collapsed.
 * All converted rows will continue to have their data updated.
 *
 * @public
 * @param {Grid~RowReference} rowRef
 */
Grid.prototype.unlinkChain = function(rowRef) {
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(!rowDef) {
		return;
	}

	if(!rowDef.isChain()) {
		return;
	}

	rowDef.unlinkChain();
};

/** Alias to setRic
* @public
* @function
* @param {Grid~RowReference} rowRef
* @param {string} str
* @see {@link Grid.setRic}
*/
Grid.prototype.setRowContent = Grid.prototype.setRic;

/**
* @public
* @param {string|number} rid Row Id or index
* @param {boolean=} force
*/
Grid.prototype.toggleRowExpansion = function(rid, force) {
	this._dv.toggleRowExpansion(rid, force);
};
/**
* @private
* @param {object} e
*/
Grid.prototype._onRowExpansionBinding = function(e) {
	if(!this.hasListener("rowExpansionBinding")) {
		return;
	}

	if(e["originalRowId"]) {
		var rowIndex = this._dv.getRowIndex(e["originalRowId"]);
		e["originalRowDef"] = this._getRowDefinitionByIndex(rowIndex);
		e["originalRowData"] = e["originalRowDef"].getRowData();
	} else {
		e["rowDef"] = this._getRowDefinitionByIndex(e["rowIndex"]);
		e["rowData"] = e["rowDef"].getRowData();
	}

	this._dispatch("rowExpansionBinding", e);
};

/** Reset existing rows. It is a combination of insertRows and removeAllRows.
* @public
* @param {Array.&lt;string&gt;} ary
*/
Grid.prototype.setRics = function(ary) {
	this.removeAllRows();
	if(ary &amp;&amp; ary.length) {
		this.insertRows(ary);
	}
};

/** WARNING: This represents number of visible rows in a single grid
* @public
* @return {number}
*/
Grid.prototype.getRowCount = function() {
	return this._dv.getRowCount();
};
/** Get all rows without paging
* @public
* @return {number}
*/
Grid.prototype.getPageItemCount = function() {
	return this._dv.getRowCount(false, true);
};
/** WARNING: This represents number of rows in the DataTable which includes all invisible rows and rows in multiple wrapped grids
* @public
* @return {number}
*/
Grid.prototype.getDataRowCount = function() {
	return this._dt.getRowCount();
};
/** @public
* @return {number}
*/
Grid.prototype.getColumnCount = function() {
	return this._grid.getColumnCount();
};
/** @public
* @param {number} colIndex
* @return {string}
*/
Grid.prototype.getColumnDataType = function(colIndex) {
	var colDef = this.getColumnDefinition(colIndex);
	if (colDef) {
		return colDef.getDataType();
	}
	return '';
};
/** @public
* @param {number} colIndex
* @return {ColumnDefinition}
*/
Grid.prototype.getColumnDefinition = function(colIndex) {
	var colData = this._grid.getColumnData(colIndex);
	if(colData) {
		return /** @type{ColumnDefinition} */(colData[COL_DEF]) || null;
	}
	return null;
};
/** @public
* @return {!Array.&lt;ColumnDefinition&gt;}
*/
Grid.prototype.getColumnDefinitions = function() {
	var colCount = this.getColumnCount();
	var colDefs = new Array(colCount);
	for(var i = 0; i &lt; colCount; i++) {
		colDefs[i] = this.getColumnDefinition(i);
	}
	return colDefs;
};

/** @public
* @param {string} colId
* @return {ColumnDefinition}
*/
Grid.prototype.getColumnDefinitionById = function(colId) {
	if(typeof colId === "string") {
		return this.getColumnDefinition(this.getColumnIndex(colId));
	}
	return null;
};

/** @public
* @param {Array.&lt;string&gt;} colIds
* @return {ColumnDefinition}
*/
Grid.prototype.getColumnDefinitionsById = function(colIds) {
	var colCount = Array.isArray(colIds) ? colIds.length : 0;
	if(colCount &gt; 0) {
		var i, colId;
		var colDefs = new Array(colCount);
		for(i = 0; i &lt; colCount; i++) {
			colId = colIds[i];
			colDefs[i] = this.getColumnDefinitionById(colId);
		}
		return colDefs;
	}
	return null;

};
/** @private
* @param {Grid~ColumnReference} colRef
* @return {ColumnDefinition}
*/
Grid.prototype._getColumnDefinition = function(colRef) {
	if(colRef instanceof ColumnDefinition) {
		return /** @type{!ColumnDefinition} */(colRef);
	} else if(typeof colRef === "number") {
		return this.getColumnDefinition(colRef);
	} else if(typeof colRef === "string") {
		var colCount = this.getColumnCount();
		for(var i = 0; i &lt; colCount; ++i) {
			var colDef = this.getColumnDefinition(i);
			if(_hasFieldOrId(colDef, colRef)) {
				return colDef; // Return the first found column
			}
		}
	}
	return null;
};
/** @public
* @param {number|string} rowRef Row index as shown in the view or row id (string)
* @return {string}
*/
Grid.prototype.getRowType = function(rowRef) {
	var rowDef = this.getRowDefinition(rowRef);
	return rowDef ? rowDef.getType() : "";
};
/** Get RowDefinition object by either number or row id
* @public
* @param {number|string} rowRef Row index as shown in the view or row id (string)
* @return {RowDefinition}
*/
Grid.prototype.getRowDefinition = function(rowRef) {
	if(typeof rowRef === "number") {
		return this._getRowDefinitionByIndex(rowRef);
	} else if(typeof rowRef === "string") {
		return this._getRowDefinitionById(rowRef);
	}
	return null;
};
/** @private
* @param {number} rowIndex
* @return {RowDefinition}
*/
Grid.prototype._getRowDefinitionByIndex = function(rowIndex) {
	return this._dv.getDataAt(rowIndex, ROW_DEF) || null;
};
/** @private
* @param {string} rowId
* @return {RowDefinition}
*/
Grid.prototype._getRowDefinitionById = function(rowId) {
	return this._dt.getData(rowId, ROW_DEF) || null;
};
/** @private
* @param {Grid~RowReference} rowRef
* @return {RowDefinition}
*/
Grid.prototype._getRowDefinitionByRef = function(rowRef) {
	if(rowRef instanceof RowDefinition) {
		if(rowRef.getRowId()) { // The row may have been removed from the grid
			return /** @type{!RowDefinition} */(rowRef);
		}
	}
	return this.getRowDefinition(rowRef);
};
/** Get all row definitions shown in the view, excluding rows that are hidden by filtering or pagination. &lt;br&gt;
* A new array object is created every time. Do not call this method repeatedly.&lt;br&gt;
* Group header row will return null for its rowDefinition since the row is auto generated and has no data nor definition.
* @public
* @return {!Array.&lt;RowDefinition&gt;}
*/
Grid.prototype.getRowDefinitions = function() {
	return this._dv.getColumnData(ROW_DEF, true); // Include group header rows
};
/** Get all row definitions, including filtered and hidden rows, but without group header rows.
* @private
* @return {!Array.&lt;RowDefinition&gt;}
*/
Grid.prototype._getAllRowDefinitions = function() {
	return this._dt.getColumnData(ROW_DEF); // no group header rows
};

/** Get all row definitions, including filtered and hidden rows, but without auto generated rows (i.e., group header and chain constituent).
* @public
* @param {boolean=} inclAutoGenerated=false Set to true to include auto generated rows. Default value is false (exclude auto generated rows)
* @return {!Array.&lt;RowDefinition&gt;}
*/
Grid.prototype.getAllRowDefinitions = function(inclAutoGenerated) {
	if(inclAutoGenerated) {
		return this._getAllRowDefinitions();
	}
	return this._dt.getColumnData(ROW_DEF).filter(excludeAutoGenerated);
};
/** A shorthand to retrieve row data based on index of the specified row.
* @public
* @param {number} rowIndex Row index as shown in the view
* @return {Object} "FIELD1": value1, "FIELD2": value2, ...
*/
Grid.prototype.getRowData = function(rowIndex) {
	return toRowData(this._getRowDefinitionByIndex(rowIndex));
};
/** Get data from multiple rows. If null or undefined value is given, data from all rows are returned.
* @public
* @param {*=} obj The value can be rowIndex, array of row indices, array of row definitions, DataView instance, null or undefined
* @return {!Array.&lt;Object&gt;}
* @example
* grid.getMultipleRowData(); // All row data are returned
* grid.getMultipleRowData([0, 2, 4]); // Three row data are returned
* grid.getMultipleRowData(1); // One row data from the specified row index is returned
* grid.getMultipleRowData(DataView); // All row data from the specified DataView instance are returned
*/
Grid.prototype.getMultipleRowData = function(obj) {
	if(typeof obj === "number") {
		return [this.getRowData(obj)];
	}
	var rowDefs = null;
	if(Array.isArray(obj)) {
		var rowRefs = obj;
		var rowCount = rowRefs.length;
		var rows = new Array(rowCount);
		rowDefs = this.getRowDefinitions();

		for(var r = 0; r &lt; rowCount; ++r) {
			var rowRef = rowRefs[r];
			if(typeof rowRef === "number") {
				rows[r] = toRowData(rowDefs[rowRef]);
			} else if(rowRef &amp;&amp; rowRef.getRowData) {
				rows[r] = toRowData(rowRef);
			}
		}
		return rows;
	}

	if(obj &amp;&amp; obj.getColumnData) { // Check if the given reference is DataView or DataTable
		rowDefs = obj.getColumnData(ROW_DEF, false); // Get all row data WITHOUT group header rows
	} else {
		rowDefs = this.getRowDefinitions(); // Get all row definition from current view INCLUDING group header rows
	}
	return rowDefs.map(toRowData);
};
/** Set row data base on RIC.
* @public
* @param {string} ric
* @param {Object} values {"FIELD1": value1, "FIELD2": value2, ...} Use null to remove current row data (not row in the view).
*/
Grid.prototype.setRicData = function(ric, values) {
	var rowDefs = this._connector.getRowDefByRic(ric);
	var rowCount = rowDefs ? rowDefs.length : 0;
	for (var i = 0; i &lt; rowCount; ++i) {
		var rowDef = rowDefs[i];
		if (rowDef &amp;&amp; rowDef.getSymbol() === ric) {
			rowDef.setRowData(values); // TODO: Need conflator to improve performance
		}
	}
};
/** A shorthand to set row data based on index of the specified row. It is better to keep rowDefinition object for updating data directly as row index can be changed by sorting and filtering.
* @public
* @param {Grid~RowReference} rowRef
* @param {Object} values {"FIELD1": value1, "FIELD2": value2, ...} Use null to remove current row data (not row in the view).
*/
Grid.prototype.setRowData = function(rowRef, values) {
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		rowDef.setRowData(values);
	}
};

/**
* @public
* @param {Grid~RowReference} rowRef
* @param {Object} values
*/
Grid.prototype.setStaticRowData = function(rowRef, values) {
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		rowDef.setStaticRowData(values);
	}
};

/**
* @public
* @param {Grid~RowReference} rowRef
* @param {string} field
* @param {*} value
*/
Grid.prototype.setStaticData = function(rowRef, field, value) {
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		rowDef.setStaticData(field, value);
	}
};

/** @private
* @param {Grid~RowReference=} rowRef
* @return {string}
*/
Grid.prototype._getRowId = function(rowRef) {
	if(typeof rowRef === "string") {
		return rowRef;
	} else if(typeof rowRef === "number") { // WARNING: This is view index, excluding hidden row
		return this._dv.getRowId(rowRef);
	} else if(rowRef instanceof RowDefinition) {
		return rowRef.getRowId();
	}
	return "";
};

/** @public
* @param {Grid~ColumnReference} colRef
* @return {number}
*/
Grid.prototype.getColumnIndex = function(colRef) {
	if(colRef) {
		var colCount = this.getColumnCount();
		if(colRef instanceof ColumnDefinition) {
			for(var i = 0; i &lt; colCount; ++i) {
				var colDef = this.getColumnDefinition(i);
				if(colDef === colRef) {
					return i;
				}
			}
			return -1;
		}
	}
	return this._grid.getColumnIndex(colRef);
};
/** Any invalid column reference will be excluded from the output array
* @public
* @param {Array.&lt;Grid~ColumnReference&gt;} colRefs
* @return {!Array.&lt;number&gt;}
*/
Grid.prototype.getColumnIndices = function(colRefs) {
	var ary = [];
	var colCount = this.getColumnCount();
	var inputAry = Array.isArray(colRefs) ? colRefs : [colRefs];
	var len = inputAry.length;
	// Verify user input
	for(var i = 0; i &lt; len; ++i) {
		var colIndex = this.getColumnIndex(inputAry[i]);
		if(colIndex &gt;= 0 &amp;&amp; colIndex &lt; colCount) {
			ary.push(colIndex); // WARNING: We have not checked for duplication
		}
	}
	return ary;
};
/** Return column id that is set through configuration object
* @public
* @param {number} colIndex
* @return {string} Return empty string if no existing id or column
* @see {@link Grid#getColumnDefinition}
*/
Grid.prototype.getColumnId = function(colIndex) {
	return this._grid.getColumnId(colIndex);
};
/** Get ids from each column definition.
* @public
* @return {!Array.&lt;string&gt;} New array is created
*/
Grid.prototype.getColumnIds = function() {
	return this._grid.getColumnIds();
};
/** Return field defined in the column definition
* @public
* @param {number} colIndex
* @return {string}
* @see {@link Grid#getColumnDefinition}
*/
Grid.prototype.getColumnField = function(colIndex) {
	return this._grid.getColumnField(colIndex);
};
/** Get fields from each column definition. Note that this does not include any required field or data fields. Duplicates may exist.
* @public
* @return {!Array.&lt;string&gt;} New array is created
*/
Grid.prototype.getColumnFields = function() {
	return this._grid.getColumnFields();
};
/** Get column name from each column definition. Note that this does not include any required field or data fields. Duplicates may exist.
* @public
* @return {!Array.&lt;string&gt;} New array is created
*/
Grid.prototype.getColumnNames = function() {
	return this.getColumnDefinitions().map(_getName);
};
/** Get all fields, including required fields and data fields, with no duplicate
* @public
* @return {!Array.&lt;string&gt;} New array is created
*/
Grid.prototype.getAllFields = function() {
	return this._connector.getAllFields();
};
/** Freeze the column at the left side of the table starting from index 0 to the specified colIndex
* If no index is specified (null or undefined index), unfreeze all columns.
* @public
* @param {number=} colIndex Negative index is equivalent to null value
* @param {number=} pinnedRightColumns Number of columns to be pinned/snapped on the right side
*/
Grid.prototype.freezeColumn = function(colIndex, pinnedRightColumns) {
	if(colIndex == null) {
		colIndex = -1;
	}
	this._grid.freezeColumn(colIndex, pinnedRightColumns);
};

/** Pin column to the left side by moving the specified column to the rightmost of the frozen columns. &lt;br&gt;
* The method will do nothing if the specified column is already pinned to the left side
* @public
* @param {Grid~ColumnReference|Array.&lt;Grid~ColumnReference&gt;} colRef
* @param {string=} side Available values are: left|right. If no value is supplied, the column will be pinned to the left.
* @return {boolean}
*/
Grid.prototype.pinColumn = function(colRef, side) {
	if(Array.isArray(colRef)) {
		var ary = colRef;
		var len = ary.length;

		var dirty = 0;
		for(var i = 0; i &lt; len; ++i) {
			dirty |= this._pinColumn(ary[i], side);
		}
		return dirty ? true : false;
	}
	return this._pinColumn(colRef, side);
};
/** @private
* @param {Grid~ColumnReference} colRef
* @param {string=} side Available values are: left|right. If no value is supplied, the column will be pinned to the left.
* @return {boolean}
*/
Grid.prototype._pinColumn = function(colRef, side) {
	var colIndex = this.getColumnIndex(colRef);
	var colCount = this.getColumnCount();
	if(colIndex &lt; 0 || colIndex &gt; colCount) {
		return false;
	}

	var leftPinnedCount = this._grid.getPinnedLeftColumnCount();
	var rightPinnedCount = this._grid.getPinnedRightColumnCount();
	var stationaryIdx = this._grid.getStationaryColumnIndex();

	if(side &amp;&amp; side.toLowerCase() === "right") {
		var rightPinnedIndex = this._grid.getFirstPinnedRightIndex();
		if(colIndex &gt;= rightPinnedIndex) {
			return false; // The column is already pinned area
		}

		if(stationaryIdx &gt;= 0 &amp;&amp; colIndex &lt;= stationaryIdx) {
			return false;
		}

		this.moveColumnById(colIndex, rightPinnedIndex);
		rightPinnedCount += 1;
		leftPinnedCount -= 1;
	} else {
		if(colIndex &lt; leftPinnedCount) {
			return false; // The column is already pinned area
		}
		if(!leftPinnedCount) {
			if(stationaryIdx &gt;= 0) {
				leftPinnedCount = stationaryIdx;
				if(colIndex &gt; stationaryIdx) {
					leftPinnedCount++;
				}
			}
		}
		this.moveColumnById(colIndex, leftPinnedCount);
	}

	this._grid.freezeColumn(leftPinnedCount, rightPinnedCount);
	return true;
};
/** Unpin column from the left side by moving the specified column to the end of the frozen columns. &lt;br&gt;
* The method will do nothing if the specified column is not pinned on the left side.
* @public
* @param {Grid~ColumnReference|Array.&lt;Grid~ColumnReference&gt;} colRef
* @param {Grid~ColumnReference=} dest The unpinned column will be placed before the destination position after the operation
* @return {boolean}
*/
Grid.prototype.unpinColumn = function(colRef, dest) {
	if(Array.isArray(colRef)) {
		var ary = colRef;
		var len = ary.length;

		var dirty = 0;
		for(var i = len; --i &gt;= 0;) { // WARNING: unpinning is done in reversed order
			dirty |= this._unpinColumn(ary[i], dest);
		}
		return dirty ? true : false;
	}
	return this._unpinColumn(colRef, dest);
};
/** @private
* @param {Grid~ColumnReference} colRef
* @param {Grid~ColumnReference=} dest The unpinned column will be placed before the destination position after the operation
* @return {boolean}
*/
Grid.prototype._unpinColumn = function(colRef, dest) {
	var colIndex = this.getColumnIndex(colRef);
	if(colIndex &lt; 0) {
		return false;
	}

	var leftPinnedCount = this._grid.getPinnedLeftColumnCount();
	var rightPinnedCount = this._grid.getPinnedRightColumnCount();
	var colCount = this.getColumnCount();
	var firstRightPinnedIndex = colCount - rightPinnedCount;

	if(colIndex &gt;= leftPinnedCount &amp;&amp; colIndex &lt; firstRightPinnedIndex) {
		return false;
	}

	var srcId = null;
	var destId = null;
	if(dest != null) {
		var destIdx = this.getColumnIndex(dest);
		destId = this.getColumnId(destIdx);
		srcId = this.getColumnId(colIndex);
	}

	var stationaryIdx = this._grid.getStationaryColumnIndex();

	if(colIndex &lt; leftPinnedCount) {
		if(colIndex &gt; stationaryIdx) {
			this.moveColumnById(colIndex, leftPinnedCount);
		}

		this._grid.freezeColumn(leftPinnedCount - 2, rightPinnedCount); // Column index is used for freezing
	} else if(colIndex &gt;= firstRightPinnedIndex) {
		if(colIndex &gt; stationaryIdx) {
			this.moveColumnById(colIndex, firstRightPinnedIndex);
		}

		this._grid.freezeColumn(leftPinnedCount - 1, rightPinnedCount - 1); // Column index is used for freezing
	}

	if(colIndex &gt; stationaryIdx) {
		if(destId != null) {
			this.moveColumnById(srcId, destId);
		}
	}

	return true;
};
/** A shorthand to unpin all columns from the left hand side
* @public
* @return {boolean}
*/
Grid.prototype.unpinAllColumns = function() {
	var leftPinnedCount = this._grid.getPinnedLeftColumnCount();
	var rightPinnedCount = this._grid.getPinnedRightColumnCount();
	if(!leftPinnedCount &amp;&amp; !rightPinnedCount) {
		return false;
	}
	this._grid.freezeColumn(-1, 0); // Column index is used for left freezing and column count is used for right freezing
	return true;
};

/** @private
* @param {Object} e
*/
Grid.prototype._onColumnHeaderBinding = function(e) {
	if(e["sectionType"] !== "title" || e["sectionIndex"] &gt; 0) {
		return; // WARNING: Assume that only the first title section is owned by the grid. Anything else is assumed to be generated by plugins
	}

	var c = e["fromColIndex"];
	var toC = e["toColIndex"];
	while(c &lt; toC) {
		this._renderColumnHeader(c++, e);
	}
};
/** @private
* @param {number=} colIndex
* @param {Object} arg
*/
Grid.prototype._renderColumnHeader = function(colIndex, arg) {
	var colDef = this.getColumnDefinition(colIndex);
	if(!colDef) {
		return;
	}
	var customRenderer = colDef.getHeaderRenderer();
	var tSection = arg.section;
	var rowCount = tSection.getRowCount();
	arg["colIndex"] = colIndex;
	arg["columnDef"] = colDef;

	var colName = colDef.getName();
	var colTooltip = colDef.getTooltip();
	var headerAlignment = colDef.getHeaderAlignment();

	for(var r = 0; r &lt; rowCount; ++r) {
		var tCell = tSection.getCell(colIndex, r, false);
		// Default behaviors
		tCell.setContent(colName);
		tCell.setTooltip(colTooltip);
		tCell.setStyle("textAlign", headerAlignment);

		if(customRenderer) {
			arg["rowIndex"] = r;
			arg["cell"] = tCell;
			customRenderer(arg);
		}
	}
};
/** @public
*/
Grid.prototype.updateColumnTitle = function() {
	if(this._columnTitleConflator.conflate()) {
		return;
	}
	var tss = this._grid.getSectionSettings("title"); // WARNING: Assume that only the first title section is owned by the grid
	if(tss) {
		tss.rerender();
	}
};
/** @public
* @return {boolean}
*/
Grid.prototype.isSorting = function() {
	return this._stp.isSorting();
};
/** @public
* @return {number}
*/
Grid.prototype.getSortedColumnIndex = function() {
	return this._stp.getSortedColumnIndex();
};
/** @public
* @return {string} "a" for "ascending, "d" for descending, and "n" for none/noOrder
*/
Grid.prototype.getSortOrder = function() {
	return this._stp.getSortOrder();
};
/** @public
*/
Grid.prototype.clearSort = function() {
	this._stp.clearSortState(); // WARNING: No event is dispatched
};

/** @private
* @param {!Object} e
*/
Grid.prototype._onDataChanged = function(e) {
	var rowData = e["rowData"]; // Use rowData to retrieve corresponding subscription object
	if (!rowData) {
		return; // This must be a global change
	}
	var rowDef = rowData[ROW_DEF];

	if(rowDef) {
		var rowId = rowDef.getRowId();
		if(rowId) {
			// e["rid"] could be from JET/RTK (rowId + ric) or static data update (rowId)
			var curRowData = this._dc.getRowData(e["rid"]);
			if (curRowData) {
				if(rowDef.addUpdate(e)) { // This is the only place that update array can grow. It is used for blinking data.
					this._dt._hasNewUpdates = true; // Mark data table for cleaning it up later
				}
				this._updateStreamingData();
			} else if(rowDef.isAutoGenerated()) { // Subscription and its parent has been removed by Real-time provider
				rowDef.setParent(null); // Manually remove child reference from its parent
				this._removeRow(rowDef);
			}
		}
		return;
	}

	// The new data update has no row definition, meaning that we have found a new constituent from a chain.
	var subId = rowData[SUB_ID]; // The constituent will share the same sub id as its parent
	if(subId) {
		var parentDef = this._getRowDefinitionById(subId);
		if(parentDef &amp;&amp; parentDef.getRic() !== rowData["RIC"]) { // TODO: Check for delayed ric
			if(!this._chainMembers) {
				this._chainMembers = {};
			}
			if(!this._chainMembers[e["rid"]]) { // Prevent duplication
				this._chainMembers[e["rid"]] = rowData;
				this._addMemberOfChain(rowData);
			}
		}
	}
};
/** @private
* @param {!Object} rowData
*/
Grid.prototype._addMemberOfChain = function(rowData) {
	if(this._chainConflator.conflate(rowData)) {
		return;
	}

	var rows = this._chainConflator.popAllData(); // This must have no duplication
	var len = rows ? rows.length : 0;
	var i;

	var prevState = false;
	if(len &gt; 1) {
		prevState = this._dt.freeze(); // Avoid sorting for each insertion
	}
	var childDefs = [];
	for(i = 0; i &lt; len; ++i) {
		rowData = /** @type{!Object} */(rows[i]);
		var subId = rowData[SUB_ID];
		var parentDef = this._getRowDefinitionById(subId);
		if(parentDef) {
			var childDef = parentDef.addConstituent(/** @type{string} */(rowData["RIC"]), this._dt);
			if(childDef) {
				childDefs.push(childDef);
			} // else { // childDef has already been added
		}
	}
	this._chainMembers = null; // Clear all waiting chain members

	var childCount = childDefs.length;
	if(childCount) {
		for(i = childCount; --i &gt;= 0;) {
			this._connector.addRic(childDefs[i]); // TODO: JET/RTK should not re-subscribe this
		}
	}
	if(len &gt; 1) {
		this._dt.freeze(prevState);
	}
};

/** @private
*/
Grid.prototype._updateStreamingData = function() {
	if(this._streamingConflator.conflate()) {
		return;
	}

	if(this._dt) {
		this._dt.classifySegments();
		this._dt.dispatchGlobalChange();
	}
};

/** @private
* @param {Object} e
*/
Grid.prototype._onPreDataSorting = function (e) {
	var objs = this._stp.getSortedColumns();

	this._sorter.reset();
	if(Array.isArray(objs)) {
		var sortCount = objs.length;
		for(var i = 0; i &lt; sortCount; ++i) {
			var obj = objs[i];
			var field = obj["field"] || "";
			var colIndex = obj["colIndex"];
			var colDef = (colIndex &gt;= 0) ? this.getColumnDefinition(colIndex) : null;

			var rowSorting = false;
			var sortLogic = null;
			if(colDef) {
				field = colDef.getField(); // WARNING: Field and logic could be out of sync
				rowSorting = colDef.isRowSorting();
				sortLogic = colDef.getSorter();
			}
			// TODO: get sortLogic from DataView
			// if(!sortLogic &amp;&amp; field) {
			// sortLogic = state["sortLogic"];
			// }

			this._sorter.addColumnContext(field, sortLogic, rowSorting, obj["sortOrder"], colIndex, colDef);
		}
	}

	this._columnSorter = this._sorter.getSorter();
};
/** @private
* @param {RowDefinition} rowDefA
* @param {RowDefinition} rowDefB
* @param {number} order
* @return {number}
*/
Grid.prototype._mainSorter = function (rowDefA, rowDefB, order) {
	return this._columnSorter(rowDefA, rowDefB, order);
};

/** @private
* @param {Object} e
*/
Grid.prototype._onPostSectionDataBinding = function(e) {
	if(e["actualUpdate"]) {
		this._asyncClearDataUpdates();
	}
};
/** @private
*/
Grid.prototype._asyncClearDataUpdates = function() {
	setTimeout(this._clearDataUpdates, 0);
};
/** @private
*/
Grid.prototype._clearDataUpdates = function() {
	if(!this._dt || !this._dt._hasNewUpdates) {
		return;
	}
	var rowIds = this._dt.getAllRowIds(true); // Use shallow copy for speed
	for(var i = rowIds.length; --i &gt;= 0;) {
		var rowData = this._dt.getRowData(rowIds[i]);
		var rowDef = rowData[ROW_DEF];
		rowDef.resetUpdates();
	}
};

/** @public
* @return {DataView}
*/
Grid.prototype.getDataView = function() {
	return this._dv;
};
/** @public
* @param {number} pageIndex
* @return {boolean}
*/
Grid.prototype.setPage = function(pageIndex) {
	return this._dv.setPage(pageIndex);
};
/** @public
* @param {number} size
*/
Grid.prototype.setPageSize = function(size) {
	this._dv.setPageSize(size);
};
/** @public
* @return {number}
*/
Grid.prototype.getPageIndex = function() {
	return this._dv.getPageIndex();
};
/** @public
* @return {number}
*/
Grid.prototype.getPageSize = function() {
	return this._dv.getPageSize();
};
/** @public
* @return {number}
*/
Grid.prototype.getPageCount = function() {
	return this._dv.getPageCount();
};

/** @description Toggle between expanded and collapsed chain index
 * @public
 * @param {Grid~RowReference} rowRef
 */
Grid.prototype.toggleChain = function(rowRef) {
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		rowDef.toggleChain();
	}
};
/**
 * @public
 * @param {Grid~RowReference} rowRef
 * @param {Array.&lt;string&gt;} fields
 * @return {boolean}
 */
Grid.prototype.setClassification = function(rowRef, fields) {
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef) {
		return this._dt.setSegmentClassification(rowDef.getRowId(), fields);
	}
	return false;
};

/** Check element in the grid element
 * @public
 * @param {Element} elem
 * @return {boolean}=true if an element from the parameter is inside a grid element
 */
Grid.prototype.contains = function(elem) {
	if(elem) {
		// This will impact the contents within the rt-grid element, but not those outside of it, such as the wrapper elements efx-grid and emerald-grid.
		return this._topNode.contains(elem);
	}
	return false;
};

/** Check grid element is focused
 * @public
 * @return {boolean}
 */
Grid.prototype.isFocused = function() {
	var activeElement = document.activeElement;
	if(!activeElement || !activeElement.shadowRoot) {
		// active element is not in the shadow DOM. try using contains method to check
		return this.contains(activeElement);
	}
 	// For wrapper scenarios, such as efx-grid or efx-grid
	return  activeElement.shadowRoot === this._topNode.parentNode;
};
/** @description Focus grid element without moving window scrollbar
 * @public
 */
Grid.prototype.focus = function() {
	this._grid.focus();
};
/** Request re-rendering of content row by triggering data binding event without any change in data model
 * @public
 */
Grid.prototype.requestRowRefresh = function() {
	this._grid.requestRowRefresh();
};
/** Force recalculation of grid's layout
 * @public
 */
Grid.prototype.updateLayout = function() {
	this._grid.updateLayout();
};
/** Get extension instance
* @public
* @param {string} str Extension name
* @return {*} Returns null, if the specified extension does not exist
*/
Grid.prototype.getExtension = function(str) {
	if(str) {
		return this._grid.getPlugin(str.replace(/Extension/ig, ""));
	}
	return null;
};

/** @private
* @param {Object} e
*/
Grid.prototype._onFormulaDataChanged = function(e) {
	if (this._formulaConflator.conflate()) {
		return;
	}

	// TODO: Check if we need to recompose the data in the data composed method
	this._recalculateFormulas(); // Force recalculation of user formula
	this._updateRowData(); // Re-render the data
};
/** @private
* @param {Object} e
*/
Grid.prototype._onFormulaDataRequired = function(e) {
	// if(obj["field"]) {
	// this._registerFieldToDataProvider(obj); TODO
	// if(this._dataRequiredTimerId) {
	// window.clearTimeout(this._dataRequiredTimerId);
	// }
	// this._dataRequiredTimerId = window.setTimeout( this._recalculateFormulas, 0); // Force recalculation of all rows
	// }
};

/** @private
* @param {Object} e
*/
Grid.prototype._onDataComposed = function(e) {
	var values = e["changes"];
	if(!values) {
		return; // Cannot do data composition if there is no change in data
	}

	var rowData = e["rowData"];
	if(!rowData) {
		return; // Row could already be removed or global change event is sent
	}

	var rowDef = rowData[ROW_DEF];
	if(!rowDef) {
		return;
	}
	if(!rowDef.getDataSource()) {
		return; // Somehow, rowDef is invalid and doesn't have data source
	}

	if(this._autoDateConversion) { // auto data conversion
		var field, value, dataType, colDef;
		for(field in values) {
			colDef = this._getColumnDefinition(field);
			if(colDef) {
				dataType = colDef.getDataType();
			} else {
				dataType = ColumnDefinition.getDataType(field);
			}

			if(dataType === "datetime") {
				value = values[field];
				rowDef.setData(field + "_RAW", value);
				value = DateTime.toDateObject(value);
				rowDef.setData(field, value); // TODO: Check if this trigger data change multiple times
			}
		}
	}

	if(this.hasListener("dataComposed")) {
		e["grid"] = this;
		e["rowDef"] = rowDef;
		this._dispatch("dataComposed", e);
	}

	this._recalculateFormulas(e);
};
/** @private
* @param {Object} e
*/
Grid.prototype._onSubSegmentChanged = function(e) {
	var insertionList = /** @type{Array.&lt;Segment&gt;} */(e["insertionList"]);
	var removalList = /** @type{Array.&lt;string&gt;} */(e["removalList"]);
	var removedRows = /** @type{Object} */(e["removedRows"]);

	var i;
	var removalCount = removalList.length;
	var rowDef = null;
	for(i = 0; i &lt; removalCount; i++) {
		var rid = removalList[i];
		var removedRow = removedRows[rid];
		if(removedRow) {
			rowDef = removedRow[ROW_DEF];
			if(rowDef) {
				rowDef.dispose();
				removedRow[ROW_DEF] = null;
			}
		}
	}

	var insertionCount = insertionList.length;
	for(i = 0; i &lt; insertionCount; i++) {
		var segment = insertionList[i];
		// var parentId = segment.getParentId();
		var segmentId = segment.getId();
		rowDef = new RowDefinition({
			"segmentId": segmentId
		});
		rowDef.setDataSource(this._dc);
		rowDef.registerToView(this._dv);
	}
};

/** @private
* @param {Object=} e
*/
Grid.prototype._recalculateFormulas = function(e) {
	if(!this._fnEngine || this._fnEngine.getFormulaCount() &lt;= 0) {
		return;
	}

	if(e &amp;&amp; e["rid"]) {
		this._fnEngine.calculate(/** @type{Object.&lt;string, *&gt;} */ (e["rowData"]), /** @type{Object.&lt;string, *&gt;} */ (e["changes"]));
	} else {
		var rows = this._dc ? this._dc.getAllRowData() : null; // Slow

		var rowCount = rows ? rows.length : 0;
		for(var r = 0; r &lt; rowCount; ++r) { // WARNING: This is very slow
			this._fnEngine.calculate(rows[r]);
		}
	}
};

/** @private
* @param {Object} e The updated data from snapshot filler when it request data from JET/RTK
*/
Grid.prototype._snapshotFillerDataChanged = function (e) {
	if (!this._dt) return;

	var data = e.data;
	if(e.timeSeries) {
		this._updateTimeSeriesFields(e); // Increase or decrease time series field
	} else {
		for (var ric in data) {
			this.setRicData(ric, data[ric]);
		}
	}

	if(!this._lastPollingRequest) { // This is the first time we receive successful ADC response
		this._lastPollingRequest = 1; // Allow polling to be started
	}
	this._startPolling();
};
/** @private
*/
Grid.prototype._startPolling = function () {
	if(this._pollingEnabled &amp;&amp; this._pollingInterval) {
		if(this._lastPollingRequest &amp;&amp; !this._pollingTimerId) {
			var now = new Date();
			this._lastPollingRequest = now.getTime();
			this._pollingTimerId = setTimeout(this._onPollingInterval, this._pollingInterval);
		}
	}
};
/** @private
*/
Grid.prototype._onPollingInterval = function () {
	this._pollingTimerId = 0;
	if(this._pollingEnabled &amp;&amp; this._pollingInterval) {
		this.refreshADCData();
		this._startPolling();
	}
};
/** @public
* @param {boolean=} activated=true
*/
Grid.prototype.activateADCPolling = function (activated) {
	if(activated !== false) {
		this._pollingEnabled = true;
		// Make immediate request after re-activation if it has been a long time
		var now = new Date();
		if(this._lastPollingRequest) {
			var diff = now.getTime() - this._lastPollingRequest;
			if(diff &gt; this._pollingInterval) {
				this.refreshADCData();
			}
		}
		this._startPolling();
	} else {
		this._pollingEnabled = false;
	}
};
/** Force re-requesting ADC data to immediately update the data
* @public
* @return {boolean} Return true, if a request has been made
*/
Grid.prototype.refreshADCData = function () {
	var dirty = this._snapshot.addFields(this._connector.getAllFields());
	if(dirty) {
		dirty = this._snapshot.addRics(this._connector.getAllRics());
		if(dirty) {
			return true;
		}
	}
	this._lastPollingRequest = 0; // No ADC field or RIC detected. Prevent polling from continuing
	return false;
};

/** @private
*/
Grid.prototype._onAutoLayoutUpdate = function() {
	var elem = this._topNode;

	var cw = elem.clientWidth;
	if(cw !== this._clientWidth) {
		this._clientWidth = cw;
		this.updateLayout();
	}
};

/** @description Log DataTable to console. By default, this will log only fields specified in the column definition. To see other column data use "colNames" options
 * @public
 * @param {Object=} opt_options { "colNames": Array.&lt;string&gt;, "rowCount": number, "startIndex": number, "getter": function(Object, string):* }
 */
Grid.prototype.logDT = function(opt_options) {
	var rowDefs = this._getAllRowDefinitions();
	this._logData(rowDefs, opt_options);
};
/** @description Log DataView to console. By default, this will log only fields specified in the column definition. To see other column data use "colNames" options
 * @public
 * @param {Object=} opt_options { "colNames": Array.&lt;string&gt;, "rowCount": number, "startIndex": number, "getter": function(Object, string):* }
 * @example
// Options have the following format:
// {
//    "colNames": Array.&lt;string&gt;,
//    "rowCount": number,
//    "startIndex": number,
//    "getter": function(rowData:Object, colName:string):*,
//    "withRowIds": boolean
// }
grid.logDV({"rowCount": 10}); // Showing 10 records
 */
Grid.prototype.logDV = function(opt_options) {
	var rowDefs = this.getRowDefinitions();
	this._logData(rowDefs, opt_options);
};
/** Log the collection of data to console
 * @private
 * @param {!Array.&lt;RowDefinition&gt;} rowDefs
 * @param {Object=} options
 */
Grid.prototype._logData = function(rowDefs, options) {
	if(!options) {
		options = {};
	}
	if(!options["colNames"]) {
		// TODO: Get all required fields and eliminate duplicate fields
		options["colNames"] = this.getColumnFields();
	}
	var tbl = DataCache.constructTable(rowDefs.map(toRowData), options);

	console.table(tbl); // eslint-disable-line
};
/** @public
* @description Replace existing row with a new row. Row ID would be changed, after row is replaced.
* @param {Grid~RowReference} rowRef Reference (i.e. row index, row id, or row definition) of the insert position
* @param {Object=} rowOption
* @returns {Object}
*/
Grid.prototype.replaceRow = function(rowRef, rowOption) {
	var rowId = this._getRowId(rowRef);
	var rowDef = this._getRowDefinitionByRef(rowRef);
	if(rowDef.isAutoGenerated()) { // Users cannot replace auto-generated
		return  null;
	}
	var configObj = rowDef.getConfigObject();

	if(deepEqual(configObj, rowOption)){
		return null;
	} else {
		var insertedRow = this.insertRow(rowOption, rowId);
		this.removeRow(rowId);
		return insertedRow;
	}
};

export { Grid };
export default Grid;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColumnDefinition.html">ColumnDefinition</a></li><li><a href="DataConnector.html">DataConnector</a></li><li><a href="Grid.html">Grid</a></li><li><a href="ReferenceCounter.html">ReferenceCounter</a></li><li><a href="RowDefinition.html">RowDefinition</a></li><li><a href="RowDefSorter.html">RowDefSorter</a></li><li><a href="SnapshotFiller.html">SnapshotFiller</a></li><li><a href="StyleLoader.html">StyleLoader</a></li></ul><h3>Events</h3><ul><li><a href="Grid.html#event:adcDataReceived">adcDataReceived</a></li><li><a href="Grid.html#event:beforeRowRemoved">beforeRowRemoved</a></li><li><a href="Grid.html#event:dataComposed">dataComposed</a></li><li><a href="Grid.html#event:fieldAdded">fieldAdded</a></li><li><a href="Grid.html#event:fieldRemoved">fieldRemoved</a></li><li><a href="Grid.html#event:pageCountChanged">pageCountChanged</a></li><li><a href="Grid.html#event:pageIndexChanged">pageIndexChanged</a></li><li><a href="Grid.html#event:ricAdded">ricAdded</a></li><li><a href="Grid.html#event:ricRemoved">ricRemoved</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COL_DEF">COL_DEF</a></li><li><a href="global.html#ROW_DEF">ROW_DEF</a></li><li><a href="global.html#ROW_TYPES">ROW_TYPES</a></li></ul>
</nav>


<script src="scripts/linenumber.js"> </script>
<script src="scripts/prettify.js"> </script>
<script> prettyPrint(); </script>
</body>
</html>
