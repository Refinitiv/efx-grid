<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: SnapshotFiller.js</title>

    <script src="scripts/prettify.js"> </script>
    <script src="scripts/lang-css.js"> </script>
    <!--[if lt IE 9]&gt;
      &lt;script src="//html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
    &lt;![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/default.css">
    <link type="text/css" rel="stylesheet" href="styles/elf-template.css">
</head>

<body>

<div id="main-template" class="elf-template">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable */
import Grid from "./Grid.js";
import {Ext} from '../../node_modules/tr-grid-util/es6/Ext.js';
import {EventDispatcher} from '../../node_modules/tr-grid-util/es6/EventDispatcher.js';
import {FieldDefinition} from './FieldDefinition.js';

/** @private
* @param {Object} obj
* @return {boolean}
*/
var isEmptyObject = function (obj) {
	for (var key in obj) {
		return false;
	}
	return true;
};

/** This class make requesting ADC field easier by encapsulating JET.Data APIs and mapping data to the row
* @constructor
* @extends {EventDispatcher}
*/
var SnapshotFiller = function () {
	this._onRequest = this._onRequest.bind(this);

	this._rics = {};
	this._fields = {};
	this._adcOptions = { // TODO: support requesting level parameter
		productId: "001"
	};
};
Ext.inherits(SnapshotFiller, EventDispatcher);

//#region Private Members
/** @type {number}
* @private
*/
SnapshotFiller.prototype._timerId = 0;
/** @type {!Object.&lt;string, number&gt;}
* @private
*/
SnapshotFiller.prototype._rics;
/** @type {!Object.&lt;string, number&gt;}
* @private
*/
SnapshotFiller.prototype._fields;
/** @type {!*}
* @private
*/
SnapshotFiller.prototype._rtk;
/** @type {!Grid~ADCOptions}
* @private
*/
SnapshotFiller.prototype._adcOptions = null;
//#endregion Private Members

/** @public
* @param {*} rtk RTK instance
*/
SnapshotFiller.prototype.setRTK = function (rtk) {
	this._rtk = rtk;
};

/** @public
* @param {Grid~ADCOptions} adcOptions ADC requesting level parameter options
*/
SnapshotFiller.prototype.setADCOptions = function (adcOptions) {

	var val = adcOptions["productId"];
	if(val) {
		this._adcOptions.productId = val;
	}
	// TODO: support requesting level parameter https://confluence.refinitiv.com/display/ADC/Request+level+parameters
	// var val = adcOptions["lang"];
	// if(val) {
	// 	this._adcOptions.lang = val;
	// }
	// var val = adcOptions["cache"];
	// if(val) {
	// 	this._adcOptions.cache = val;
	// }
};

/** @public
* @param {string} ric
*/
SnapshotFiller.prototype.addRic = function (ric) {
	// TODO: since we use ric instead of rowDef
	// We need to find a way to check isSubscribing and isAutoGenerated before add ric
	// if (!rowDef.isSubscribing()) { // // Only real-time row (non-empty non-header) can be registered for snapshot.
	// 	if (!rowDef.isAutoGenerated()) {  // However, chain constituents (auto generated) are still eligible.
	// 		return;
	// 	}
	// }

	if (ric &amp;&amp; !this._rics[ric]) {
		this._rics[ric] = 1;
		this._request();
	}
};
/** @public
* @param {Array.&lt;string&gt;} rics
* @return {boolean}
*/
SnapshotFiller.prototype.addRics = function (rics) {
	var len = rics ? rics.length : 0;
	var dirty = false;
	for(var i = 0; i &lt; len; ++i) {
		var ric = rics[i];
		if (ric &amp;&amp; !this._rics[ric]) {
			this._rics[ric] = 1;
			dirty = true;
		}
	}
	if(dirty) {
		this._request();
		return true;
	}
	return false;
};
/** @public
* @param {string} str
*/
SnapshotFiller.prototype.addField = function (str) {
	if(this._addField(str)) {
		this._request();
	}
};
/** @public
* @param {Array.&lt;string&gt;} fields
* @return {boolean}
*/
SnapshotFiller.prototype.addFields = function (fields) {
	var len = fields.length;
	var dirty = 0;
	for(var i = 0; i &lt; len; ++i) {
		dirty |= this._addField(fields[i]);
	}
	if(dirty) {
		this._request();
		return true;
	}
	return false;
};

/** @private
* @param {string} str
* @return {number}
*/
SnapshotFiller.prototype._addField = function (str) {
	if(SnapshotFiller.isValidField(str)) {
		if(!this._fields[str]) {
			this._fields[str] = 1;
			return 1;
		}
	}
	return 0;
};
/** @public
* @function
* @param {string} str
* @returns {boolean}
*/
SnapshotFiller.isValidField = function(str) {
	// Only field with TR. is considered as ADC field
	return (str &amp;&amp; str.indexOf("TR.") === 0) ? true : false;
};

/** @private
*/
SnapshotFiller.prototype._request = function () {
	if(!this._timerId) {
		this._timerId = setTimeout(this._onRequest, 0);
	}
};
/** @private
*/
SnapshotFiller.prototype._onRequest = function () {
	this._timerId = 0;

	var jet = window["JET"]; // Assume that JET is already exist.
	if (this._rtk) {
		if (!this._rtk.Data) {
			return; // Require RTK.Data plugin to get snapshot data
		}
	} else if (!jet || !jet["ContainerDescription"] || (typeof jet["Data"] !== "function")) {
		return; // Require JET to get snapshot data or JET is not ready to use
	}

	// Retrieve instruments and ADC fields
	var instruments = Object.keys(this._rics);

	var i;
	var fields = [];
	var timeSeriesFields = [];
	for (var field in this._fields) {
		if(!FieldDefinition.isTimeSeriesField(field)) {
			fields.push(field);
		} else {
			timeSeriesFields.push(field);
		}
	}
	var fieldLen = fields.length;
	var timeSeriesFieldLen = timeSeriesFields.length;

	if ( (!fieldLen &amp;&amp; !timeSeriesFieldLen ) || !instruments.length) { // No ADC field or real-time RIC
		return;
	}

	// Clean up members, preparing for the next request
	this._rics = {};
	this._fields = {};

	var onSuccess, payload;
	if (this._rtk) {
		var strFields;
		// Request time serie fields
		if(timeSeriesFields.length &gt; 0) {
			// request time series field
			var strtTimeSeriesFields = timeSeriesFields.join(',');
			payload = {
				"method": "select",
				"formula": strtTimeSeriesFields,
				"identifiers": instruments,
				"productId": this._adcOptions.productId,
				"output": "Col,date|,Row,In|,va,T,NoEmptyTickers" // For customize output server, for more information please visit "https://confluence.refinitiv.com/display/ADC/Data+Cloud+Output+Format"
			};
			onSuccess = this._onRTKTimeSeriesSuccess.bind(this, timeSeriesFields);
			this._rtk.Data.Adc
				.request(payload)
				.then(onSuccess)
				.catch(function (err) {
					console.log(err);
				});
		}

		// Request normal adc field
		if(fields.length &gt; 0) {
			strFields = fields.join(',');
			payload = {
				"method": "select",
				"formula": strFields,
				"identifiers": instruments,
				"productId": this._adcOptions.productId,
				"output": "Col,In,va,T,NoEmptyTickers" // For customize output server, for more information please visit "https://confluence.refinitiv.com/display/ADC/Data+Cloud+Output+Format"
			};
			onSuccess = this._onRTKSuccess.bind(this, fields);
			this._rtk.Data.Adc
				.request(payload)
				.then(onSuccess)
				.catch(function (err) {
					console.log(err);
				});
		}


	} else {
		var reqFields = [];
		for(i = 0; i &lt; fieldLen; i++) {
			reqFields.push({ "name": fields[i] });
		}
		payload = {
			"instruments": instruments,
			"fields": reqFields
		};
		onSuccess = this._onJETSuccess.bind(this, fields);
		jet["Data"]("datagrid")
			.then(function (service) { return service["request"](payload); })
			.then(JSON.parse)
			.then(onSuccess)
			.catch(function (err) {
				console.log(err);
			});
	}
};

/** @private
* @function
* @param {Array.&lt;string&gt;} fields
* @param {string} serverResult
*/
SnapshotFiller.prototype._onJETSuccess = function (fields, serverResult) {
	this._dispatch("adcDataReceived", serverResult);
	var data2D = serverResult["data"];
	var svHeaders = serverResult["headers"] &amp;&amp; serverResult["headers"][0];

	if (!Array.isArray(data2D) || !Array.isArray(svHeaders)) {
		return; //TODO: Return Promise.reject(errMsg);
	}


	// Server will return field only in UPPERCASE
	// ex. requestField = TR.Volume ===&gt; serverField = TR.VOLUME
	// so we need convert UPPERCASE to be original
	var i, field, ric;
	var j = 1; //  to skip instrument index, use j = 1
	var fLength = fields.length;
	var hLength = svHeaders.length;
	var headers = new Array(hLength);
	for (i = 0; i &lt; fLength &amp;&amp; j &lt; hLength; i++) {
		field = fields[i];
		if (svHeaders[j].field === field.toUpperCase()) {
			headers[j] = field;
			j++;
		}
	}

	var len = data2D.length;
	var fieldLen = headers.length;
	var ricMap = {};

	// TODO: Freeze the data view before setting multiple data
	for (i = 0; i &lt; len; i++) {
		var dataRow = data2D[i];
		ric = dataRow[0];

		if (ricMap[ric]) {
			continue; // we interested only first row of ric
		}

		var snapData = ricMap[ric] = {};

		// loop for create rowData for update
		for (j = 1; j &lt; fieldLen; j++) { //  to skip instrument index, use j = 1
			var value = dataRow[j];
			if (value != null &amp;&amp; value !== "") {
				field = headers[j];
				snapData[field] = value;
			}
		}
	}

	// return result only ric that has update data
	var updatedData = {};
	for (ric in ricMap) {
		var obj = ricMap[ric];
		if (!isEmptyObject(obj)) {
			updatedData[ric] = obj;
		}
	}

	this._dispatch("dataChanged", {
		data: updatedData
	});
};

/** @private
* @function
* @param {Array.&lt;string&gt;} fields
* @param {string} serverResult
*/
SnapshotFiller.prototype._onRTKSuccess = function (fields, serverResult) {
	this._dispatch("adcDataReceived", serverResult);
	var data2D = serverResult["rows"];
	var svHeaders = serverResult["rows"] &amp;&amp; serverResult["rows"][0];
	if (!Array.isArray(data2D) || !Array.isArray(svHeaders)) {
		return; //TODO: Return Promise.reject(errMsg);
	}

	// Server will return field only in UPPERCASE
	// ex. requestField = TR.Volume ===&gt; serverField = TR.VOLUME
	// so we need convert UPPERCASE to be original
	var i, field, ric;
	var j = 1; //  to skip instrument index, use j = 1
	var fLength = fields.length;
	var hLength = svHeaders.length;
	var headers = new Array(hLength);
	for (i = 0; i &lt; fLength &amp;&amp; j &lt; hLength; i++) {
		field = fields[i];
		if (svHeaders[j].r.toUpperCase() === field.toUpperCase()) {
			headers[j] = field;
			j++;
		}
	}

	var len = data2D.length;
	var fieldLen = headers.length;
	var ricMap = {};

	// TODO: Freeze the data view before setting multiple data
	for (i = 1; i &lt; len; i++) { // to skip column header index, use i = 1
		var dataRow = data2D[i];
		ric = dataRow[0];

		var snapData = ricMap[ric] = {};

		// loop for create rowData for update
		for (j = 1; j &lt; fieldLen; j++) { // to skip instrument index, use j = 1
			var value = dataRow[j];
			if (value != null &amp;&amp; value !== "") {
				if(typeof value !== 'object') {
					field = headers[j];
					snapData[field] = value;
				}
				// TODO : handled when a cell has a mistake and the value appears as {f: "1"} ( description error in fault attribute at index 1 ),
				// Therefore, we need to store information to the error field for this cell.
				// else {}

			}
		}
	}

	// return result only ric that has update data
	var updatedData = {};
	for (ric in ricMap) {
		var obj = ricMap[ric];
		if (!isEmptyObject(obj)) {
			updatedData[ric] = obj;
		}
	}

	this._dispatch("dataChanged", {
		data: updatedData
	});
};


/** @private
* @function
* @param {Array.&lt;string&gt;} fields
* @param {string} serverResult
*/
SnapshotFiller.prototype._onRTKTimeSeriesSuccess = function (fields, serverResult) {

	// TODO: noti the user for change structure
	this._dispatch("adcDataReceived", serverResult);
	var data2D = serverResult["rows"];
	var svHeaders = serverResult["rows"] &amp;&amp; serverResult["rows"][0];
	if (!Array.isArray(data2D) || !Array.isArray(svHeaders)) {
		return; // TODO: Return Promise.reject(errMsg);
	}

	var headerLen = svHeaders.length;

	var headerDates = [];
	var i, j;

	for (i = 2; i &lt; headerLen; i++) { // Start with 2 (Skip instrunment and date header)
		headerDates.push(svHeaders[i].v);
	}

	var ric, j, field;
	var len = data2D.length;
	var ricMap = {};
	var childrenFieldToParent = {};

	var fileNameToTSField = {};
	var count = 0;
	for (let i = 1; i &lt; len; i++) {
		var dataRow = data2D[i];
		var fieldName = dataRow[1];
		if(!fileNameToTSField[fieldName]) {
			fileNameToTSField[fieldName] = fields[count++];
		}   	
	}

	// TODO: Freeze the data view before setting multiple data
	for (i = 1; i &lt; len; i++) { // to skip column header index, use i = 1
		var dataRow = data2D[i];
		ric = dataRow[0];
		var fieldName = dataRow[1]; // ex. PRICECLOSE
		if(!ricMap[ric]) {
			ricMap[ric] = {};
		}
		var snapData = ricMap[ric];
		for (var k = 0; k &lt; headerDates.length; k++) {
			field = fileNameToTSField[fieldName].replace("TR.", "") + "_"  + headerDates[k]; // TODO: make support time series field definition cache
			childrenFieldToParent[field] = fileNameToTSField[fieldName];
			snapData[field] = dataRow[2 + k]; // Start with field value
		}
	}

	// return result only ric that has update data
	var dataMapping = {};
	for (ric in ricMap) {
		var obj = ricMap[ric];
		if (!isEmptyObject(obj)) {
			dataMapping[ric] = obj;
		}
	}

	this._dispatch("dataChanged", {
		data: dataMapping,
		timeSeries: true,
		childrenFieldToParent: childrenFieldToParent
	});
};

export { SnapshotFiller };
export default SnapshotFiller;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColumnDefinition.html">ColumnDefinition</a></li><li><a href="DataConnector.html">DataConnector</a></li><li><a href="Grid.html">Grid</a></li><li><a href="ReferenceCounter.html">ReferenceCounter</a></li><li><a href="RowDefinition.html">RowDefinition</a></li><li><a href="RowDefSorter.html">RowDefSorter</a></li><li><a href="SnapshotFiller.html">SnapshotFiller</a></li><li><a href="StyleLoader.html">StyleLoader</a></li></ul><h3>Events</h3><ul><li><a href="Grid.html#event:adcDataReceived">adcDataReceived</a></li><li><a href="Grid.html#event:beforeRowRemoved">beforeRowRemoved</a></li><li><a href="Grid.html#event:dataComposed">dataComposed</a></li><li><a href="Grid.html#event:fieldAdded">fieldAdded</a></li><li><a href="Grid.html#event:fieldRemoved">fieldRemoved</a></li><li><a href="Grid.html#event:pageCountChanged">pageCountChanged</a></li><li><a href="Grid.html#event:pageIndexChanged">pageIndexChanged</a></li><li><a href="Grid.html#event:ricAdded">ricAdded</a></li><li><a href="Grid.html#event:ricRemoved">ricRemoved</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COL_DEF">COL_DEF</a></li><li><a href="global.html#ROW_DEF">ROW_DEF</a></li></ul>
</nav>


<script src="scripts/linenumber.js"> </script>
<script src="scripts/prettify.js"> </script>
<script> prettyPrint(); </script>
</body>
</html>
